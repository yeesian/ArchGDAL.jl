using Test
import ArchGDAL;
const AG = ArchGDAL;
using Tables
using LibGEOS

@testset "test_tables.jl" begin
    @testset "Tables Support" begin
        dataset = AG.read(joinpath(@__DIR__, "data/point.geojson"))
        dataset1 = AG.read(
            joinpath(@__DIR__, "data/multi_geom.csv"),
            options = [
                "GEOM_POSSIBLE_NAMES=point,linestring",
                "KEEP_GEOM_COLUMNS=NO",
            ],
        )
        dataset2 = AG.read(
            joinpath(@__DIR__, "data/missing_testcase.csv"),
            options = [
                "GEOM_POSSIBLE_NAMES=point,linestring",
                "KEEP_GEOM_COLUMNS=NO",
            ],
        )
        @test dataset isa ArchGDAL.IDataset
        @test dataset1 isa ArchGDAL.IDataset
        @test dataset2 isa ArchGDAL.IDataset
        layer = AG.getlayer(dataset, 0)
        layer1 = AG.getlayer(dataset1, 0)
        layer2 = AG.getlayer(dataset2, 0)

        @testset "Tables methods" begin
            @test isnothing(Tables.schema(layer1))
            @test Tables.istable(typeof(layer)) == true
            @test Tables.rowaccess(typeof(layer)) == true

            features = collect(Tables.rows(layer1))
            @test length(features) == 2

            @test Tables.columnnames(features[1]) ==
                  (:point, :linestring, :id, :zoom, :location)
            @test ismissing(Tables.getcolumn(features[2], -5))
            @test ismissing(Tables.getcolumn(features[2], 0))
            @test Tables.getcolumn(features[1], 1) == "5.1"
            @test Tables.getcolumn(features[1], 2) == "1.0"
            @test Tables.getcolumn(features[1], 3) == "Mumbai"
            @test AG.toWKT(Tables.getcolumn(features[1], 4)) == "POINT (30 10)"
            @test AG.toWKT(Tables.getcolumn(features[1], 5)) ==
                  "LINESTRING (30 10,10 30,40 40)"
            @test Tables.getcolumn(features[1], :id) == "5.1"
            @test Tables.getcolumn(features[1], :zoom) == "1.0"
            @test Tables.getcolumn(features[1], :location) == "Mumbai"
            @test AG.toWKT(Tables.getcolumn(features[1], :point)) ==
                  "POINT (30 10)"
            @test AG.toWKT(Tables.getcolumn(features[1], :linestring)) ==
                  "LINESTRING (30 10,10 30,40 40)"
            @test ismissing(Tables.getcolumn(features[1], :fake))

            @test Tables.columnnames(features[2]) ==
                  (:point, :linestring, :id, :zoom, :location)
            @test ismissing(Tables.getcolumn(features[2], -5))
            @test ismissing(Tables.getcolumn(features[2], 0))
            @test Tables.getcolumn(features[2], 1) == "5.2"
            @test Tables.getcolumn(features[2], 2) == "2.0"
            @test Tables.getcolumn(features[2], 3) == "New Delhi"
            @test AG.toWKT(Tables.getcolumn(features[2], 4)) == "POINT (35 15)"
            @test AG.toWKT(Tables.getcolumn(features[2], 5)) ==
                  "LINESTRING (35 15,15 35,45 45)"
            @test Tables.getcolumn(features[2], :id) == "5.2"
            @test Tables.getcolumn(features[2], :zoom) == "2.0"
            @test Tables.getcolumn(features[2], :location) == "New Delhi"
            @test AG.toWKT(Tables.getcolumn(features[2], :point)) ==
                  "POINT (35 15)"
            @test AG.toWKT(Tables.getcolumn(features[2], :linestring)) ==
                  "LINESTRING (35 15,15 35,45 45)"
            @test ismissing(Tables.getcolumn(features[2], :fake))

            geom_names, field_names = AG.schema_names(AG.layerdefn(layer))
            @test collect(geom_names) == [Symbol("")]
            @test collect(field_names) == [:FID, :pointname]
            geom_names, field_names = AG.schema_names(AG.layerdefn(layer1))
            @test collect(geom_names) == [:point, :linestring]
            @test collect(field_names) == [:id, :zoom, :location]
        end

        @testset "Conversion to table for drivers: GeoJSON, ESRI Shapefile" begin
            TEST_DS_DRIVERS_FILE_EXTENSIONS = Dict(
                "ESRI Shapefile" => "",
                "GeoJSON" => ".geojson",
                "CSV" => ".csv",
                "GML" => ".gml",
                "KML" => ".kml",
                "GPKG" => ".gpkg",
                "FlatGeobuf" => ".fgb",
            )

            TEST_DS_FILENAME_STEM = "test_ds"

            """
                clean_test_files()

            Cleans test files generated by `get_test_dataset`
            """
            function clean_test_dataset_files()
                for (drvshortname, file_extension) in
                    TEST_DS_DRIVERS_FILE_EXTENSIONS
                    isfile(
                        joinpath(
                            @__DIR__,
                            "tmp",
                            TEST_DS_FILENAME_STEM * file_extension,
                        ),
                    ) && rm(
                        joinpath(
                            @__DIR__,
                            "tmp",
                            TEST_DS_FILENAME_STEM * file_extension,
                        ),
                    )
                    isfile(
                        joinpath(
                            @__DIR__,
                            "tmp",
                            TEST_DS_FILENAME_STEM * ".xsd",
                        ),
                    ) && rm(
                        joinpath(
                            @__DIR__,
                            "tmp",
                            TEST_DS_FILENAME_STEM * ".xsd",
                        ),
                    )
                    isfile(
                        joinpath(
                            @__DIR__,
                            "tmp",
                            TEST_DS_FILENAME_STEM * ".tmp",
                        ),
                    ) && rm(
                        joinpath(
                            @__DIR__,
                            "tmp",
                            TEST_DS_FILENAME_STEM * ".tmp",
                        ),
                    )
                    isdir(joinpath(@__DIR__, "tmp", TEST_DS_FILENAME_STEM)) &&
                        rm(
                            joinpath(@__DIR__, "tmp", TEST_DS_FILENAME_STEM),
                            recursive = true,
                        )
                end
            end

            """
                get_test_dataset(
                    drvshortname::AbstractString = "ESRI shapefile",
                    geomfamily::String = "line";
                    withmissinggeom::Bool = true,
                    withmissingfield::Bool = true,
                    withmixedgeomtypes::Bool = true,
                )::AG.IDataset

            # Build a test dataset from scratch
            with:
            - OGR driver: `drvshortname` ∈ `["ESRI Shapefile", "GeoJSON"]`
            - `"GeoJSON"` driver → 1 layer with 2 geometry columns
            - `"ESRI Shapefile"` driver → 2 layers with 1 geometry column
            1) with `wkbLineString` and `wkbMultiLineString` types
            2) with `wkbPolygon`, `wkbMultiPolygon` types  
            - Layers' geometry type set to `wkbUnknown` but modified by the OGR driver according to its specifications,
            - Each geometry has two additionnal fields `id::Int64` and `name::String`

            # Options
            - `withmissinggeom::Bool=true`: a missing geometry value per geom field
            - `withmissingfield::Bool=true`: a missing field value in `id` field
            - `withmixedgeomtypes::Bool=true`: a multi geometry value per geom field

            # Returns
            The corresponding IDataset

            """
            function get_test_dataset(
                drvshortname::AbstractString = "ESRI shapefile",
                geomfamily::String = "line";
                withmissinggeom::Bool = true,
                withmissingfield::Bool = true,
                withmixedgeomtypes::Bool = true,
            )::AG.IDataset

                # Build dataset filename
                filename = joinpath(
                    @__DIR__,
                    "tmp",
                    TEST_DS_FILENAME_STEM *
                    TEST_DS_DRIVERS_FILE_EXTENSIONS[drvshortname],
                )

                # Clean previously created files for new dataset
                clean_test_dataset_files()

                # Prepare data for dataset building
                data = Dict(
                    "line" => (
                        simple1 = (
                            name = "line1",
                            geom = AG.createlinestring([
                                (i, i + 1) for i in 1.0:3.0
                            ]),
                        ),
                        multi1 = (
                            name = "multiline1",
                            geom = AG.createmultilinestring([
                                [(i, i + 1) for i in j:j+3] for j in 1.0:5.0:6.0
                            ]),
                        ),
                        simple2 = (
                            name = "line2",
                            geom = AG.createlinestring([
                                (i, i + 1) for i in 3.0:5.0
                            ]),
                        ),
                        emptygeom = (name = "emptygeom", geom = missing),
                        emptyfield = (
                            name = "emptyid",
                            geom = AG.createlinestring([
                                (i, i + 1) for i in 5.0:7.0
                            ]),
                        ),
                    ),
                    "polygon" => (
                        simple1 = (
                            name = "polygon1",
                            geom = AG.createpolygon([
                                (0.0, 0.0),
                                (0.0, 1.0),
                                (1.0, 1.0),
                            ]),
                        ),
                        multi1 = (
                            name = "multipolygon1",
                            geom = AG.createmultipolygon([
                                [[(0.0, 0.0), (0.0, j), (j, j)]] for
                                j in 1.0:-0.1:0.9
                            ]),
                        ),
                        simple2 = (
                            name = "polygon2",
                            geom = AG.createpolygon([
                                (0.0, 0.0),
                                (0.0, -1.0),
                                (-1.0, -1.0),
                            ]),
                        ),
                        emptygeom = (name = "emptygeom", geom = missing),
                        emptyfield = (
                            name = "emptyid",
                            geom = AG.createpolygon([
                                (0.0, 0.0),
                                (-1.0, 0.0),
                                (-1.0, 1.0),
                            ]),
                        ),
                    ),
                )

                # Create dataset
                AG.create(
                    filename;
                    driver = AG.getdriver(drvshortname),
                ) do newdataset
                    AG.createlayer(
                        name = "test_layer",
                        dataset = newdataset,
                        geom = AG.wkbUnknown,
                    ) do newlayer
                        # Add geom and field defn
                        AG.addfielddefn!(newlayer, "id", AG.OFTInteger64)
                        AG.addfielddefn!(newlayer, "name", AG.OFTString)
                        id_idx = AG.findfieldindex(AG.layerdefn(newlayer), "id")
                        name_idx =
                            AG.findfieldindex(AG.layerdefn(newlayer), "name")
                        # Add features
                        AG.addfeature(newlayer) do newfeature
                            AG.setfield!(newfeature, id_idx, 1)
                            AG.setfield!(
                                newfeature,
                                name_idx,
                                data[geomfamily].simple1.name,
                            )
                            return AG.setgeom!(
                                newfeature,
                                0,
                                data[geomfamily].simple1.geom,
                            )
                        end
                        if withmixedgeomtypes
                            AG.addfeature(newlayer) do newfeature
                                AG.setfield!(newfeature, id_idx, 2)
                                AG.setfield!(
                                    newfeature,
                                    name_idx,
                                    data[geomfamily].multi1.name,
                                )
                                return AG.setgeom!(
                                    newfeature,
                                    0,
                                    data[geomfamily].multi1.geom,
                                )
                            end
                        else
                            AG.addfeature(newlayer) do newfeature
                                AG.setfield!(newfeature, id_idx, 2)
                                AG.setfield!(
                                    newfeature,
                                    name_idx,
                                    data[geomfamily].simple2.name,
                                )
                                return AG.setgeom!(
                                    newfeature,
                                    0,
                                    data[geomfamily].simple2.geom,
                                )
                            end
                        end
                        if withmissinggeom
                            AG.addfeature(newlayer) do newfeature
                                AG.setfield!(newfeature, id_idx, 3)
                                return AG.setfield!(
                                    newfeature,
                                    name_idx,
                                    data[geomfamily].emptygeom.name,
                                )
                                # No geom set
                            end
                        end
                        if withmissingfield
                            AG.addfeature(newlayer) do newfeature
                                AG.setfieldnull!(newfeature, id_idx)
                                AG.setfield!(
                                    newfeature,
                                    name_idx,
                                    data[geomfamily].emptyfield.name,
                                )
                                return AG.setgeom!(
                                    newfeature,
                                    0,
                                    data[geomfamily].emptyfield.geom,
                                )
                            end
                        end
                    end
                end

                return AG.read(filename)
            end

            """
                map_on_test_dataset(
                    f::Function,
                    drvshortname::AbstractString="ESRI shapefile", 
                    geomfamily::String="line"; 
                    withmissinggeom::Bool=true,
                    withmissingfield::Bool=true,
                    withmixedgeomtypes::Bool=true, 
                )::AG.IDataset

            # Build a test dataset from scratch
            with:
            - OGR driver: `drvshortname` ∈ `["ESRI Shapefile", "GeoJSON"]`
            - `"GeoJSON"` driver → 1 layer with 2 geometry columns
            - `"ESRI Shapefile"` driver → 2 layers with 1 geometry column
            1) with `wkbLineString` and `wkbMultiLineString` types
            2) with `wkbPolygon`, `wkbMultiPolygon` types  
            - Layers' geometry type set to `wkbUnknown` but modified by the OGR driver according to its specifications,
            - Each geometry has two additionnal fields `id::Int64` and `name::String`

            # Options
            - `withmissinggeom::Bool=true`: a missing geometry value per geom field
            - `withmissingfield::Bool=true`: a missing field value in `id` field
            - `withmixedgeomtypes::Bool=true`: a multi geometry value per geom field

            # Returns
            The result of `f` applied on the corresponding dataset

            """
            function map_on_test_dataset(
                f::Function,
                drvshortname::AbstractString = "ESRI shapefile",
                geomfamily::String = "line";
                withmissinggeom::Bool = true,
                withmissingfield::Bool = true,
                withmixedgeomtypes::Bool = true,
            )

                # Build dataset
                ds = get_test_dataset(
                    drvshortname,
                    geomfamily;
                    withmissinggeom = withmissinggeom,
                    withmissingfield = withmissingfield,
                    withmixedgeomtypes = withmixedgeomtypes,
                )

                return try
                    f(ds)
                finally
                    (@isdefined ds) && AG.destroy(ds)
                end
            end

            # Helper functions
            wellknownvalue(obj::Any) = obj
            wellknownvalue(obj::AG.AbstractGeometry) = AG.toWKT(obj)
            wellknownvalue(obj::AG.AbstractSpatialRef) = AG.toWKT(obj)
            wellknownvalue(obj::Missing)::Missing = missing
            wellknownvalue(obj::Nothing)::Nothing = nothing
            function wellknownvalues(x)::Tuple
                return Tuple(wellknownvalue.(x[i]) for i in 1:length(x))
            end
            tupleoftuples_equal = (
                (x, y) ->
                    length(x) == length(y) &&
                        all([all(x[i] .=== y[i]) for i in 1:length(x)])
            )

            """
                layer_to_columntable_with_WKT(
                    drvshortname::String, 
                    geomfamilly::String,
                    withmissinggeom::Bool,
                    withmissingfield::Bool,
                    withmixedgeomtypes::Bool,
                )::NamedTuple

            Convenience function to build new test results for `test_layer_to_table`  
            Creates a dataset from scratch with `get_test_dataset` and converts it to a columntable  
            Returns a `NamedTuple` with:
            - names: layer geom and field names
            - types: expected types given by `Tables.buildcolumns`
            - values: expected Tables.columntable result values with geometries converted to WKT

            """
            function layer_to_columntable_with_WKT(
                drvshortname::String,
                geomfamilly::String,
                withmissinggeom::Bool,
                withmissingfield::Bool,
                withmixedgeomtypes::Bool,
            )::NamedTuple
                map_on_test_dataset(
                    drvshortname,
                    geomfamilly;
                    withmissinggeom = withmissinggeom,
                    withmissingfield = withmissingfield,
                    withmixedgeomtypes = withmixedgeomtypes,
                ) do ds
                    layer = AG.getlayer(ds, 0)
                    return (
                        names = keys(Tables.columntable(layer)),
                        types = eltype.(values(Tables.columntable(layer)),),
                        values = wellknownvalues(
                            values(Tables.columntable(layer)),
                        ),
                    )
                end
            end

            """
                test_layer_to_table(
                    drvshortname::String, 
                    geomfamilly::String,
                    withmissinggeom::Bool,
                    withmissingfield::Bool,
                    withmixedgeomtypes::Bool,
                    reference_geotable::Tuple)

            Creates a dataset from scratch with `get_test_dataset` and converts it to a columntable  
            And test Tables.columntable(::AG.IFeatureLayer) result against `reference_geotable`

            """
            function test_layer_to_table(
                drvshortname::String,
                geomfamilly::String,
                withmissinggeom::Bool,
                withmissingfield::Bool,
                withmixedgeomtypes::Bool,
                reference_geotable::NamedTuple,
            )
                map_on_test_dataset(
                    drvshortname,
                    geomfamilly;
                    withmissinggeom = withmissinggeom,
                    withmissingfield = withmissingfield,
                    withmixedgeomtypes = withmixedgeomtypes,
                ) do ds
                    layer = AG.getlayer(ds, 0)
                    @test keys(Tables.columntable(layer)) ==
                          reference_geotable.names
                    @test eltype.(values(Tables.columntable(layer))) ==
                          reference_geotable.types
                    @test tupleoftuples_equal(
                        wellknownvalues(values(Tables.columntable(layer))),
                        reference_geotable.values,
                    )
                end
            end

            """
                test_layer_to_table(
                    layer::AG.AbstractFeatureLayer,
                    reference_geotable::NamedTuple,
                )::Bool

            test Tables.columntable(::AG.AbstractFeatureLayer) result against `reference_geotable`

            """
            function test_layer_to_table(
                layer::AG.AbstractFeatureLayer,
                reference_geotable::NamedTuple,
            )
                @test keys(Tables.columntable(layer)) ==
                      reference_geotable.names
                @test eltype.(values(Tables.columntable(layer))) ==
                      reference_geotable.types
                @test tupleoftuples_equal(
                    wellknownvalues(values(Tables.columntable(layer))),
                    reference_geotable.values,
                )
            end

            @testset "Conversion to table for ESRI Shapefile driver" begin
                ESRI_Shapefile_test_reference_geotable = (
                    names = (Symbol(""), :id, :name),
                    types = (
                        Union{Missing,ArchGDAL.IGeometry},
                        Union{Missing,Int64},
                        String,
                    ),
                    values = (
                        Union{Missing,String}[
                            "POLYGON ((0 0,0 1,1 1))",
                            "MULTIPOLYGON (((0 0,0 1,1 1)),((0.9 0.9,0.0 0.9,0 0)))",
                            missing,
                            "POLYGON ((0 0,-1 0,-1 1))",
                        ],
                        [1, 2, 3, missing],
                        ["polygon1", "multipolygon1", "emptygeom", "emptyid"],
                    ),
                )
                test_layer_to_table(
                    "ESRI Shapefile",
                    "polygon",
                    true,
                    true,
                    true,
                    ESRI_Shapefile_test_reference_geotable,
                )

                ESRI_Shapefile_test_reference_geotable = (
                    names = (Symbol(""), :id, :name),
                    types = (
                        Union{
                            Missing,
                            ArchGDAL.IGeometry{ArchGDAL.wkbLineString},
                        },
                        Union{Missing,Int64},
                        String,
                    ),
                    values = (
                        Union{Missing,String}[
                            "LINESTRING (1 2,2 3,3 4)",
                            "LINESTRING (3 4,4 5,5 6)",
                            missing,
                            "LINESTRING (5 6,6 7,7 8)",
                        ],
                        [1, 2, 3, missing],
                        ["line1", "line2", "emptygeom", "emptyid"],
                    ),
                )
                test_layer_to_table(
                    "ESRI Shapefile",
                    "line",
                    true,
                    true,
                    false,
                    ESRI_Shapefile_test_reference_geotable,
                )
            end

            @testset "Conversion to table for GeoJSON driver" begin
                GeoJSON_test_reference_geotable = (
                    names = (Symbol(""), :id, :name),
                    types = (
                        Union{Missing,ArchGDAL.IGeometry},
                        Union{Missing,Int32},
                        String,
                    ),
                    values = (
                        Union{Missing,String}[
                            "POLYGON ((0 0,0 1,1 1))",
                            "MULTIPOLYGON (((0 0,0 1,1 1)),((0 0,0.0 0.9,0.9 0.9)))",
                            missing,
                            "POLYGON ((0 0,-1 0,-1 1))",
                        ],
                        Union{Missing,Int32}[1, 2, 3, missing],
                        ["polygon1", "multipolygon1", "emptygeom", "emptyid"],
                    ),
                )
                test_layer_to_table(
                    "GeoJSON",
                    "polygon",
                    true,
                    true,
                    true,
                    GeoJSON_test_reference_geotable,
                )

                GeoJSON_test_reference_geotable = (
                    names = (Symbol(""), :id, :name),
                    types = (
                        Union{
                            Missing,
                            ArchGDAL.IGeometry{ArchGDAL.wkbLineString},
                        },
                        Union{Missing,Int32},
                        String,
                    ),
                    values = (
                        Union{Missing,String}[
                            "LINESTRING (1 2,2 3,3 4)",
                            "LINESTRING (3 4,4 5,5 6)",
                            missing,
                            "LINESTRING (5 6,6 7,7 8)",
                        ],
                        Union{Missing,Int32}[1, 2, 3, missing],
                        ["line1", "line2", "emptygeom", "emptyid"],
                    ),
                )
                test_layer_to_table(
                    "GeoJSON",
                    "line",
                    true,
                    true,
                    false,
                    GeoJSON_test_reference_geotable,
                )
            end

            @testset "Conversion to table for GML driver" begin
                GML_test_reference_geotable = (
                    names = (:geometryProperty, :fid, :id, :name),
                    types = (
                        Union{Missing,ArchGDAL.IGeometry},
                        String,
                        Union{Missing,Int64},
                        String,
                    ),
                    values = (
                        Union{Missing,String}[
                            "LINESTRING (1 2,2 3,3 4)",
                            "MULTILINESTRING ((1 2,2 3,3 4,4 5),(6 7,7 8,8 9,9 10))",
                            missing,
                            "LINESTRING (5 6,6 7,7 8)",
                        ],
                        [
                            "test_layer.0",
                            "test_layer.1",
                            "test_layer.2",
                            "test_layer.3",
                        ],
                        Union{Missing,Int64}[1, 2, 3, missing],
                        ["line1", "multiline1", "emptygeom", "emptyid"],
                    ),
                )
                test_layer_to_table(
                    "GML",
                    "line",
                    true,
                    true,
                    true,
                    GML_test_reference_geotable,
                )
            end

            @testset "Conversion to table for GPKG driver" begin
                GPKG_test_reference_geotable = (
                    names = (:geom, :id, :name),
                    types = (
                        Union{Missing,ArchGDAL.IGeometry},
                        Union{Missing,Int64},
                        String,
                    ),
                    values = (
                        Union{Missing,String}[
                            "LINESTRING (1 2,2 3,3 4)",
                            "MULTILINESTRING ((1 2,2 3,3 4,4 5),(6 7,7 8,8 9,9 10))",
                            missing,
                            "LINESTRING (5 6,6 7,7 8)",
                        ],
                        Union{Missing,Int64}[1, 2, 3, missing],
                        ["line1", "multiline1", "emptygeom", "emptyid"],
                    ),
                )
                test_layer_to_table(
                    "GPKG",
                    "line",
                    true,
                    true,
                    true,
                    GPKG_test_reference_geotable,
                )
            end

            @testset "Conversion to table for KML driver" begin
                KML_test_reference_geotable = (
                    names = (Symbol(""), :Name, :Description),
                    types = (ArchGDAL.IGeometry, String, String),
                    values = (
                        [
                            "LINESTRING (1 2,2 3,3 4)",
                            "MULTILINESTRING ((1 2,2 3,3 4,4 5),(6 7,7 8,8 9,9 10))",
                            "LINESTRING (5 6,6 7,7 8)",
                        ],
                        ["line1", "multiline1", "emptyid"],
                        ["", "", ""],
                    ),
                )
                test_layer_to_table(
                    "KML",
                    "line",
                    true,
                    true,
                    true,
                    KML_test_reference_geotable,
                )
            end

            @testset "Conversion to table for FlatGeobuf driver" begin
                FlatGeobuf_test_reference_geotable = (
                    names = (Symbol(""), :id, :name),
                    types = (ArchGDAL.IGeometry, Union{Nothing,Int64}, String),
                    values = (
                        [
                            "LINESTRING (5 6,6 7,7 8)",
                            "MULTILINESTRING ((1 2,2 3,3 4,4 5),(6 7,7 8,8 9,9 10))",
                            "LINESTRING (1 2,2 3,3 4)",
                        ],
                        Union{Nothing,Int64}[nothing, 2, 1],
                        ["emptyid", "multiline1", "line1"],
                    ),
                )
                test_layer_to_table(
                    "FlatGeobuf",
                    "line",
                    true,
                    true,
                    true,
                    FlatGeobuf_test_reference_geotable,
                )
            end

            @testset "Conversion to table for CSV driver" begin
                AG.read(
                    joinpath(@__DIR__, "data/multi_geom.csv"),
                    options = [
                        "GEOM_POSSIBLE_NAMES=point,linestring",
                        "KEEP_GEOM_COLUMNS=NO",
                    ],
                ) do multigeom_test_ds
                    multigeom_test_layer = AG.getlayer(multigeom_test_ds, 0)
                    CSV_multigeom_test_reference_geotable = (
                        names = (:point, :linestring, :id, :zoom, :location),
                        types = (
                            ArchGDAL.IGeometry{ArchGDAL.wkbPoint},
                            ArchGDAL.IGeometry{ArchGDAL.wkbLineString},
                            String,
                            String,
                            String,
                        ),
                        values = (
                            ["POINT (30 10)", "POINT (35 15)"],
                            [
                                "LINESTRING (30 10,10 30,40 40)",
                                "LINESTRING (35 15,15 35,45 45)",
                            ],
                            ["5.1", "5.2"],
                            ["1.0", "2.0"],
                            ["Mumbai", "New Delhi"],
                        ),
                    )
                    return test_layer_to_table(
                        multigeom_test_layer,
                        CSV_multigeom_test_reference_geotable,
                    )
                end
            end

            clean_test_dataset_files()
        end

        @testset "Table to layer conversion" begin
            # Helper functions
            toWKT_withmissings(x::Missing) = missing
            toWKT_withmissings(x::AG.AbstractGeometry) = AG.toWKT(x)
            toWKT_withmissings(x::Any) = x

            function ctv_toWKT(
                x::T,
            ) where {T<:NTuple{N,AbstractArray{S,D} where S}} where {N,D}
                return Tuple(toWKT_withmissings.(x[i]) for i in 1:N)
            end

            """
                equals_for_columntables_with_IGeometries(ct1, ct2)

            Compares two `NamedTuple` containing values `<: IGeometry` in the first `ngeom` columns of `ct1`, regarless of key order

            """
            function equals_for_columntables_with_IGeometries(ct1, ct2, ngeom)
                # we convert IGeometry values to WKT
                (ctv1, ctv2) = ctv_toWKT.(values.((ct1, ct2)))
                # we use two index functions to map ctv1 and ctv2 indices to the 
                # sorted key list indices
                (spidx_in, spidx_out) =
                    sortperm.(([keys(ct1)...], [keys(ct2)...]))
                return all([
                    sort([keys(ct1)...]) == sort([keys(ct2)...]),
                    all(
                        all.([
                            isequal.(
                                (
                                    # if we are comparing two geometry columns values, we
                                    # convert `nothing` values to `missing`, see note #2
                                    spidx_out[i] <= ngeom ?
                                    map(
                                        val ->
                                            (
                                                val === nothing ||
                                                val === missing
                                            ) ? missing : val,
                                        ctv1[spidx_in[i]],
                                    ) : ctv1[spidx_in[i]]
                                ),
                                ctv2[spidx_out[i]],
                            ) for i in 1:length(ctv2)
                        ]),
                    ),
                ])
            end

            """
                nt2layer2nt_equals_nt(nt; force_no_schema=true)

            Takes a NamedTuple, converts it to an IFeatureLayer and compares the NamedTuple
            to the one obtained from the IFeatureLayer conversion to table

            _Notes:_
            1. _Table columns have geometry column first and then field columns as
            enforced by `Tables.columnnames`_
            2. _`nothing` values in geometry column are returned as `missing` from
            the NamedTuple roundtrip conversion, since geometry fields do not have the
            same distinction between NULL and UNSET values the fields have_

            """
            function nt2layer2nt_equals_nt(
                nt::NamedTuple;
                force_no_schema::Bool = false,
            )::Bool
                force_no_schema ?
                layer = AG._fromtable(
                    nothing,
                    Tables.rows(nt);
                    layer_name = "layer",
                ) : layer = AG.IFeatureLayer(nt)
                (ct_in, ct_out) = Tables.columntable.((nt, layer))
                ngeom = AG.ngeom(layer)
                return equals_for_columntables_with_IGeometries(
                    ct_in,
                    ct_out,
                    ngeom,
                )
            end

            @testset "Tables with IGeometry" begin
                # Test with mixed IGeometry and Float
                nt = NamedTuple([
                    :point => [AG.createpoint(30, 10), 1.0],
                    :name => ["point1", "point2"],
                ])
                @test_throws ErrorException nt2layer2nt_equals_nt(nt)

                # Test with mixed String and Float64
                nt = NamedTuple([
                    :point => [
                        AG.createpoint(30, 10),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                    ],
                    :name => ["point1", 2.0],
                ])
                @test_throws ErrorException nt2layer2nt_equals_nt(nt)

                # Test with Int128 not convertible to OGRFieldType
                nt = NamedTuple([
                    :point => [
                        AG.createpoint(30, 10),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                    ],
                    :id => Int128[1, 2],
                ])
                @test_throws ErrorException nt2layer2nt_equals_nt(nt)

                # Test with `missing` and `nothing`values
                nt = NamedTuple([
                    :point => [
                        AG.createpoint(30, 10),
                        nothing,
                        AG.createpoint(35, 15),
                    ],
                    :linestring => [
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createlinestring([
                            (35.0, 15.0),
                            (15.0, 35.0),
                            (45.0, 45.0),
                        ]),
                        missing,
                    ],
                    :id => [nothing, "5.1", "5.2"],
                    :zoom => [1.0, 2.0, 3],
                    :location => ["Mumbai", missing, "New Delhi"],
                    :mixedgeom1 => [
                        AG.createpoint(30, 10),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createpoint(35, 15),
                    ],
                    :mixedgeom2 => [
                        AG.createpoint(30, 10),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createmultilinestring([
                            [(25.0, 5.0), (5.0, 25.0), (35.0, 35.0)],
                            [(35.0, 15.0), (15.0, 35.0), (45.0, 45.0)],
                        ]),
                    ],
                ])
                @test nt2layer2nt_equals_nt(nt; force_no_schema = true)
                @test nt2layer2nt_equals_nt(nt)

                # Test with `missing` values
                nt = NamedTuple([
                    :point => [
                        AG.createpoint(30, 10),
                        missing,
                        AG.createpoint(35, 15),
                    ],
                    :linestring => [
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createlinestring([
                            (35.0, 15.0),
                            (15.0, 35.0),
                            (45.0, 45.0),
                        ]),
                        missing,
                    ],
                    :id => [missing, "5.1", "5.2"],
                    :zoom => [1.0, 2.0, 3],
                    :location => ["Mumbai", missing, "New Delhi"],
                    :mixedgeom1 => [
                        AG.createpoint(30, 10),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createpoint(35, 15),
                    ],
                    :mixedgeom2 => [
                        AG.createpoint(30, 10),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createmultilinestring([
                            [(25.0, 5.0), (5.0, 25.0), (35.0, 35.0)],
                            [(35.0, 15.0), (15.0, 35.0), (45.0, 45.0)],
                        ]),
                    ],
                ])
                @test nt2layer2nt_equals_nt(nt; force_no_schema = true)
                @test nt2layer2nt_equals_nt(nt)
            end

            @testset "Tables with mixed IGeometry, GeoInterface, WKT/WKB" begin
                nt = NamedTuple([
                    :point => [
                        AG.createpoint(30, 10),
                        nothing,
                        AG.createpoint(35, 15),
                    ],
                    :linestring => [
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createlinestring([
                            (35.0, 15.0),
                            (15.0, 35.0),
                            (45.0, 45.0),
                        ]),
                        missing,
                    ],
                    :id => [nothing, "5.1", "5.2"],
                    :zoom => [1.0, 2.0, 3],
                    :location => ["Mumbai", missing, "New Delhi"],
                    :mixedgeom1 => [
                        AG.createpoint(5, 15),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createpoint(35, 15),
                    ],
                    :mixedgeom2 => [
                        AG.createpoint(10, 20),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createmultilinestring([
                            [(25.0, 5.0), (5.0, 25.0), (35.0, 35.0)],
                            [(35.0, 15.0), (15.0, 35.0), (45.0, 45.0)],
                        ]),
                    ],
                ])

                # Test a table conversion with geometries as `GeoInterface.AbstractGeometry` only
                nt_native = (;
                    zip(Symbol.((.*)(String.(keys(nt)), "_GI")), values(nt))...,
                )
                nt_GI = (;
                    zip(
                        Symbol.((.*)(String.(keys(nt)), "_GI")),
                        map.(
                            x ->
                                typeof(x) <: AG.IGeometry ?
                                LibGEOS.readgeom(AG.toWKT(x)) : x,
                            values(nt),
                        ),
                    )...,
                )
                @test all([
                    string(
                        Tables.columntable(AG.IFeatureLayer(nt_native))[colname],
                    ) == string(
                        Tables.columntable(AG.IFeatureLayer(nt_GI))[colname],
                    ) for colname in keys(nt_native)
                ])

                # Test a table conversion with geometries as WKT only
                nt_native = (;
                    zip(
                        Symbol.((.*)(String.(keys(nt)), "_WKT")),
                        values(nt),
                    )...,
                )
                nt_WKT = (;
                    zip(
                        Symbol.((.*)(String.(keys(nt)), "_WKT")),
                        map.(
                            x ->
                                typeof(x) <: AG.IGeometry ? AG.toWKT(x) : x,
                            values(nt),
                        ),
                    )...,
                )
                @test all([
                    string(
                        Tables.columntable(AG.IFeatureLayer(nt_native))[colname],
                    ) == string(
                        Tables.columntable(AG.IFeatureLayer(nt_WKT))[colname],
                    ) for colname in keys(nt_native)
                ])

                # Test a table conversion with geometries as WKB only
                nt_native = (;
                    zip(
                        Symbol.((.*)(String.(keys(nt)), "_WKB")),
                        values(nt),
                    )...,
                )
                nt_WKB = (;
                    zip(
                        Symbol.((.*)(String.(keys(nt)), "_WKB")),
                        map.(
                            x ->
                                typeof(x) <: AG.IGeometry ? AG.toWKB(x) : x,
                            values(nt),
                        ),
                    )...,
                )
                @test all([
                    string(
                        Tables.columntable(AG.IFeatureLayer(nt_native))[colname],
                    ) == string(
                        Tables.columntable(AG.IFeatureLayer(nt_WKB))[colname],
                    ) for colname in keys(nt_native)
                ])

                # Test a table conversion with geometries as:
                # -`IGeometry`, 
                # - `GeoInterface.AbstractGeometry`,
                # - WKT,
                # - WKB.
                nt_pure = merge(
                    nt,
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_GI")),
                            values(nt),
                        )...,
                    ),
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_WKT")),
                            values(nt),
                        )...,
                    ),
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_WKB")),
                            values(nt),
                        )...,
                    ),
                )

                nt_mixed = merge(
                    nt,
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_GI")),
                            map.(
                                x ->
                                    typeof(x) <: AG.IGeometry ?
                                    LibGEOS.readgeom(AG.toWKT(x)) : x,
                                values(nt),
                            ),
                        )...,
                    ),
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_WKT")),
                            map.(
                                x ->
                                    typeof(x) <: AG.IGeometry ? AG.toWKT(x) : x,
                                values(nt),
                            ),
                        )...,
                    ),
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_WKB")),
                            map.(
                                x ->
                                    typeof(x) <: AG.IGeometry ? AG.toWKB(x) : x,
                                values(nt),
                            ),
                        )...,
                    ),
                )

                @test all([
                    string(
                        Tables.columntable(AG.IFeatureLayer(nt_pure))[colname],
                    ) == string(
                        Tables.columntable(AG.IFeatureLayer(nt_mixed))[colname],
                    ) for colname in keys(nt_pure)
                ])
            end

            @testset "geomcols and fieldtypes kwargs in table to layer conversion" begin
                # Base NamedTuple with IGeometries only
                nt = NamedTuple([
                    :point => [
                        AG.createpoint(30, 10),
                        nothing,
                        AG.createpoint(35, 15),
                    ],
                    :linestring => [
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createlinestring([
                            (35.0, 15.0),
                            (15.0, 35.0),
                            (45.0, 45.0),
                        ]),
                        missing,
                    ],
                    :id => [nothing, "5.1", "5.2"],
                    :zoom => [1.0, 2.0, 3],
                    :location => ["Mumbai", missing, "New Delhi"],
                    :mixedgeom1 => [
                        AG.createpoint(5, 15),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createpoint(35, 15),
                    ],
                    :mixedgeom2 => [
                        AG.createpoint(10, 20),
                        AG.createlinestring([
                            (30.0, 10.0),
                            (10.0, 30.0),
                            (40.0, 40.0),
                        ]),
                        AG.createmultilinestring([
                            [(25.0, 5.0), (5.0, 25.0), (35.0, 35.0)],
                            [(35.0, 15.0), (15.0, 35.0), (45.0, 45.0)],
                        ]),
                    ],
                ])
                # Base NamedTuple with mixed geometry format, for test cases
                nt_source = merge(
                    nt,
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_GI")),
                            map.(
                                x ->
                                    typeof(x) <: AG.IGeometry ?
                                    LibGEOS.readgeom(AG.toWKT(x)) : x,
                                values(nt),
                            ),
                        )...,
                    ),
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_WKT")),
                            map.(
                                x ->
                                    typeof(x) <: AG.IGeometry ? AG.toWKT(x) : x,
                                values(nt),
                            ),
                        )...,
                    ),
                    (;
                        zip(
                            Symbol.((.*)(String.(keys(nt)), "_WKB")),
                            map.(
                                x ->
                                    typeof(x) <: AG.IGeometry ? AG.toWKB(x) : x,
                                values(nt),
                            ),
                        )...,
                    ),
                )

                #########################
                # Test `geomcols` kwarg #
                #########################
                geomcols = [
                    "point",
                    "linestring",
                    "mixedgeom1",
                    "mixedgeom2",
                    "point_GI",
                    "linestring_GI",
                    "mixedgeom1_GI",
                    "mixedgeom2_GI",
                    "mixedgeom2_WKT",
                    "mixedgeom2_WKB",
                ]
                # Convert `nothing` to `missing` and non `missing` or `nothing`
                # values to `IGeometry`in columns that are treated as 
                # geometries in table to layer conversion 
                nt_expectedresult = merge(
                    (;
                        [
                            k => map(
                                x ->
                                    x === nothing ? missing :
                                    (
                                        x === missing ? missing :
                                        convert(AG.IGeometry, x)
                                    ),
                                nt_source[k],
                            ) for k in Symbol.(geomcols)
                        ]...,
                    ),
                    (;
                        [
                            k => nt_source[k] for
                            k in setdiff(keys(nt_source), Symbol.(geomcols))
                        ]...,
                    ),
                )

                # Test table to layer conversion using `geomcols` kwargs
                # with a list of column names but not all table's columns
                # that may be parsed as geometry columns
                @test begin
                    nt_result = Tables.columntable(
                        AG.IFeatureLayer(
                            nt_source;
                            layer_name = "layer",
                            geomcols = geomcols,
                        ),
                    )
                    all([
                        Set(keys(nt_result)) == Set(keys(nt_expectedresult)),
                        all([
                            isequal(
                                toWKT_withmissings.(nt_result[k]),
                                toWKT_withmissings.(nt_expectedresult[k]),
                            ) for k in keys(nt_expectedresult)
                        ]),
                    ])
                end

                # Test table to layer conversion using `geomcols` kwargs
                # with a list of column indices but not all table's columns
                # that may be parsed as geometry columns
                geomcols = [1, 2, 6, 7, 8, 9, 13, 14, 21, 28]
                @test begin
                    nt_result = Tables.columntable(
                        AG.IFeatureLayer(
                            nt_source;
                            layer_name = "layer",
                            geomcols = geomcols,
                        ),
                    )
                    all([
                        Set(keys(nt_result)) == Set(keys(nt_expectedresult)),
                        all([
                            isequal(
                                toWKT_withmissings.(nt_result[k]),
                                toWKT_withmissings.(nt_expectedresult[k]),
                            ) for k in keys(nt_expectedresult)
                        ]),
                    ])
                end

                # Test that a column specified in `geomecols` kwarg that cannot
                # be parsed as a geometry column, throws an error 
                geomcols = [
                    "point",
                    "linestring",
                    "mixedgeom1",
                    "mixedgeom2",
                    "point_GI",
                    "linestring_GI",
                    "mixedgeom1_GI",
                    "mixedgeom2_GI",
                    "mixedgeom2_WKT",
                    "mixedgeom2_WKB",
                    "id",
                ]
                @test_throws ErrorException AG.IFeatureLayer(
                    nt_source;
                    layer_name = "layer",
                    geomcols = geomcols,
                )

                # Test that a column not specified in `geomecols` kwarg which
                # is a geometry column with a format that cannot be converted
                # directly to an OGRFieldType, throws an error 
                geomcols = [
                    "point",
                    "linestring",
                    "mixedgeom1",
                    "mixedgeom2",
                    "point_GI",
                    "linestring_GI",
                    "mixedgeom1_GI",
                    # "mixedgeom2_GI", # Column with geometries format not convertible to OGRFieldType
                    "mixedgeom2_WKT",
                    "mixedgeom2_WKB",
                ]
                @test_throws ErrorException AG.IFeatureLayer(
                    nt_source;
                    layer_name = "layer",
                    geomcols = geomcols,
                )

                # Test that a column specified by name in `geomecols` kwarg 
                # which is not member of table's columns throws an error 
                geomcols = [
                    "point",
                    "linestring",
                    "mixedgeom1",
                    "mixedgeom2",
                    "point_GI",
                    "linestring_GI",
                    "mixedgeom1_GI",
                    "mixedgeom2_GI",
                    "mixedgeom2_WKT",
                    "mixedgeom2_WKB",
                    "dummy_column",
                ]
                @test_throws ErrorException AG.IFeatureLayer(
                    nt_source;
                    layer_name = "layer",
                    geomcols = geomcols,
                )

                # Test that a column specified by index in `geomecols` kwarg 
                # which is not member of table's columns throws an error 
                geomcols = [1, 2, 6, 7, 8, 9, 13, 14, 21, 28, 29]
                @test_throws ErrorException AG.IFeatureLayer(
                    nt_source;
                    layer_name = "layer",
                    geomcols = geomcols,
                )

                ###########################
                # Test `fieldtypes` kwarg #
                ###########################

                # Test table to layer conversion using `geomcols` kwargs
                # with a list of column names but not all table's columns
                # that may be parsed as geometry columns
                geomcols = [
                    "point",
                    "linestring",
                    "mixedgeom1",
                    "mixedgeom2",
                    "point_GI",
                    "linestring_GI",
                    "mixedgeom1_GI",
                    "mixedgeom2_GI",
                    "mixedgeom2_WKT",
                    "mixedgeom2_WKB",
                ]
                fieldtypes = Dict(
                    "id" => (AG.OFTString, AG.OFSTNone),
                    "zoom" => (AG.OFTReal, AG.OFSTNone),
                    "point_GI" => AG.wkbPoint,
                    "mixedgeom2_WKB" => AG.wkbUnknown,
                )
                @test begin
                    nt_result = Tables.columntable(
                        AG.IFeatureLayer(
                            nt_source;
                            layer_name = "layer",
                            geomcols = geomcols,
                            fieldtypes = fieldtypes,
                        ),
                    )
                    all([
                        Set(keys(nt_result)) == Set(keys(nt_expectedresult)),
                        all([
                            isequal(
                                toWKT_withmissings.(nt_result[k]),
                                toWKT_withmissings.(nt_expectedresult[k]),
                            ) for k in keys(nt_expectedresult)
                        ]),
                    ])
                end
            end
        end
    end
end
