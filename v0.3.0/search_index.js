var documenterSearchIndex = {"docs":
[{"location":"datasets/#Data-Model-1","page":"GDAL Datasets","title":"Data Model","text":"","category":"section"},{"location":"datasets/#GDAL-Datasets-1","page":"GDAL Datasets","title":"GDAL Datasets","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The following code demonstrates the general workflow for reading in a dataset:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"ArchGDAL.read(filename) do dataset\n    # work with dataset\nend","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"We defer the discussion on ArchGDAL.read(filename) to the section on Working with Files.","category":"page"},{"location":"datasets/#Vector-Datasets-1","page":"GDAL Datasets","title":"Vector Datasets","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In this section, we work with the data/point.geojson dataset:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"julia> dataset = ArchGDAL.read(\"data/point.geojson\")\nGDAL Dataset (Driver: GeoJSON/GeoJSON)\nFile(s):\n  data/point.geojson\n\nNumber of feature layers: 1\n  Layer 0: point (wkbPoint)","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The display indicates","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"the type of the object (GDAL Dataset)\nthe driver used to open it (shortname/longname: GeoJSON/GeoJSON)\nthe files that it corresponds to (data/point.geojson)\nthe number of layers in the dataset (1), and a brief summary of each.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"You can also programmatically retrieve them using","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"typeof(dataset): the type of the object (GDAL Dataset)\nArchGDAL.filelist(dataset): the files that it corresponds to ([\"data/point.geojson\"])\nArchGDAL.nlayer(dataset): the number of layers in the dataset (1)\ndriver = ArchGDAL.getdriver(dataset): the driver used to open it\nArchGDAL.shortname(driver): the short name of a driver (\"GeoJSON\")\nArchGDAL.longname(driver): the long name of a driver (\"GeoJSON\")\nlayer = ArchGDAL.getlayer(dataset, i): the i-th layer in the dataset.\nArchGDAL.getgeomtype(layer): the geometry type for layer (i.e. wkbPoint)\nArchGDAL.getname(layer): the name of layer (i.e. point)\nArchGDAL.nfeature(layer): the number of features in the layer (i.e. 4)","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"For more on working with features and vector data, see the Section on Feature Data.","category":"page"},{"location":"datasets/#Raster-Datasets-1","page":"GDAL Datasets","title":"Raster Datasets","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In this section, we work with the gdalworkshop/world.tif dataset:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"julia> dataset = AG.read(\"gdalworkshop/world.tif\")\nGDAL Dataset (Driver: GTiff/GeoTIFF)\nFile(s):\n  gdalworkshop/world.tif\n\nDataset (width x height): 2048 x 1024 (pixels)\nNumber of raster bands: 3\n  [GA_ReadOnly] Band 1 (Red): 2048 x 1024 (UInt8)\n  [GA_ReadOnly] Band 2 (Green): 2048 x 1024 (UInt8)\n  [GA_ReadOnly] Band 3 (Blue): 2048 x 1024 (UInt8)","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The display indicates","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"the type of the object (GDAL Dataset)\nthe driver used to open it (shortname/longname: GTiff/GeoTIFF)\nthe files that it corresponds to (gdalworkshop/world.tif)\nthe number of raster bands in the dataset (3), and a brief summary of each.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"You can also programmatically retrieve them using","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"typeof(dataset): the type of the object (GDAL Dataset)\nArchGDAL.filelist(dataset): the files that it corresponds to ([\"gdalworkshop/world.tif\"])\nArchGDAL.nraster(dataset): the number of rasters (3)\nArchGDAL.width(dataset) the width (2048 pixels)\nArchGDAL.height(dataset) the height (1024 pixels)\ndriver = ArchGDAL.getdriver(dataset): the driver used to open it\nArchGDAL.shortname(driver): the short name of a driver (\"GTiff\")\nArchGDAL.longname(driver): the long name of a driver (\"GeoTIFF\")\nband = ArchGDAL.getband(dataset, i): the i-th raster band\ni = ArchGDAL.indexof(band): the index of the raster band.\nArchGDAL.accessflag(band): the access flag (i.e. GA_ReadOnly)\nArchGDAL.getname(ArchGDAL.getcolorinterp(band)): the color channel (e.g. Red)\nArchGDAL.width(band) the width of the raster band (2048 pixels)\nArchGDAL.height(band) the height of the raster band (1024 pixels)\nArchGDAL.pixeltype(band): the pixel type of the raster band (i.e. UInt8)","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"For more on working with raster data, see the Section on Raster Data.","category":"page"},{"location":"datasets/#Working-with-Files-1","page":"GDAL Datasets","title":"Working with Files","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"We provide the following methods for working with files:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"ArchGDAL.copy(): creates a copy of a dataset. This is often used with a virtual source dataset allowing configuration of band types, and other information without actually duplicating raster data.\nArchGDAL.create(): creates a new dataset.\nArchGDAL.read(): opens a dataset in read-only mode.\nArchGDAL.update(): opens a dataset with the possibility of updating it. If you open a dataset object with update access, it is not recommended to open a new dataset on the same underlying file.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In GDAL, datasets are closed by calling GDAL.close(). This will result in proper cleanup, and flushing of any pending writes. Forgetting to call GDAL.close() on a dataset opened in update mode in a popular format like GTiff will likely result in being unable to open it afterwards.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In ArchGDAL, the closing of datasets is handled by the API and not by the user. ArchGDAL provides two methods for working with datasets.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The first is to use a do-block:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"ArchGDAL.<copy/create/read/update>(...) do dataset\n    # work with dataset\nend","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The second is to call the method directly:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"dataset = ArchGDAL.<copy/create/read/update>(...)\n# work with dataset","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"note: Note\nThis pattern of using do-blocks to manage context plays a big way into the way we handle memory in this package. For details, see the section on Memory Management.","category":"page"},{"location":"geometries/#Geometric-Operations-1","page":"Geometric Operations","title":"Geometric Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"In this section, we consider some of the common kinds of geometries that arises in applications. These include Point, LineString, Polygon, GeometryCollection, MultiPolygon, MultiPoint, and MultiLineString. For brevity in the examples, we will use the prefix const AG = ArchGDAL.","category":"page"},{"location":"geometries/#Geometry-Creation-1","page":"Geometric Operations","title":"Geometry Creation","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"To create geometries of different types.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"point = AG.createpoint(1.0, 2.0)\nlinestring = AG.createlinestring([(i,i+1) for i in 1.0:3.0])\nlinearring = AG.createlinearring([(0.,0.), (0.,1.), (1.,1.)])\nsimplepolygon = AG.createpolygon([(0.,0.), (0.,1.), (1.,1.)])\ncomplexpolygon = AG.createpolygon([[(0.,0.), (0.,j), (j,j)] for j in 1.0:-0.1:0.9])\nmultipoint = AG.createlinearring([(0.,0.), (0.,1.), (1.,1.)])\nmultilinestring = AG.createmultilinestring([[(i,i+1) for i in j:j+3] for j in 1.0:5.0:6.0])\nmultipolygon = AG.createmultipolygon([[[(0.,0.), (0.,j), (j,j)]] for j in 1.0:-0.1:0.9])","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"Alternatively, they can be assembled from their components.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"point = AG.createpoint()\n    AG.addpoint!(point, 1.0, 2.0)\nlinestring = AG.createlinestring()\n    for i in 1.0:3.0\n        AG.addpoint!(linestring, i, i+1)\n    end\nlinearring = AG.createlinearring()\n    for i in 1.0:3.0\n        AG.addpoint!(linearring, i, i+1)\n    end\npolygon = AG.createpolygon()\n    for j in 1.0:-0.1:0.9\n        ring = AG.createlinearring([(0.,0.), (0.,j), (j,j)])\n        AG.addgeom!(polygon, ring)\n    end\nmultipoint = AG.createmultipoint()\n    for i in 1.0:3.0\n        pt = AG.createpoint(i, i+1)\n        AG.addgeom!(multipoint, pt)\n    end\nmultilinestring = AG.createmultilinestring()\n    for j in 1.0:5.0:6.0\n        line = AG.createlinestring([(i,i+1) for i in j:j+3])\n        AG.addgeom!(multilinestring, line)\n    end\nmultipolygon = AG.createmultipolygon()\n    for j in 1.0:-0.1:0.9\n        poly = AG.createpolygon([(0.,0.), (0.,j), (j,j)])\n        AG.addgeom!(multipolygon, poly)\n    end","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"They can also be constructed from other data formats such as:","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"Well-Known Binary (WKB): AG.fromWKB([0x01,0x01,...,0x27,0x41])\nWell-Known Text (WKT): AG.fromWKT(\"POINT (1 2)\")\nJavaScript Object Notation (JSON): AG.fromJSON(\"\"\"{\"type\":\"Point\",\"coordinates\":[1,2]}\"\"\")","category":"page"},{"location":"geometries/#Geometry-Modification-1","page":"Geometric Operations","title":"Geometry Modification","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods are commonly used for retrieving elements of a geometry.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.getcoorddim(geom): dimension of the coordinates. Returns 0 for an empty point\nAG.getspatialref(geom)\nAG.getx(geom, i)\nAG.gety(geom, i)\nAG.getz(geom, i)\nAG.getpoint(geom, i)\nAG.getgeom(geom, i)","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods are commonly used for modifying or adding to a geometry.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.setcoorddim!(geom, dim)\nAG.setpointcount!(geom, n)\nAG.setpoint!(geom, i, x, y)\nAG.setpoint!(geom, i, x, y, z)\nAG.addpoint!(geom, x, y)\nAG.addpoint!(geom, x, y, z)\nAG.addgeom!(geom1, geom2)\nAG.removegeom!(geom, i)\nAG.removeallgeoms!(geom)","category":"page"},{"location":"geometries/#Unary-Operations-1","page":"Geometric Operations","title":"Unary Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following is an non-exhaustive list of unary operations available for geometries.","category":"page"},{"location":"geometries/#Attributes-1","page":"Geometric Operations","title":"Attributes","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.geomdim(geom): 0 for points, 1 for lines and 2 for surfaces\nAG.getcoorddim(geom): dimension of the coordinates. Returns 0 for an empty point\nAG.envelope(geom): the bounding envelope for this geometry\nAG.envelope3d(geom): the bounding envelope for this geometry\nAG.wkbsize(geom): size (in bytes) of related binary representation\nAG.getgeomtype(geom): geometry type code (in OGRwkbGeometryType)\nAG.geomname(geom): WKT name for geometry type\nAG.getspatialref(geom): spatial reference system. May be NULL\nAG.geomlength(geom): the length of the geometry, or 0.0 for unsupported types\nAG.geomarea(geom): the area of the geometry, or 0.0 for unsupported types","category":"page"},{"location":"geometries/#Predicates-1","page":"Geometric Operations","title":"Predicates","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following predicates return a Bool.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.isempty(geom)\nAG.isvalid(geom)\nAG.issimple(geom)\nAG.isring(geom)\nAG.hascurvegeom(geom, nonlinear::Bool)","category":"page"},{"location":"geometries/#Immutable-Operations-1","page":"Geometric Operations","title":"Immutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods do not modify geom.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.clone(geom): a copy of the geometry with the original spatial reference system.\nAG.forceto(geom, targettype): force the provided geometry to the specified geometry type.\nAG.simplify(geom, tol): Compute a simplified geometry.\nAG.simplifypreservetopology(geom, tol): Simplify the geometry while preserving topology.\nAG.delaunaytriangulation(geom, tol, onlyedges): a delaunay triangulation of the vertices of the geometry.\nAG.boundary(geom): the boundary of the geometry\nAG.convexhull(geom): the convex hull of the geometry.\nAG.buffer(geom, dist, quadsegs): a polygon containing the region within the buffer distance of the original geometry.\nAG.union(geom): the union of the geometry using cascading\nAG.pointonsurface(geom): Returns a point guaranteed to lie on the surface.\nAG.centroid(geom): Compute the geometry centroid. It is not necessarily within the geometry.\nAG.pointalongline(geom, distance): Fetch point at given distance along curve.\nAG.polygonize(geom): Polygonizes a set of sparse edges.","category":"page"},{"location":"geometries/#Mutable-Operations-1","page":"Geometric Operations","title":"Mutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods modifies the first argument geom.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.setcoorddim!(geom, dim): sets the explicit coordinate dimension.\nAG.flattento2d!(geom): Convert geometry to strictly 2D.\nAG.closerings!(geom): Force rings to be closed by adding the start point to the end.\nAG.transform!(geom, coordtransform): Apply coordinate transformation to geometry.\nAG.segmentize!(geom, maxlength): Modify the geometry such it has no segment longer than the given distance.\nAG.empty!(geom): Clear geometry information.","category":"page"},{"location":"geometries/#Export-Formats-1","page":"Geometric Operations","title":"Export Formats","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.toWKB(geom)\nAG.toISOWKB(geom)\nAG.toWKT(geom)\nAG.toISOWKT(geom)\nAG.toGML(geom)\nAG.toKML(geom)\nAG.toJSON(geom)","category":"page"},{"location":"geometries/#Binary-Operations-1","page":"Geometric Operations","title":"Binary Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following is an non-exhaustive list of binary operations available for geometries.","category":"page"},{"location":"geometries/#Predicates-2","page":"Geometric Operations","title":"Predicates","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following predicates return a Bool.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.intersects(g1, g2)\nAG.equals(g1, g2)\nAG.disjoint(g1, g2)\nAG.touches(g1, g2)\nAG.crosses(g1, g2)\nAG.within(g1, g2)\nAG.contains(g1, g2)\nAG.overlaps(g1, g2)","category":"page"},{"location":"geometries/#Immutable-Operations-2","page":"Geometric Operations","title":"Immutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods do not mutate the input geomteries g1 and g2.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.intersection(g1, g2)\nAG.union(g1, g2)\nAG.difference(g1, g2)\nAG.symdifference(g1, g2)","category":"page"},{"location":"geometries/#Mutable-Operations-2","page":"Geometric Operations","title":"Mutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following method modifies the first argument g1.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"AG.addgeom!(g1, g2)","category":"page"},{"location":"rasters/#Raster-Data-1","page":"Raster Data","title":"Raster Data","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"In this section, we revisit the gdalworkshop/world.tif dataset.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"julia> dataset = AG.read(\"gdalworkshop/world.tif\")\nGDAL Dataset (Driver: GTiff/GeoTIFF)\nFile(s):\n  gdalworkshop/world.tif\n\nDataset (width x height): 2048 x 1024 (pixels)\nNumber of raster bands: 3\n  [GA_ReadOnly] Band 1 (Red): 2048 x 1024 (UInt8)\n  [GA_ReadOnly] Band 2 (Green): 2048 x 1024 (UInt8)\n  [GA_ReadOnly] Band 3 (Blue): 2048 x 1024 (UInt8)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"A description of the display is available in Raster Datasets.","category":"page"},{"location":"rasters/#Raster-Bands-1","page":"Raster Data","title":"Raster Bands","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"We can examine an individual raster band","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"julia> band = ArchGDAL.getband(dataset, 1)\n[GA_ReadOnly] Band 1 (Red): 2048 x 1024 (UInt8)\n    blocksize: 256×256, nodata: -1.0e10, units: 1.0px + 0.0\n    overviews: (0) 1024x512 (1) 512x256 (2) 256x128\n               (3) 128x64 (4) 64x32 (5) 32x16\n               (6) 16x8","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You can programmatically retrieve the information in the header using","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.accessflag(band): the access flag for this band. (GA_ReadOnly)\ncolorinterp = ArchGDAL.getcolorinterp(band): color interpretation of the values in the band (GCI_RedBand)\nArchGDAL.getname(colorinterp): name (string) corresponding to color interpretation (\"Red\")\nArchGDAL.width(band): width (pixels) of the band (2048)\nArchGDAL.height(band): height (pixels) of the band (1024)\nArchGDAL.indexof(band): the index of the band (1+) within its dataset, or 0 if unknown. (1)\nArchGDAL.pixeltype(band): pixel data type for this band. (UInt8)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You can get additional attribute information using","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.getscale(band): the scale in units = (px * scale) + offset (1.0)\nArchGDAL.getoffset(band): the offset in units = (px * scale) + offset (0.0)\nArchGDAL.getunittype(band): name for the units, e.g. \"m\" (meters) or \"ft\" (feet). (\"\")\nArchGDAL.getnodatavalue(band): a special marker value used to mark pixels that are not valid data. (-1.0e10)\n(x,y) = ArchGDAL.blocksize(band): the \"natural\" block size of this band ((256,256))","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nGDAL contains a concept of the natural block size of rasters so that applications can organized data access efficiently for some file formats. The natural block size is the block size that is most efficient for accessing the format. For many formats this is simple a whole scanline. However, for tiled images this will typically be the tile size.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"Finally, you can obtain overviews:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.noverview(band): the number of overview layers available, zero if none. (7)\nArchGDAL.getoverview(band, i): returns the i-th overview in the raster band. Each overview is itself a raster band, e.g.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"julia> ArchGDAL.getoverview(band, 2)\n[GA_ReadOnly] Band 1 (Red): 256 x 128 (UInt8)\n    blocksize: 128×128, nodata: -1.0e10, units: 1.0px + 0.0\n    overviews:","category":"page"},{"location":"rasters/#Raster-I/O-1","page":"Raster Data","title":"Raster I/O","text":"","category":"section"},{"location":"rasters/#Reading-Raster-Values-1","page":"Raster Data","title":"Reading Raster Values","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"The general operative method for reading in raster values from a dataset or band is to use ArchGDAL.read().","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.read(dataset): reads the entire dataset as a single multidimensional array.\nArchGDAL.read(dataset, indices): reads the raster bands at the indices (in that order) into a multidimensional array.\nArchGDAL.read(dataset, i): reads the i-th raster band into an array.\nArchGDAL.read(band): reads the raster band into an array.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nThe array returned by read has (cols, rows, bands) dimensions. To convert to a format used by the Images.jl ecosystem, you can either create a view using PermutedDimsArray(A, (3,2,1)) or create a permuted copy using permutedims(A, (3,2,1)). The resulting arrays will have (bands, rows, cols) dimensions.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You can also specify the subset of rows and columns (provided as UnitRanges) to read:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.read(dataset, indices, rows, cols)\nArchGDAL.read(dataset, i, rows, cols)\nArchGDAL.read(band, rows, cols)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"On other occasions, it might be easier to first specify a position (xoffset,yoffset) to read from, and the size (xsize, ysize) of the window to read:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.read(dataset, indices, xoffset, yoffset, xsize, ysize)\nArchGDAL.read(dataset, i, xoffset, yoffset, xsize, ysize)\nArchGDAL.read(band, xoffset, yoffset, xsize, ysize)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You might have an existing buffer that you wish to read the values into. In such cases, the general API for doing so is to write ArchGDAL.read!(source, buffer, args...) instead of ArchGDAL.read(source, args...).","category":"page"},{"location":"rasters/#Writing-Raster-Values-1","page":"Raster Data","title":"Writing Raster Values","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"For writing values from a buffer to a raster dataset or band, the following methods are available:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.write!(band, buffer)\nArchGDAL.write!(band, buffer, rows, cols)\nArchGDAL.write!(band, buffer, xoffset, yoffset, xsize, ysize)\nArchGDAL.write!(dataset, buffer, i)\nArchGDAL.write!(dataset, buffer, i, rows, cols)\nArchGDAL.write!(dataset, buffer, i, xoffset, yoffset, xsize, ysize)\nArchGDAL.write!(dataset, buffer, indices)\nArchGDAL.write!(dataset, buffer, indices, rows, cols)\nArchGDAL.write!(dataset, buffer, indices, xoffset, yoffset, xsize, ysize)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nArchGDAL expects the dimensions of the buffer to be (cols, rows, bands) or (cols, rows).","category":"page"},{"location":"rasters/#Windowed-Reads-and-Writes-1","page":"Raster Data","title":"Windowed Reads and Writes","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"Following the description in mapbox/rasterio's documentation, a window is a view onto a rectangular subset of a raster dataset. This is useful when you want to work on rasters that are larger than your computers RAM or process chunks of large rasters in parallel.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"For that purpose, we have a method called ArchGDAL.windows(band) which iterates over the windows of a raster band, returning the indices corresponding to the rasterblocks within that raster band for efficiency:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"julia> for (cols,rows) in ArchGDAL.windows(band)\n           println((cols,rows))\n       end\n(1:256, 1:256)\n(1:256, 257:512)\n(1:256, 513:768)\n(1:256, 769:1024)\n(257:512, 1:256)\n(257:512, 257:512)\n(257:512, 513:768)\n(257:512, 769:1024)\n(513:768, 1:256)\n...","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"Alternatively, we have another method called ArchGDAL.blocks(band) which iterates over the windows of a raster band, returning the offset and size corresponding to the rasterblocks within that raster band for efficiency:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"julia> for (xyoffset,xysize) in ArchGDAL.blocks(band)\n           println((xyoffset,xysize))\n       end\n((0, 0), (256, 256))\n((1, 0), (256, 256))\n((2, 0), (256, 256))\n((3, 0), (256, 256))\n((0, 1), (256, 256))\n((1, 1), (256, 256))\n...","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nThese methods are often used for reading/writing a block of image data efficiently, as it accesses \"natural\" blocks from the raster band without resampling, or data type conversion.","category":"page"},{"location":"features/#Feature-Data-1","page":"Feature Data","title":"Feature Data","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"In this section, we revisit the data/point.geojson dataset.","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"julia> dataset = AG.read(\"data/point.geojson\")\nGDAL Dataset (Driver: GeoJSON/GeoJSON)\nFile(s):\n  data/point.geojson\n\nNumber of feature layers: 1\n  Layer 0: point (wkbPoint)","category":"page"},{"location":"features/#Feature-Layers-1","page":"Feature Data","title":"Feature Layers","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"julia> layer = ArchGDAL.getlayer(dataset, 0)\nLayer: point\n  Geometry 0 (): [wkbPoint], POINT (100 0), POINT (100.2785 0.0893), ...\n     Field 0 (FID): [OFTReal], 2.0, 3.0, 0.0, 3.0\n     Field 1 (pointname): [OFTString], point-a, point-b, a, b","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"The display provides","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"the name of the feature layer (point)\nthe geometries in the dataset, and their brief summary.\nthe fields in the dataset, and their brief summary.","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"You can also programmatically retrieve them using","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getname(layer): the name of the feature layer\nArchGDAL.nfeature(layer): the number of features in the layer\nfeaturedefn = ArchGDAL.layerdefn(layer): the schema of the layer features\nArchGDAL.nfield(featuredefn): the number of fields\nArchGDAL.ngeom(featuredefn): the number of geometries\nArchGDAL.getfielddefn(featuredefn, i): the definition for the i-th field\nArchGDAL.getgeomdefn(featuredefn, i): the definition for the i-th geometry","category":"page"},{"location":"features/#Field-Definitions-1","page":"Feature Data","title":"Field Definitions","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"Each fielddefn defines an attribute of a feature, and supports the following:","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getname(fielddefn): the name of the field (\"FID\" or \"pointname\")\nArchGDAL.gettype(fielddefn): the type of the field (OFTReal or OFTString)","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"Each geomdefn defines an attribute of a geometry, and supports the following:","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getname(geomdefn): the name of the geometry (\"\" in this case)\nArchGDAL.gettype(geomdefn): the type of the geometry (wkbPoint)","category":"page"},{"location":"features/#Individual-Features-1","page":"Feature Data","title":"Individual Features","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"We can examine an individual feature","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"julia> ArchGDAL.getfeature(layer, 2) do feature\n           print(feature)\n       end\nFeature\n  (index 0) geom => POINT\n  (index 0) FID => 0.0\n  (index 1) pointname => a","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"You can programmatically retrieve the information using","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.nfield(feature): the number of fields (2)\nArchGDAL.ngeom(feature): the number of geometries (1)\nArchGDAL.getfield(feature, i): the i-th field (0.0 and \"a\")\nArchGDAL.getgeom(feature, i): the i-th geometry (the WKT display POINT)","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"More information on geometries can be found in Geometric Operations.","category":"page"},{"location":"memory/#Interactive-versus-Scoped-Objects-1","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL provides two approaches for working with GDAL objects.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"The first approach is through Scoped Objects, which uses do-blocks as context managers. The problem with using do-blocks to manage context is that they are difficult to work with in an interactive way:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.read(filename) do dataset\n    # dataset exists within this scope\nend\n# we do not have access to dataset from here on","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"In the example above, we do not get to see information about dataset unless we write code to display information within the scope of the do-block. This makes it difficult to work with it in an exploratory \"depth-first\" manner.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"The second approach is through Interactive Objects, which are designed for use at the REPL.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"dataset = ArchGDAL.read(filename)\n# work with dataset","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"A potential drawback of the second approach is that the objects are managed by Julia's garbage collector. This requires ArchGDAL to keep track of objects that interactive objects have a relationship with so that the interactive objects are not prematurely destroyed. For safety, ArchGDAL might make clones/copies of the underlying data, and only allow a subset of GDAL's objects to be created in this way.","category":"page"},{"location":"memory/#Memory-Management-(Advanced)-1","page":"Interactive versus Scoped Objects","title":"Memory Management (Advanced)","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"Unlike the design of fiona, ArchGDAL does not immediately make copies from data sources. This introduces concerns about memory management (whether objects should be managed by Julia's garbage collector, or by other means of destroying GDAL object when they are out of scope).","category":"page"},{"location":"memory/#Scoped-Objects-1","page":"Interactive versus Scoped Objects","title":"Scoped Objects","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"For scoped objects, they are often created within the context of a do-block. As an example, the following code block","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.getband(dataset, i) do rasterband\n    # do something with rasterband\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"corresponds to the following sequence of function calls:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"rasterband = ArchGDAL.unsafe_getband(dataset, i)\ntry\n    # do something with rasterband\nfinally\n    ArchGDAL.destroy(rasterband)\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"under the hood (see src/context.jl). Therefore, the objects themselves do not have a finalizer registered:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"mutable struct RasterBand <: AbstractRasterBand\n    ptr::GDALRasterBand\nend\n\nunsafe_getband(dataset::AbstractDataset, i::Integer) =\n    RasterBand(GDAL.getrasterband(dataset.ptr, i))\n\nfunction destroy(rb::AbstractRasterBand)\n    rb.ptr = GDALRasterBand(C_NULL)\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"note: Note\nWe use the unsafe_ prefix to indicate those methods that return scoped objects. These methods should not be used by users directly.","category":"page"},{"location":"memory/#Interactive-Objects-1","page":"Interactive versus Scoped Objects","title":"Interactive Objects","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"By contrast, the following code","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"rasterband = ArchGDAL.getband(dataset, i)\n# do something with rasterband","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"returns an interactive rasterband that has destroy() registered with its finalizer.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"mutable struct IRasterBand <: AbstractRasterBand\n    ptr::GDALRasterBand\n    ownedby::AbstractDataset\n\n    function IRasterBand(\n            ptr::GDALRasterBand = GDALRasterBand(C_NULL);\n            ownedby::AbstractDataset = Dataset()\n        )\n        rasterband = new(ptr, ownedby)\n        finalizer(destroy, rasterband)\n        return rasterband\n    end\nend\n\ngetband(dataset::AbstractDataset, i::Integer) =\n    IRasterBand(GDAL.getrasterband(dataset.ptr, i), ownedby = dataset)\n\nfunction destroy(rasterband::IRasterBand)\n    rasterband.ptr = GDALRasterBand(C_NULL)\n    rasterband.ownedby = Dataset()\n    return rasterband\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"The I in IRasterBand indicates that it is an [i]nteractive type. Other interactive types include IDataset, IFeatureLayer, ISpatialRef and IGeometry.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL requires all interactive types to have a finalizer that calls destroy() on them. All objects that have a relationship with an interactive object are required to hold a reference to the interactive object. For example, objects of type IRasterBand might have a relationship with an IDataset, therefore they have an ownedby attribute which might refer to such a dataset.","category":"page"},{"location":"memory/#Views-1","page":"Interactive versus Scoped Objects","title":"Views","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"Sometimes, it is helpful to work with objects that are \"internal references\" that have restrictions on the types of methods that they support. As an example layerdefn(featurelayer) returns a feature definition that is internal to the feature layer, and does not support methods such as write!(featuredefn, fielddefn) and deletegeomdefn!(featuredefn, i). To indicate that they might have restrictions, some types have View as a postfix. Such types include IFeatureDefnView, IFieldDefnView, and IGeomFieldDefnView.","category":"page"},{"location":"memory/#Summary-1","page":"Interactive versus Scoped Objects","title":"Summary","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"To summarize,","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.unsafe_<method>(args...) will return a scoped object. The proper way of using them is within the setting of a do-block:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.<method>(args...) do result\n    # result is a scoped object\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.<method>(args...) will return an interactive object.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"result = ArchGDAL.<method>(args...)\n# result is an interactive object","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"note: Note\nUsers are allowed to mix both \"interactive\" and \"scoped\" objects. As long as they do not manually call ArchGDAL.destroy() on any object, ArchGDAL is designed to avoid the pitfalls of GDAL memory management (e.g. in PythonGotchas).","category":"page"},{"location":"memory/#References-1","page":"Interactive versus Scoped Objects","title":"References","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"Here's a collection of references for developers who are interested.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"http://docs.julialang.org/en/release-0.4/manual/calling-c-and-fortran-code/\nhttps://github.com/JuliaLang/julia/issues/7721\nhttps://github.com/JuliaLang/julia/issues/11207\nhttps://trac.osgeo.org/gdal/wiki/PythonGotchas\nhttps://lists.osgeo.org/pipermail/gdal-dev/2010-September/026027.html\nhttps://sgillies.net/2013/12/17/teaching-python-gis-users-to-be-more-rational.html\nhttps://pcjericks.github.io/py-gdalogr-cookbook/gotchas.html#features-and-geometries-have-a-relationship-you-don-t-want-to-break","category":"page"},{"location":"spatialite/#Working-with-Spatialite-1","page":"Working with Spatialite","title":"Working with Spatialite","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"Here is an example of how you can work with a SQLite Database in ArchGDAL.jl, and follows the tutorial in http://www.gaia-gis.it/gaia-sins/spatialite-tutorial-2.3.1.html.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"We will work with the following database:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"import ArchGDAL\nconst AG = ArchGDAL\n\nfilepath = download(\"https://github.com/yeesian/ArchGDALDatasets/raw/e0b15dca5ad493c5ebe8111688c5d14b031b7305/spatialite/test-2.3.sqlite\", \"test.sqlite\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"Here's a quick summary of test.sqlite:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"AG.read(filepath) do dataset\n    print(dataset)\nend","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"We will display the results of running query on the dataset using the following function:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"function inspect(query, filename=filepath)\n    AG.read(filename) do dataset\n        AG.executesql(dataset, query) do results\n            print(results)\n        end\n    end\nend","category":"page"},{"location":"spatialite/#Constructing-SQL-Queries-1","page":"Working with Spatialite","title":"Constructing SQL Queries","text":"","category":"section"},{"location":"spatialite/#A-Simple-LIMIT-Query-1","page":"Working with Spatialite","title":"A Simple LIMIT Query","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"Here's a first query:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"SELECT * FROM towns LIMIT 5\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"A few points to understand:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SELECT statement requests SQLite to perform a query\nfetching all columns [*]\nFROM the database table of name towns\nretrieving only the first five rows [LIMIT 5]","category":"page"},{"location":"spatialite/#A-Simple-ORDER-BY-Query-1","page":"Working with Spatialite","title":"A Simple ORDER BY Query","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"Now try this second SQL query:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"select name AS Town, peoples as Population from towns ORDER BY name LIMIT 5\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"Some remarks:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"in SQL, constructs using lower- or upper-case have identical effects; So the commands constructed using SELECT and select, or FROM and from are equivalent.\nyou can freely choose which columns to fetch, determine their ordering, and rename then if you wish by using the AS clause.\nyou can order the fetched rows by using the ORDER BY clause.","category":"page"},{"location":"spatialite/#The-WHERE-and-ORDER-BY-clauses-1","page":"Working with Spatialite","title":"The WHERE and ORDER BY clauses","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"A more complex SQL query:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"select name, peoples from towns\n           WHERE peoples > 350000 order by peoples DESC\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"Some remarks:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"you can filter a specific set of rows by imposing a WHERE clause; only those rows that satisfies the logical expression you specify will be fetched.\nIn this example only towns with a population greater than 350000 peoples has been fetched.\nyou can order rows in descending order if appropriate, by using the DESC clause.","category":"page"},{"location":"spatialite/#Using-SQL-functions-1","page":"Working with Spatialite","title":"Using SQL functions","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nselect COUNT(*) as '# Towns',\n    MIN(peoples) as Smaller,\n    MAX(peoples) as Bigger,\n    SUM(peoples) as 'Total peoples',\n    SUM(peoples) / COUNT(*) as 'mean peoples for town'\nfrom towns\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"you can split complex queries along many lines\nyou can use functions in an SQL query. COUNT(), MIN(), MAX() and SUM() are functions. Not at all surprisingly:\nCOUNT() returns the total number of rows.\nMIN() returns the minimum value for the given column.\nMAX() returns the maximum value for the given column.\nSUM() returns the total of all values for the given column.\nyou can do calculations in your query. e.g. we have calculated the mean of peoples per village dividing the SUM() by the COUNT() values.","category":"page"},{"location":"spatialite/#Constructing-Expressions-1","page":"Working with Spatialite","title":"Constructing Expressions","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"select (10 - 11) * 2 as Number, ABS((10 - 11) * 2) as AbsoluteValue\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the (10 - 11) * 2 term is an example of an expression.\nthe ABS() function returns the absolute value of a number.\nnote that in this example we have not used any DB column or DB table at all.","category":"page"},{"location":"spatialite/#The-HEX()-function-1","page":"Working with Spatialite","title":"The HEX() function","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nselect name, peoples, HEX(Geometry)\nfrom Towns where peoples > 350000 order by peoples DESC\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the HEX() function returns the hexadecimal representation of a BLOB column value.\nin the preceding execution of this query, the geom column seemed empty; now, by using the HEX() function, we discover that it contains lots of strange binary data.\ngeom contains GEOMETRY values, stored as BLOBs and encoded in the internal representation used by SpatiaLite.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"note: Note\nSQLite in its own hasn't the slightest idea of what GEOMETRY is, and cannot do any other operation on it. To really use GEOMETRY values, it's time use the SpatiaLite extension.","category":"page"},{"location":"spatialite/#Spatialite-Features-1","page":"Working with Spatialite","title":"Spatialite Features","text":"","category":"section"},{"location":"spatialite/#Well-Known-Text-1","page":"Working with Spatialite","title":"Well-Known Text","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT name, peoples, AsText(Geometry)\nfrom Towns where peoples > 350000 order by peoples DESC\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the AsText() function comes from SpatiaLite, and returns the Well Known Text - WKT representation for a GEOMETRY column value. WKT is a standard notation conformant to OpenGIS specification.\nin the preceding execution of this query, the HEX() function returned lots of strange binary data. Now the AsText() function shows useful and quite easily understandable GEOMETRY values.\na POINT is the simplest GEOMETRY class, and has only a couple of [X,Y] coordinates.","category":"page"},{"location":"spatialite/#Working-with-Coordinates-1","page":"Working with Spatialite","title":"Working with Coordinates","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT name, X(Geometry), Y(Geometry) FROM Towns\nWHERE peoples > 350000 \nORDER BY peoples DESC\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite X() function returns the X coordinate for a POINT.\nthe Y() function returns the Y coordinate for a POINT.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"SELECT HEX(GeomFromText('POINT(10 20)'))\")","category":"page"},{"location":"spatialite/#Format-Conversions-1","page":"Working with Spatialite","title":"Format Conversions","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"you can use the following GEOMETRY format conversion functions:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"SELECT HEX(AsBinary(GeomFromText('POINT(10 20)')))\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"SELECT AsText(GeomFromWKB(X'010100000000000000000024400000000000003440'))\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite GeomFromText() function returns the internal BLOB representation for a GEOMETRY.\nthe AsBinary() function returns the Well Known Binary - WKB representation for a GEOMETRY column value. WKB is a standard notation conformant to OpenGIS specification.\nthe GeomFromWKB() function converts a WKB value into the corresponding internal BLOB value.","category":"page"},{"location":"spatialite/#GEOMETRY-Classes-1","page":"Working with Spatialite","title":"GEOMETRY Classes","text":"","category":"section"},{"location":"spatialite/#LINESTRING-1","page":"Working with Spatialite","title":"LINESTRING","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"SELECT PK_UID, AsText(Geometry) FROM HighWays WHERE PK_UID = 10\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"LINESTRING is another GEOMETRY class, and has lots of POINTs.\nin this case you have fetched a very simple LINESTRING, representing a polyline with just 4 vertices.\nit isn't unusual to encounter LINESTRINGs with thousands of vertices in real GIS data.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT PK_UID, NumPoints(Geometry), GLength(Geometry),\n       Dimension(Geometry), GeometryType(Geometry)\nFROM HighWays ORDER BY NumPoints(Geometry) DESC LIMIT 5\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite NumPoints() function returns the number of vertices for a LINESTRING GEOMETRY.\nthe GLength() function returns the geometric length [expressed in map units] for a LINESTRING GEOMETRY.\nthe Dimension() function returns the dimensions' number for any GEOMETRY class [e.g. 1 for lines].\nthe GeometryType() function returns the class type for any kind of GEOMETRY value.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT PK_UID, NumPoints(Geometry),\n       AsText(StartPoint(Geometry)), AsText(EndPoint(Geometry)),\n       X(PointN(Geometry, 2)), Y(PointN(Geometry, 2))\nFROM HighWays ORDER BY NumPoints(Geometry) DESC LIMIT 5\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite StartPoint() function returns the first POINT for a LINESTRING GEOMETRY.\nthe EndPoint() function returns the last POINT for a LINESTRING GEOMETRY.\nthe PointN() function returns the selected vertex as a POINT; each one vertex is identified by a relative index. The first vertex is identified by an index value 1, the second by an index value 2 and so on.\nYou can freely nest the various SpatiaLite functions, by passing the return value of the inner function as an argument for the outer one.","category":"page"},{"location":"spatialite/#POLYGON-1","page":"Working with Spatialite","title":"POLYGON","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"SELECT name, AsText(Geometry) FROM Regions WHERE PK_UID = 52\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"POLYGON is another GEOMETRY class.\nin this case you have fetched a very simple POLYGON, having only the exterior ring [i.e. it doesn't contains any internal hole]. Remember that POLYGONs may optionally contain an arbitrary number of internal holes, each one delimited by an interior ring.\nthe exterior ring in itself is simply a LINESTRING [and interior rings too are LINESTRINGS].\nnote that a POLYGON is a closed geometry, and thus the first and the last POINT for each ring are exactly identical.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT PK_UID, Area(Geometry), AsText(Centroid(Geometry)),\n       Dimension(Geometry), GeometryType(Geometry)\nFROM Regions ORDER BY Area(Geometry) DESC LIMIT 5\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"we have already meet the SpatiaLite Dimension() and GeometryType() functions; they works for POLYGONs exactly in same fashion as for any other kind of GEOMETRY.\nthe SpatiaLite Area() function returns the geometric area [expressed in square map units] for a POLYGON GEOMETRY.\nthe Centroid() function returns the POINT identifying the centroid for a POLYGON GEOMETRY.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT PK_UID, NumInteriorRings(Geometry),\n       NumPoints(ExteriorRing(Geometry)), NumPoints(InteriorRingN(Geometry, 1))\nFROM regions ORDER BY NumInteriorRings(Geometry) DESC LIMIT 5\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite ExteriorRing() functions returns the exterior ring for a given GEOMETRY. Any valid POLYGON must have an exterior ring. Remember: each one of the rings belonging to a POLYGON is a closed LINESTRING.\nthe SpatiaLite NumInteriorRings() function returns the number of interior rings belonging to a POLYGON. A valid POLYGON may have any number of interior rings, including zero i.e. no interior ring at all.\nThe SpatiaLite InteriorRingN() function returns the selected interior rings as a LINESTRING; each one interior ring is identified by a relative index. The first interior ring is identified by an index value 1, the second by an index value 2 and so on.\nAny ring is a LINESTRING, so we can use the NumPoints() function in order to detect the number of related vertices. If we call the NumPoints() function on a NULL GEOMETRY [or on a GEOMETRY of non-LINESTRING class] we'll get a NULL result. This explains why the the last three rows has a NULL NumPoints() result; there is no corresponding interior ring!","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT AsText(InteriorRingN(Geometry, 1)),\n       AsText(PointN(InteriorRingN(Geometry, 1), 4)),\n       X(PointN(InteriorRingN(Geometry, 1), 5)),\n       Y(PointN(InteriorRingN(Geometry, 1), 5))\nFROM Regions WHERE PK_UID = 55\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"we have already met in the preceding ones the usage of nested functions. For POLYGONs it becomes to be a little more tedious, but still easily understandable.\ne.g. to obtain the last column we have used InteriorRingN() in order to get the first interior ring, and then PointN() to get the fifth vertex. At last we can call Y() to get the coordinate value.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"inspect(\"\"\"\nSELECT Name, AsText(Envelope(Geometry)) FROM Regions LIMIT 5\n\"\"\")","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite Envelope() function always returns a POLYGON that is the Minimum Bounding Rectangle - MBR for the given GEOMETRY. Because an MBR is a rectangle, it always has 5 POINTs [remember: in closed geometries the last POINT must be identical to the first one].\nindividual POINTs are as follows:\nPOINT #1: minX,minY\nPOINT #2: maxX,minY\nPOINT #3: maxX,maxY\nPOINT #4: minX,maxY\nPOINT #5: minX,minY\nMBRs are of peculiar interest, because by using them you can evaluate spatial relationships between two geometries in a simplified and roughly approximative way. But MBR comparisons are very fast to compute, so they are very useful and widely used to speed up data processing.\nMBRs are also widely referenced as bounding boxes, or \"BBOX\" as well.","category":"page"},{"location":"spatialite/#Complex-Geometry-Classes-1","page":"Working with Spatialite","title":"Complex Geometry Classes","text":"","category":"section"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"POINT, LINESTRING and POLYGON are the elementary classes for GEOMETRY. But GEOMETRY supports the following complex classes as well:","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"a MULTIPOINT is a collection of two or more POINTs belonging to the same entity.\na MULTILINESTRING is a collection of two or more LINESTRINGs.\na MULTIPOLYGON is a collection of two or more POLYGONs.\na GEOMETRYCOLLECTION is an arbitrary collection containing any other kind of geometries.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"We'll not explain in detail this kind of collections, because it will be simply too boring and dispersive. Generally speaking, they extend in the expected way to their corresponding elementary classes, e.g.","category":"page"},{"location":"spatialite/#","page":"Working with Spatialite","title":"Working with Spatialite","text":"the SpatiaLite NumGeometries() function returns the number of elements for a collection.\nthe GeometryN() function returns the N-th element for a collection.\nthe GLength() function applied to a MULTILINESTRING returns the sum of individual lengths for each LINESTRING composing the collection.\nthe Area() function applied to a MULTIPOLYGON returns the sum of individual areas for each POLYGON in the collection.\nthe Centroid() function returns the average centroid when applied to a MULTIPOLYGON.","category":"page"},{"location":"#ArchGDAL.jl-documentation-1","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"GDAL is a translator library for raster and vector geospatial data formats that is released under an X/MIT license by the Open Source Geospatial Foundation. As a library, it presents an abstract data model to drivers for various raster and vector formats.","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"ArchGDAL.jl aims to be a complete solution for working with GDAL in Julia, similar in scope to the SWIG bindings for Python. It builds on top of GDAL.jl, and provides a high level API for GDAL, espousing the following principles.","category":"page"},{"location":"#Principles-(The-Arch-Way)-1","page":"ArchGDAL.jl documentation","title":"Principles (The Arch Way)","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"(adapted from https://wiki.archlinux.org/index.php/Arch_Linux#Principles)","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"simplicity: without unnecessary additions or modifications. It preserves the GDAL Data Model and requires minimal dependencies.\nmodernity: ArchGDAL strives to maintain the latest stable release versions of GDAL as long as systemic package breakage can be reasonably avoided.\npragmatism: The principles here are only useful guidelines. Ultimately, design decisions are made on a case-by-case basis through developer consensus. Evidence-based technical analysis and debate are what matter, not politics or popular opinion.\nuser-centrality: Whereas other libraries attempt to be more user-friendly, ArchGDAL shall be user-centric. It is intended to fill the needs of those contributing to it, rather than trying to appeal to as many users as possible.\nversatility: ArchGDAL will strive to remain small in its assumptions about the range of user-needs, and to make it easy for users to build their own extensions/conveniences.","category":"page"},{"location":"#Installation-1","page":"ArchGDAL.jl documentation","title":"Installation","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"To install this package, run the following command in the Pkg REPL-mode,","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"pkg> add ArchGDAL","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"To test if it is installed correctly,","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"pkg> test ArchGDAL","category":"page"},{"location":"projections/#Spatial-Projections-1","page":"Spatial Projections","title":"Spatial Projections","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"(This is based entirely on the GDAL/OSR Tutorial and Python GDAL/OGR Cookbook.)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"The ArchGDAL.SpatialRef, and ArchGDAL.CoordTransform types are lightweight wrappers around GDAL objects that represent coordinate systems (projections and datums) and provide services to transform between them. These services are loosely modeled on the OpenGIS Coordinate Transformations specification, and use the same Well Known Text format for describing coordinate systems.","category":"page"},{"location":"projections/#Coordinate-Systems-1","page":"Spatial Projections","title":"Coordinate Systems","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"There are two primary kinds of coordinate systems. The first is geographic (positions are measured in long/lat) and the second is projected (such as UTM - positions are measured in meters or feet).","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"Geographic Coordinate Systems: A Geographic coordinate system contains information on the datum (which implies an spheroid described by a semi-major axis, and inverse flattening), prime meridian (normally Greenwich), and an angular units type which is normally degrees.\nProjected Coordinate Systems: A projected coordinate system (such as UTM, Lambert Conformal Conic, etc) requires and underlying geographic coordinate system as well as a definition for the projection transform used to translate between linear positions (in meters or feet) and angular long/lat positions.","category":"page"},{"location":"projections/#Creating-Spatial-References-1","page":"Spatial Projections","title":"Creating Spatial References","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"julia> spatialref = ArchGDAL.importEPSG(2927)\nSpatial Reference System: +proj=lcc +lat_1=47.33333333333334  ... defs\n\njulia> print(ArchGDAL.toPROJ4(spatialref))\n+proj=lcc +lat_1=47.33333333333334 +lat_2=45.83333333333334 +lat_0=45.33333333333334 +lon_0=-120.5 +x_0=500000.0001016001 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"The details of how to interpret the results can be found in http://proj4.org/usage/projections.html.","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"In the above example, we constructed a SpatialRef object from the EPSG Code 2927. There are a variety of other formats from which SpatialRefs can be constructed, such as","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"ArchGDAL.importEPSG(::Int): based on the EPSG code\nArchGDAL.importEPSGA(::Int): based on the EPSGA code\nArchGDAL.importESRI(::String): based on ESRI projection codes\nArchGDAL.importPROJ4(::String) based on the PROJ.4 string (reference)\nArchGDAL.importURL(::String): download from a given URL and feed it into SetFromUserInput for you.\nArchGDAL.importWKT(::String): WKT string\nArchGDAL.importXML(::String): XML format (GML only currently)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"We currently support a few export formats too:","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"ArchGDAL.toMICoordSys(spref): Mapinfo style CoordSys format.\nArchGDAL.toPROJ4(spref): coordinate system in PROJ.4 format.\nArchGDAL.toWKT(spref): nicely formatted WKT string for display to a person.\nArchGDAL.toXML(spref): converts into XML format to the extent possible.","category":"page"},{"location":"projections/#Reprojecting-a-Geometry-1","page":"Spatial Projections","title":"Reprojecting a Geometry","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"julia> source = ArchGDAL.importEPSG(2927)\nSpatial Reference System: +proj=lcc +lat_1=47.33333333333334  ... defs\n\njulia> target = ArchGDAL.importEPSG(4326)\nSpatial Reference System: +proj=longlat +datum=WGS84 +no_defs\n\njulia> ArchGDAL.createcoordtrans(source, target) do transform\n           point = ArchGDAL.fromWKT(\"POINT (1120351.57 741921.42)\")\n           println(\"Before: $(ArchGDAL.toWKT(point))\")\n           ArchGDAL.transform!(point, transform)\n           println(\"After: $(ArchGDAL.toWKT(point))\")\n       end\nBefore: POINT (1120351.57 741921.42)\nAfter: POINT (-122.598135130878 47.3488013802885)","category":"page"},{"location":"projections/#References-1","page":"Spatial Projections","title":"References","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"Some background on OpenGIS coordinate systems and services can be found in the Simple Features for COM, and Spatial Reference Systems Abstract Model documents available from the Open Geospatial Consortium. The GeoTIFF Projections Transform List may also be of assistance in understanding formulations of projections in WKT. The EPSG Geodesy web page is also a useful resource. You may also consult the OGC WKT Coordinate System Issues page.","category":"page"},{"location":"considerations/#Design-Considerations-1","page":"Design Considerations","title":"Design Considerations","text":"","category":"section"},{"location":"considerations/#Code-Defensiveness-1","page":"Design Considerations","title":"Code Defensiveness","text":"","category":"section"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"Although GDAL provides a unified data model for different data formats, there are still significant differences between their implementations such that each driver is effectively its own application. This has the following implications:","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"Not all configuration options works for all drivers.\nNot all capabilities are available for all drivers.\nPerformance characteristics may vary significantly depending on the driver.","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"ArchGDAL.jl provides mechanisms for setting GDAL's configuration options, and does not maintain its own list of sanctioned options for each driver. Although work is underway to make this an easier experience for the user, it remains the responsibility of the user to check that a particular configuration exists and works for their choice of drivers.","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"Here's a collection of references for developers who are interested:","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"https://trac.osgeo.org/gdal/wiki/ConfigOptions\nhttps://github.com/mapbox/rasterio/pull/665\nhttps://github.com/mapbox/rasterio/issues/875\nhttps://mapbox.github.io/rasterio/topics/configuration.html","category":"page"}]
}
