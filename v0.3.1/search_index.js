var documenterSearchIndex = {"docs":
[{"location":"datasets/#Data-Model-1","page":"GDAL Datasets","title":"Data Model","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"using ArchGDAL","category":"page"},{"location":"datasets/#GDAL-Datasets-1","page":"GDAL Datasets","title":"GDAL Datasets","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The following code demonstrates the general workflow for reading in a dataset:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"ArchGDAL.read(filename) do dataset\n    # work with dataset\nend","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"We defer the discussion on ArchGDAL.read(filename) to the section on Working with Files.","category":"page"},{"location":"datasets/#Vector-Datasets-1","page":"GDAL Datasets","title":"Vector Datasets","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In this section, we work with the data/point.geojson dataset:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"dataset = ArchGDAL.read(\"data/point.geojson\")","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The display indicates","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"the type of the object (GDAL Dataset)\nthe driver used to open it (shortname/longname: GeoJSON/GeoJSON)\nthe files that it corresponds to (data/point.geojson)\nthe number of layers in the dataset (1), and a brief summary of each.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"You can also programmatically retrieve them using","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"typeof(dataset): the type of the object (GDAL Dataset)\nArchGDAL.filelist(dataset): the files that it corresponds to ([\"data/point.geojson\"])\nArchGDAL.nlayer(dataset): the number of layers in the dataset (1)\ndriver =ArchGDAL.getdriver(dataset): the driver used to open it\nArchGDAL.shortname(driver): the short name of a driver (\"GeoJSON\")\nArchGDAL.longname(driver): the long name of a driver (\"GeoJSON\")\nlayer =ArchGDAL.getlayer(dataset, i): the i-th layer in the dataset.\nArchGDAL.getgeomtype(layer): the geometry type for layer (i.e. wkbPoint)\nArchGDAL.getname(layer): the name of layer (i.e. point)\nArchGDAL.nfeature(layer): the number of features in the layer (i.e. 4)","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"For more on working with features and vector data, see the Section on Feature Data.","category":"page"},{"location":"datasets/#Raster-Datasets-1","page":"GDAL Datasets","title":"Raster Datasets","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In this section, we work with the gdalworkshop/world.tif dataset:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"dataset = ArchGDAL.read(\"gdalworkshop/world.tif\")","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The display indicates","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"the type of the object (GDAL Dataset)\nthe driver used to open it (shortname/longname: GTiff/GeoTIFF)\nthe files that it corresponds to (gdalworkshop/world.tif)\nthe number of raster bands in the dataset (3), and a brief summary of each.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"You can also programmatically retrieve them using","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"typeof(dataset): the type of the object (GDAL Dataset)\nArchGDAL.filelist(dataset): the files that it corresponds to ([\"gdalworkshop/world.tif\"])\nArchGDAL.nraster(dataset): the number of rasters (3)\nArchGDAL.width(dataset): the width (2048 pixels)\nArchGDAL.height(dataset): the height (1024 pixels)\ndriver =ArchGDAL.getdriver(dataset): the driver used to open it\nArchGDAL.shortname(driver): the short name of a driver (\"GTiff\")\nArchGDAL.longname(driver): the long name of a driver (\"GeoTIFF\")\nband =ArchGDAL.getband(dataset, i): the i-th raster band\ni =ArchGDAL.indexof(band): the index of the raster band.\nArchGDAL.accessflag(band): the access flag (i.e. GA_ReadOnly)\nArchGDAL.getname(ArchGDAL.getcolorinterp(band)): the color channel (e.g. Red)\nArchGDAL.width(band): the width of the raster band (2048 pixels)\nArchGDAL.height(band): the height of the raster band (1024 pixels)\nArchGDAL.pixeltype(band): the pixel type of the raster band (i.e. UInt8)","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"For more on working with raster data, see the Section on Raster Data.","category":"page"},{"location":"datasets/#Working-with-Files-1","page":"GDAL Datasets","title":"Working with Files","text":"","category":"section"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"We provide the following methods for working with files:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"ArchGDAL.copy: creates a copy of a dataset. This is often used with a virtual source dataset allowing configuration of band types, and other information without actually duplicating raster data.\nArchGDAL.create: creates a new dataset.\nArchGDAL.read: opens a dataset in read-only mode.\nArchGDAL.update: opens a dataset with the possibility of updating it. If you open a dataset object with update access, it is not recommended to open a new dataset on the same underlying file.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In GDAL, datasets are closed by calling GDAL.close(). This will result in proper cleanup, and flushing of any pending writes. Forgetting to call GDAL.close() on a dataset opened in update mode in a popular format like GTiff will likely result in being unable to open it afterwards.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"In ArchGDAL, the closing of datasets is handled by the API and not by the user. ArchGDAL provides two methods for working with datasets.","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The first is to use a do-block:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"ArchGDAL.<copy/create/read/update>(...) do dataset\n    # work with dataset\nend","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"The second is to call the method directly:","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"dataset = ArchGDAL.<copy/create/read/update>(...)\n# work with dataset","category":"page"},{"location":"datasets/#","page":"GDAL Datasets","title":"GDAL Datasets","text":"note: Note\nThis pattern of using do-blocks to manage context plays a big way into the way we handle memory in this package. For details, see the section on Memory Management.","category":"page"},{"location":"considerations/#Design-Considerations-1","page":"Design Considerations","title":"Design Considerations","text":"","category":"section"},{"location":"considerations/#Code-Defensiveness-1","page":"Design Considerations","title":"Code Defensiveness","text":"","category":"section"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"Although GDAL provides a unified data model for different data formats, there are still significant differences between their implementations such that each driver is effectively its own application. This has the following implications:","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"Not all configuration options works for all drivers.\nNot all capabilities are available for all drivers.\nPerformance characteristics may vary significantly depending on the driver.","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"ArchGDAL.jl provides mechanisms for setting GDAL's configuration options, and does not maintain its own list of sanctioned options for each driver. Although work is underway to make this an easier experience for the user, it remains the responsibility of the user to check that a particular configuration exists and works for their choice of drivers.","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"Here's a collection of references for developers who are interested:","category":"page"},{"location":"considerations/#","page":"Design Considerations","title":"Design Considerations","text":"https://trac.osgeo.org/gdal/wiki/ConfigOptions\nhttps://github.com/mapbox/rasterio/pull/665\nhttps://github.com/mapbox/rasterio/issues/875\nhttps://rasterio.readthedocs.io/en/latest/topics/configuration.html","category":"page"},{"location":"rasters/#Raster-Data-1","page":"Raster Data","title":"Raster Data","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"using ArchGDAL\nconst AG = ArchGDAL","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"In this section, we revisit the gdalworkshop/world.tif dataset.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"dataset = AG.read(\"gdalworkshop/world.tif\")","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"A description of the display is available in Raster Datasets.","category":"page"},{"location":"rasters/#Raster-Bands-1","page":"Raster Data","title":"Raster Bands","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"We can examine an individual raster band","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"band = ArchGDAL.getband(dataset, 1)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You can programmatically retrieve the information in the header using","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.accessflag(band): the access flag for this band. (GA_ReadOnly)\ncolorinterp =ArchGDAL.getcolorinterp(band): color interpretation of the values in the band (GCI_RedBand)\nArchGDAL.getname(colorinterp): name (string) corresponding to color interpretation (\"Red\")\nArchGDAL.width(band): width (pixels) of the band (2048)\nArchGDAL.height(band): height (pixels) of the band (1024)\nArchGDAL.indexof(band): the index of the band (1+) within its dataset, or 0 if unknown. (1)\nArchGDAL.pixeltype(band): pixel data type for this band. (UInt8)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You can get additional attribute information using","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.getscale(band): the scale in units = (px * scale) + offset (1.0)\nArchGDAL.getoffset(band): the offset in units = (px * scale) + offset (0.0)\nArchGDAL.getunittype(band): name for the units, e.g. \"m\" (meters) or \"ft\" (feet). (\"\")\nArchGDAL.getnodatavalue(band): a special marker value used to mark pixels that are not valid data. (-1.0e10)\n(x,y) =ArchGDAL.blocksize(band): the \"natural\" block size of this band ((256,256))","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nGDAL contains a concept of the natural block size of rasters so that applications can organized data access efficiently for some file formats. The natural block size is the block size that is most efficient for accessing the format. For many formats this is simple a whole scanline. However, for tiled images this will typically be the tile size.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"Finally, you can obtain overviews:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.noverview(band): the number of overview layers available, zero if none. (7)\nArchGDAL.getoverview(band, i): returns the i-th overview in the raster band. Each overview is itself a raster band, e.g.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.getoverview(band, 2)","category":"page"},{"location":"rasters/#Raster-I/O-1","page":"Raster Data","title":"Raster I/O","text":"","category":"section"},{"location":"rasters/#Reading-Raster-Values-1","page":"Raster Data","title":"Reading Raster Values","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"The general operative method for reading in raster values from a dataset or band is to use ArchGDAL.read().","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.read(dataset): reads the entire dataset as a single multidimensional array.\nArchGDAL.read(dataset, indices): reads the raster bands at the indices (in that order) into a multidimensional array.\nArchGDAL.read(dataset, i): reads the i-th raster band into an array.\nArchGDAL.read(band): reads the raster band into an array.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nThe array returned by read has (cols, rows, bands) dimensions. To convert to a format used by the Images.jl ecosystem, you can either create a view using PermutedDimsArray(A, (3,2,1)) or create a permuted copy using permutedims(A, (3,2,1)). The resulting arrays will have (bands, rows, cols) dimensions.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You can also specify the subset of rows and columns (provided as UnitRanges like 2:9) to read:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.read(dataset, indices, rows, cols)\nArchGDAL.read(dataset, i, rows, cols)\nArchGDAL.read(band, rows, cols)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"On other occasions, it might be easier to first specify a position (xoffset,yoffset) to read from, and the size (xsize, ysize) of the window to read:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.read(dataset, indices, xoffset, yoffset, xsize, ysize)\nArchGDAL.read(dataset, i, xoffset, yoffset, xsize, ysize)\nArchGDAL.read(band, xoffset, yoffset, xsize, ysize)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"You might have an existing buffer that you wish to read the values into. In such cases, the general API for doing so is to write ArchGDAL.read!(source, buffer, args...) instead of ArchGDAL.read(source, args...).","category":"page"},{"location":"rasters/#Writing-Raster-Values-1","page":"Raster Data","title":"Writing Raster Values","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"For writing values from a buffer to a raster dataset or band, the following methods are available:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"ArchGDAL.write!(band, buffer)\nArchGDAL.write!(band, buffer, rows, cols)\nArchGDAL.write!(band, buffer, xoffset, yoffset, xsize, ysize)\nArchGDAL.write!(dataset, buffer, i)\nArchGDAL.write!(dataset, buffer, i, rows, cols)\nArchGDAL.write!(dataset, buffer, i, xoffset, yoffset, xsize, ysize)\nArchGDAL.write!(dataset, buffer, indices)\nArchGDAL.write!(dataset, buffer, indices, rows, cols)\nArchGDAL.write!(dataset, buffer, indices, xoffset, yoffset, xsize, ysize)","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nArchGDAL expects the dimensions of the buffer to be (cols, rows, bands) or (cols, rows).","category":"page"},{"location":"rasters/#Windowed-Reads-and-Writes-1","page":"Raster Data","title":"Windowed Reads and Writes","text":"","category":"section"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"Following the description in mapbox/rasterio's documentation, a window is a view onto a rectangular subset of a raster dataset. This is useful when you want to work on rasters that are larger than your computers RAM or process chunks of large rasters in parallel.","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"For that purpose, we have a method called ArchGDAL.windows(band) which iterates over the windows of a raster band, returning the indices corresponding to the rasterblocks within that raster band for efficiency:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"using Base.Iterators: take  # to prevent showing all blocks\nwindows = ArchGDAL.windows(band)\n\nfor (cols, rows) in take(windows, 5)\n    @info \"Window\" cols rows\nend","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"Alternatively, we have another method called ArchGDAL.blocks(band) which iterates over the windows of a raster band, returning the offset and size corresponding to the rasterblocks within that raster band for efficiency:","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"blocks = ArchGDAL.blocks(band)\nfor (xyoffset, xysize) in take(blocks, 5)\n    @info \"Window offset\" xyoffset xysize\nend","category":"page"},{"location":"rasters/#","page":"Raster Data","title":"Raster Data","text":"note: Note\nThese methods are often used for reading/writing a block of image data efficiently, as it accesses \"natural\" blocks from the raster band without resampling, or data type conversion.","category":"page"},{"location":"features/#Feature-Data-1","page":"Feature Data","title":"Feature Data","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"using ArchGDAL","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"In this section, we revisit the data/point.geojson dataset.","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"dataset = ArchGDAL.read(\"data/point.geojson\")","category":"page"},{"location":"features/#Feature-Layers-1","page":"Feature Data","title":"Feature Layers","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"Retrieve a layer from a dataset using ArchGDAL.getlayer","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"layer = ArchGDAL.getlayer(dataset, 0)","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"The display provides","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"the name of the feature layer (point)\nthe geometries in the dataset, and their brief summary.\nthe fields in the dataset, and their brief summary.","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"You can also programmatically retrieve them using","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getname(layer): the name of the feature layer\nArchGDAL.nfeature(layer): the number of features in the layer\nfeaturedefn =ArchGDAL.layerdefn(layer): the schema of the layer features\nArchGDAL.nfield(featuredefn): the number of fields\nArchGDAL.ngeom(featuredefn): the number of geometries\nArchGDAL.getfielddefn(featuredefn, i): the definition for the i-th field\nArchGDAL.getgeomdefn(featuredefn, i): the definition for the i-th geometry","category":"page"},{"location":"features/#Field-Definitions-1","page":"Feature Data","title":"Field Definitions","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"Each fielddefn defines an attribute of a feature, and supports the following:","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getname(fielddefn): the name of the field (\"FID\" or \"pointname\")\nArchGDAL.gettype(fielddefn): the type of the field (OFTReal or OFTString)","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"Each geomdefn defines an attribute of a geometry, and supports the following:","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getname(geomdefn): the name of the geometry (\"\" in this case)\nArchGDAL.gettype(geomdefn): the type of the geometry (wkbPoint)","category":"page"},{"location":"features/#Individual-Features-1","page":"Feature Data","title":"Individual Features","text":"","category":"section"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"We can examine an individual feature","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.getfeature(layer, 2) do feature\n    print(feature)\nend","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"You can programmatically retrieve the information using","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"ArchGDAL.nfield(feature): the number of fields (2)\nArchGDAL.ngeom(feature): the number of geometries (1)\nArchGDAL.getfield(feature, i): the i-th field (0.0 and \"a\")\nArchGDAL.getgeom(feature, i): the i-th geometry (the WKT display POINT)","category":"page"},{"location":"features/#","page":"Feature Data","title":"Feature Data","text":"More information on geometries can be found in Geometric Operations.","category":"page"},{"location":"reference/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#General-1","page":"API Reference","title":"General","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"ArchGDAL.jl\", \"display.jl\", \"iterators.jl\", \"gcp.jl\", \"types.jl\", \"utils.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.applygeotransform-Tuple{Array{Float64,1},Float64,Float64}","page":"API Reference","title":"ArchGDAL.applygeotransform","text":"applygeotransform(geotransform::Vector{Cdouble}, pixel::Cdouble, line::Cdouble)\n\nApply GeoTransform to x/y coordinate.\n\nApplies the following computation, converting a (pixel,line) coordinate into a georeferenced (geo_x,geo_y) location.\n\n    geo_x = geotransform[1] + pixel*geotransform[2] + line*geotransform[3]\n    geo_y = geotransform[4] + pixel*geotransform[5] + line*geotransform[6]\n\nParameters\n\ngeotransform  Six coefficient GeoTransform to apply.\npixel           input pixel position.\nline            input line position.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.composegeotransform!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"API Reference","title":"ArchGDAL.composegeotransform!","text":"composegeotransform!(gt1::Vector{Float64}, gt2::Vector{Float64}, gtout::Vector{Float64})\n\nCompose two geotransforms.\n\nThe resulting geotransform is the equivelent to padfGT1 and then padfGT2 being applied to a point.\n\nParameters\n\ngt1     the first geotransform, six values.\ngt2     the second geotransform, six values.\ngtout   the output geotransform, six values, may safely be the same\n\narray as gt1 or gt2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.invgeotransform!-Tuple{Array{Float64,1},Array{Float64,1}}","page":"API Reference","title":"ArchGDAL.invgeotransform!","text":"invgeotransform!(gt_in::Vector{Cdouble}, gt_out::Vector{Cdouble})\n\nInvert Geotransform.\n\nThis function will invert a standard 3x2 set of GeoTransform coefficients. This converts the equation from being pixel to geo to being geo to pixel.\n\nParameters\n\ngt_in       Input geotransform (six doubles - unaltered).\ngt_out      Output geotransform (six doubles - updated).\n\nReturns\n\ngt_out\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL._FIELDTYPE","page":"API Reference","title":"ArchGDAL._FIELDTYPE","text":"return the corresponding DataType in julia\n\n\n\n\n\n","category":"constant"},{"location":"reference/#ArchGDAL._JLTYPE","page":"API Reference","title":"ArchGDAL._JLTYPE","text":"return the corresponding DataType in julia\n\n\n\n\n\n","category":"constant"},{"location":"reference/#ArchGDAL.arecompatible-Tuple{GDAL.OGRFieldType,GDAL.OGRFieldSubType}","page":"API Reference","title":"ArchGDAL.arecompatible","text":"arecompatible(dtype::OGRFieldType, subtype::OGRFieldSubType)\n\nReturn if type and subtype are compatible.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asyncstatustype-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.asyncstatustype","text":"asyncstatustype(name::AbstractString)\n\nGet AsyncStatusType by symbolic name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.colorinterp-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.colorinterp","text":"colorinterp(name::AbstractString)\n\nGet color interpretation corresponding to the given symbolic name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{GDAL.GDALAsyncStatusType}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(dtype::GDALAsyncStatusType)\n\nGet name of AsyncStatus data type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{GDAL.GDALColorInterp}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(obj::GDALColorInterp)\n\nReturn name (string) corresponding to color interpretation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{GDAL.GDALPaletteInterp}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(obj::GDALPaletteInterp)\n\nGet name of palette interpretation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{GDAL.OGRFieldSubType}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(obj::OGRFieldSubType)\n\nFetch human readable name for a field subtype.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{GDAL.OGRFieldType}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(obj::OGRFieldType)\n\nFetch human readable name for a field type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.gettype-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.gettype","text":"gettype(name::AbstractString)\n\nReturns GDAL data type by symbolic name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.iscomplex-Tuple{GDAL.GDALDataType}","page":"API Reference","title":"ArchGDAL.iscomplex","text":"iscomplex(dtype::GDALDataType)\n\ntrue if dtype is one of GDT_{CInt16|CInt32|CFloat32|CFloat64}.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.typename-Tuple{GDAL.GDALDataType}","page":"API Reference","title":"ArchGDAL.typename","text":"typename(dt::GDALDataType)\n\nname (string) corresponding to GDAL data type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.typesize-Tuple{GDAL.GDALDataType}","page":"API Reference","title":"ArchGDAL.typesize","text":"typesize(dt::GDALDataType)\n\nGet data type size in bits.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.typeunion-Tuple{GDAL.GDALDataType,GDAL.GDALDataType}","page":"API Reference","title":"ArchGDAL.typeunion","text":"typeunion(dt1::GDALDataType, dt2::GDALDataType)\n\nReturn the smallest data type that can fully express both input data types.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.clearconfigoption-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.clearconfigoption","text":"clearconfigoption(option::AbstractString)\n\nThis function can be used to clear a setting.\n\nNote: it will not unset an existing environment variable; it will just unset a value previously set by setconfigoption().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.clearthreadconfigoption-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.clearthreadconfigoption","text":"clearthreadconfigoption(option::AbstractString)\n\nThis function can be used to clear a setting.\n\nNote: it will not unset an existing environment variable; it will just unset a value previously set by setthreadconfigoption().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getconfigoption","page":"API Reference","title":"ArchGDAL.getconfigoption","text":"getconfigoption(option::AbstractString, default = C_NULL)\n\nGet the value of a configuration option.\n\nThe value is the value of a (key, value) option set with setconfigoption(). If the given option was not defined with setconfigoption(), it tries to find it in environment variables.\n\nParameters\n\noption  the key of the option to retrieve\ndefault a default value if the key does not match existing defined options\n\nReturns\n\nthe value associated to the key, or the default value if not found.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.getthreadconfigoption","page":"API Reference","title":"ArchGDAL.getthreadconfigoption","text":"getthreadconfigoption(option::AbstractString, default = C_NULL)\n\nSame as getconfigoption() but with settings from setthreadconfigoption().\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.metadata-Tuple{Any}","page":"API Reference","title":"ArchGDAL.metadata","text":"metadata(obj; domain::AbstractString = \"\")\n\nFetch metadata. Note that relatively few formats return any metadata.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.metadatadomainlist-Tuple{Any}","page":"API Reference","title":"ArchGDAL.metadatadomainlist","text":"metadatadomainlist(obj)\n\nFetch list of (non-empty) metadata domains.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setconfigoption-Tuple{AbstractString,Any}","page":"API Reference","title":"ArchGDAL.setconfigoption","text":"setconfigoption(option::AbstractString, value)\n\nSet a configuration option for GDAL/OGR use.\n\nThose options are defined as a (key, value) couple. The value corresponding to a key can be got later with the getconfigoption() method.\n\nParameters\n\noption  the key of the option\nvalue   the value of the option, or NULL to clear a setting.\n\nThis mechanism is similar to environment variables, but options set with setconfigoption() overrides, for getconfigoption() point of view, values defined in the environment.\n\nIf setconfigoption() is called several times with the same key, the value provided during the last call will be used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setthreadconfigoption-Tuple{AbstractString,Any}","page":"API Reference","title":"ArchGDAL.setthreadconfigoption","text":"setthreadconfigoption(option::AbstractString, value)\n\nSet a configuration option for GDAL/OGR use.\n\nThose options are defined as a (key, value) couple. The value corresponding to a key can be got later with the getconfigoption() method.\n\nParameters\n\noption  the key of the option\nvalue   the value of the option\n\nThis function sets the configuration option that only applies in the current thread, as opposed to setconfigoption() which sets an option that applies on all threads.\n\n\n\n\n\n","category":"method"},{"location":"reference/#API-GDAL-Datasets-1","page":"API Reference","title":"GDAL Datasets","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"dataset.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.buildoverviews!-Tuple{ArchGDAL.AbstractDataset,Array{Int32,1}}","page":"API Reference","title":"ArchGDAL.buildoverviews!","text":"buildoverviews!(dataset::AbstractDataset, overviewlist::Vector{Cint}; bandlist, resampling=\"NEAREST\",\n    progressfunc, progressdata)\n    Build raster overview(s).\n\nIf the operation is unsupported for the indicated dataset, then CEFailure is returned, and CPLGetLastErrorNo() will return CPLENotSupported.\n\nParameters\n\noverviewlist overview decimation factors to build.\n\nKeyword Parameters\n\npanBandList  list of band numbers. Must be in Cint (default = all)\nsampling     one of \"NEAREST\" (default), \"GAUSS\",\"CUBIC\",\"AVERAGE\",\"MODE\",                \"AVERAGE_MAGPHASE\" or \"NONE\" controlling the downsampling                method applied.\nprogressfunc a function to call to report progress, or NULL.\nprogressdata application data to pass to the progress function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.copy-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.copy","text":"copy(dataset::AbstractDataset; [filename, [driver, [<keyword arguments>]]])\n\nCreate a copy of a dataset.\n\nThis method will attempt to create a copy of a raster dataset with the indicated filename, and in this drivers format. Band number, size, type, projection, geotransform and so forth are all to be copied from the provided template dataset.\n\nParameters\n\ndataset       the dataset being duplicated.\n\nKeyword Arguments\n\nfilename      the filename for the new dataset. UTF-8 encoded.\ndriver        the driver to use for creating the new dataset\nstrict        true if the copy must be strictly equivalent, or more   normally false if the copy may adapt as needed for the output format.\noptions       additional format dependent options controlling creation\n\nof the output file. The APPEND_SUBDATASET=YES option can be specified to avoid prior destruction of existing dataset.\n\nExample\n\ndataset = ArchGDAL.copy(originaldataset)\n# work with dataset from here\n\nor\n\nArchGDAL.copy(originaldataset) do dataset\n    # work with dataset from here\nend\n\nReturns\n\nThe newly created dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.copywholeraster-Tuple{ArchGDAL.AbstractDataset,ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.copywholeraster","text":"copywholeraster(source::AbstractDataset, dest::AbstractDataset; <keyword arguments>)\n\nCopy all dataset raster data.\n\nThis function copies the complete raster contents of one dataset to another similarly configured dataset. The source and destination dataset must have the same number of bands, and the same width and height. The bands do not have to have the same data type.\n\nCurrently the only options supported are : \"INTERLEAVE=PIXEL\" to force pixel interleaved operation and \"COMPRESSED=YES\" to force alignment on target dataset block sizes to achieve best compression. More options may be supported in the future.\n\nAdditional Remarks\n\nThis function is primarily intended to support implementation of driver specific createcopy() functions. It implements efficient copying, in particular \"chunking\" the copy in substantial blocks and, if appropriate, performing the transfer in a pixel interleaved fashion.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.create-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.create","text":"create(filename::AbstractString; driver, width, height, nbands, dtype, options)\n\nCreate a new dataset.\n\nParameters\n\nfilename       the filename for the dataset being created.\n\nKeyword Arguments\n\ndriver        the driver to use for creating the new dataset\noptions       additional format dependent options controlling creation\n\nof the output file. The APPEND_SUBDATASET=YES option can be specified to avoid prior destruction of existing dataset.\n\nwidth, height, nbands, dtype: only for raster datasets.\n\nExample\n\ndataset = ArchGDAL.create(AG.getdriver(\"MEM\"))\n# work with raster dataset from here\n\nor\n\nArchGDAL.create(AG.getdriver(\"Memory\")) do dataset\n    # work with vector dataset from here\nend\n\nReturns\n\nThe newly created dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.deletelayer!-Tuple{ArchGDAL.AbstractDataset,Integer}","page":"API Reference","title":"ArchGDAL.deletelayer!","text":"deletelayer!(dataset::AbstractDataset, i::Integer)\n\nDelete the indicated layer (at index i; between 0 to nlayer()-1)\n\nReturns\n\nOGRERR_NONE on success, or OGRERR_UNSUPPORTED_OPERATION if deleting layers is not supported for this dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.filelist-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.filelist","text":"filelist(dataset::AbstractDataset)\n\nFetch files forming dataset.\n\nReturns a list of files believed to be part of this dataset. If it returns an empty list of files it means there is believed to be no local file system files associated with the dataset (for instance a virtual dataset). The returned file list is owned by the caller and should be deallocated with CSLDestroy().\n\nThe returned filenames will normally be relative or absolute paths depending on the path used to originally open the dataset. The strings will be UTF-8 encoded\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getband-Tuple{ArchGDAL.AbstractDataset,Integer}","page":"API Reference","title":"ArchGDAL.getband","text":"getband(dataset::AbstractDataset, i::Integer)\n\nFetch a band object for a dataset from its index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getdriver-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.getdriver","text":"getdriver(dataset::AbstractDataset)\n\nFetch the driver that the dataset was created with\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeotransform!-Tuple{ArchGDAL.AbstractDataset,Array{Float64,1}}","page":"API Reference","title":"ArchGDAL.getgeotransform!","text":"getgeotransform!(dataset::AbstractDataset, transform::Vector{Cdouble})\n\nFetch the affine transformation coefficients.\n\nFetches the coefficients for transforming between pixel/line (P,L) raster space, and projection coordinates (Xp,Yp) space.\n\n   Xp = padfTransform[0] + P*padfTransform[1] + L*padfTransform[2];\n   Yp = padfTransform[3] + P*padfTransform[4] + L*padfTransform[5];\n\nIn a north up image, padfTransform[1] is the pixel width, and padfTransform[5] is the pixel height. The upper left corner of the upper left pixel is at position (padfTransform[0],padfTransform[3]).\n\nThe default transform is (0,1,0,0,0,1) and should be returned even when a CE_Failure error is returned, such as for formats that don't support transformation to projection coordinates.\n\nParameters\n\nbuffer   a six double buffer into which the transformation will be placed.\n\nReturns\n\nCE_None on success, or CE_Failure if no transform can be fetched.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getlayer-Tuple{ArchGDAL.AbstractDataset,AbstractString}","page":"API Reference","title":"ArchGDAL.getlayer","text":"getlayer(dataset::AbstractDataset, name::AbstractString)\n\nFetch the feature layer corresponding to the given name.\n\nThe returned layer remains owned by the GDALDataset and should not be deleted by the application.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getlayer-Tuple{ArchGDAL.AbstractDataset,Integer}","page":"API Reference","title":"ArchGDAL.getlayer","text":"getlayer(dataset::AbstractDataset, i::Integer)\n\nFetch the layer at index i (between 0 and nlayer(dataset)-1)\n\nThe returned layer remains owned by the GDALDataset and should not be deleted by the application.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getproj-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.getproj","text":"getproj(dataset::AbstractDataset)\n\nFetch the projection definition string for this dataset in OpenGIS WKT format.\n\nIt should be suitable for use with the OGRSpatialReference class. When a projection definition is not available an empty (but not NULL) string is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.height-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.height","text":"height(dataset::AbstractDataset)\n\nFetch raster height in pixels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ngcp-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.ngcp","text":"ngcp(dataset::AbstractDataset)\n\nGet number of GCPs for this dataset. Zero if there are none.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nlayer-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.nlayer","text":"nlayer(dataset::AbstractDataset)\n\nFetch the number of feature layers on this dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nraster-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.nraster","text":"nraster(dataset::AbstractDataset)\n\nFetch the number of raster bands on this dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.read-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.read","text":"read(filename; flags=OF_ReadOnly, alloweddrivers, options, siblingfiles)\n\nOpen a raster file\n\nParameters\n\nfilename: the filename of the dataset to be read.\n\nKeyword Arguments\n\nflags: a combination of OF_* flags (listed below) that may be   combined through the logical | operator. It defaults to OF_ReadOnly.\nDriver kind: OF_Raster for raster drivers, OF_Vector for vector   drivers. If none of the value is specified, both are implied.\nAccess mode: OF_ReadOnly (exclusive) or OF_Update.\nShared mode: OF_Shared. If set, it allows the sharing of handles for a   dataset with other callers that have set OF_Shared.\nVerbose error: OF_Verbose_Error. If set, a failed attempt to open the   file will lead to an error message to be reported.\noptions: additional format dependent options.\n\nExample\n\ndataset = ArchGDAL.read(\"point.shp\")\n# work with dataset from here\n\nor\n\nArchGDAL.read(\"point.shp\") do dataset\n    # work with dataset from here\nend\n\nReturns\n\nThe corresponding dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.releaseresultset-Tuple{ArchGDAL.AbstractDataset,ArchGDAL.FeatureLayer}","page":"API Reference","title":"ArchGDAL.releaseresultset","text":"releaseresultset(dataset::AbstractDataset, layer::FeatureLayer)\n\nRelease results of ExecuteSQL().\n\nThis function should only be used to deallocate OGRLayers resulting from an ExecuteSQL() call on the same GDALDataset. Failure to deallocate a results set before destroying the GDALDataset may cause errors.\n\nParameters\n\ndataset: the dataset handle.\nlayer: the result of a previous ExecuteSQL() call.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setgeotransform!-Tuple{ArchGDAL.AbstractDataset,Array{Float64,1}}","page":"API Reference","title":"ArchGDAL.setgeotransform!","text":"setgeotransform!(dataset::AbstractDataset, transform::Vector{Cdouble})\n\nSet the affine transformation coefficients.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setproj!-Tuple{ArchGDAL.AbstractDataset,AbstractString}","page":"API Reference","title":"ArchGDAL.setproj!","text":"setproj!(dataset::AbstractDataset, projstring::AbstractString)\n\nSet the projection reference string for this dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.testcapability-Tuple{ArchGDAL.AbstractDataset,AbstractString}","page":"API Reference","title":"ArchGDAL.testcapability","text":"testcapability(dataset::AbstractDataset, capability::AbstractString)\n\nTest if capability is available. true if capability available otherwise false.\n\nOne of the following dataset capability names can be passed into this function, and a true or false value will be returned indicating whether or not the capability is available for this object.\n\nODsCCreateLayer: True if this datasource can create new layers.\nODsCDeleteLayer: True if this datasource can delete existing layers.\nODsCCreateGeomFieldAfterCreateLayer: True if the layers of this datasource       support CreateGeomField() just after layer creation.\nODsCCurveGeometries: True if this datasource supports curve geometries.\nODsCTransactions: True if this datasource supports (efficient) transactions.\nODsCEmulatedTransactions: True if this datasource supports transactions       through emulation.\n\nThe #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.\n\nParameters\n\ndataset: the dataset handle.\ncapability: the capability to test.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_copy-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.unsafe_copy","text":"unsafe_copy(dataset::AbstractDataset; [filename, [driver, [<keyword arguments>]]])\n\nCreate a copy of a dataset.\n\nThis method will attempt to create a copy of a raster dataset with the indicated filename, and in this drivers format. Band number, size, type, projection, geotransform and so forth are all to be copied from the provided template dataset.\n\nParameters\n\ndataset       the dataset being duplicated.\n\nKeyword Arguments\n\nfilename      the filename for the new dataset. UTF-8 encoded.\ndriver        the driver to use for creating the new dataset\nstrict        true if the copy must be strictly equivalent, or more\n\nnormally false if the copy may adapt as needed for the output format.\n\noptions       additional format dependent options controlling creation\n\nof the output file. The APPEND_SUBDATASET=YES option can be specified to avoid prior destruction of existing dataset.\n\nReturns\n\na pointer to the newly created dataset (may be read-only access).\n\nAdditional Remarks\n\nNote: many sequential write once formats (such as JPEG and PNG) don't implement the Create() method but do implement this CreateCopy() method. If the driver doesn't implement CreateCopy(), but does implement Create() then the default CreateCopy() mechanism built on calling Create() will be used.\n\nIt is intended that CreateCopy() will often be used with a source dataset which is a virtual dataset allowing configuration of band types, and other information without actually duplicating raster data (see the VRT driver). This is what is done by the gdal_translate utility for example.\n\nThis function will validate the creation option list passed to the driver with the GDALValidateCreationOptions() method. This check can be disabled by defining the configuration option GDAL_VALIDATE_CREATION_OPTIONS=NO.\n\nAfter you have finished working with the returned dataset, it is required to close it with GDALClose(). This does not only close the file handle, but also ensures that all the data and metadata has been written to the dataset (GDALFlushCache() is not sufficient for that purpose).\n\nIn some situations, the new dataset can be created in another process through the GDAL API Proxy mechanism.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_create-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.unsafe_create","text":"unsafe_create(filename::AbstractString; driver, width, height, nbands, dtype, options)\n\nCreate a new dataset.\n\nWhat argument values are legal for particular drivers is driver specific, and there is no way to query in advance to establish legal values.\n\nThat function will try to validate the creation option list passed to the driver with the GDALValidateCreationOptions() method. This check can be disabled by defining the configuration option GDALVALIDATECREATION_OPTIONS=NO.\n\nAfter you have finished working with the returned dataset, it is required to close it with GDALClose(). This does not only close the file handle, but also ensures that all the data and metadata has been written to the dataset (GDALFlushCache() is not sufficient for that purpose).\n\nIn some situations, the new dataset can be created in another process through the GDAL API Proxy mechanism.\n\nIn GDAL 2, the arguments nXSize, nYSize and nBands can be passed to 0 when creating a vector-only dataset for a compatible driver.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_executesql-Tuple{ArchGDAL.AbstractDataset,AbstractString}","page":"API Reference","title":"ArchGDAL.unsafe_executesql","text":"unsafe_executesql(dataset::AbstractDataset, query::AbstractString; dialect, spatialfilter)\n\nExecute an SQL statement against the data store.\n\nThe result of an SQL query is either NULL for statements that are in error, or that have no results set, or an OGRLayer pointer representing a results set from the query. Note that this OGRLayer is in addition to the layers in the data store and must be destroyed with ReleaseResultSet() before the dataset is closed (destroyed).\n\nFor more information on the SQL dialect supported internally by OGR review the OGR SQL document. Some drivers (i.e. Oracle and PostGIS) pass the SQL directly through to the underlying RDBMS.\n\nStarting with OGR 1.10, the SQLITE dialect can also be used.\n\nParameters\n\ndataset: the dataset handle.\nquery: the SQL statement to execute.\nspatialfilter: geometry which represents a spatial filter. Can be NULL.\ndialect: allows control of the statement dialect. If set to NULL, the   OGR SQL engine will be used, except for RDBMS drivers that will use their   dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect.   Starting with OGR 1.10, the SQLITE dialect can also be used.\n\nReturns\n\nan OGRLayer containing the results of the query. Deallocate with ReleaseResultSet().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_read-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.unsafe_read","text":"unsafe_read(filename; flags=OF_ReadOnly, alloweddrivers, options, siblingfiles)\n\nOpen a raster file as a GDALDataset.\n\nThis function will try to open the passed file, or virtual dataset name by invoking the Open method of each registered GDALDriver in turn. The first successful open will result in a returned dataset. If all drivers fail then NULL is returned and an error is issued.\n\nParameters\n\nfilename  the name of the file to access. In the case of exotic drivers\n\nthis may not refer to a physical file, but instead contain information for the driver on how to access a dataset. It should be in UTF-8 encoding.\n\nflags     a combination of GDAL_OF_* flags (listed below) that may be             combined through the logical | operator.\nDriver kind: GDALOFRASTER for raster drivers, GDALOFVECTOR for vector              drivers. If none of the value is specified, both are implied.\nAccess mode: OF_ReadOnly (exclusive) or OF_Update.\nShared mode: GDAL_OF_SHARED. If set, it allows the sharing of              GDALDataset handles for a dataset with other callers that              have set GDALOFSHARED. In particular, GDALOpenEx() will              consult its list of currently open and shared GDALDataset's,              and if the GetDescription() name for one exactly matches the              pszFilename passed to GDALOpenEx() it will be referenced and              returned, if GDALOpenEx() is called from the same thread.\nVerbose error: GDALOFVERBOSE_ERROR. If set, a failed attempt to open the              file will lead to an error message to be reported.\noptions: additional format dependent options.\n\nAdditional Remarks\n\nSeveral recommendations:\n\nIf you open a dataset object with GA_Update access, it is not recommended\n\nto open a new dataset on the same underlying file.\n\nThe returned dataset should only be accessed by one thread at a time. To use\n\nit from different threads, you must add all necessary code (mutexes, etc.) to avoid concurrent use of the object. (Some drivers, such as GeoTIFF, maintain internal state variables that are updated each time a new block is read, preventing concurrent use.)\n\nIn order to reduce the need for searches through the operating system file\n\nsystem machinery, it is possible to give an optional list of files with the papszSiblingFiles parameter. This is the list of all files at the same level in the file system as the target file, including the target file. The filenames must not include any path components, are essentially just the output of VSIReadDir() on the parent directory. If the target object does not have filesystem semantics then the file list should be NULL.\n\nIn some situations (dealing with unverified data), the datasets can be opened in another process through the GDAL API Proxy mechanism.\n\nFor drivers supporting the VSI virtual file API, it is possible to open a file in a .zip archive (see VSIInstallZipFileHandler()), a .tar/.tar.gz/.tgz archive (see VSIInstallTarFileHandler()), or a HTTP / FTP server (see VSIInstallCurlFileHandler())\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.width-Tuple{ArchGDAL.AbstractDataset}","page":"API Reference","title":"ArchGDAL.width","text":"width(dataset::AbstractDataset)\n\nFetch raster width in pixels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.write-Tuple{ArchGDAL.AbstractDataset,AbstractString}","page":"API Reference","title":"ArchGDAL.write","text":"write(dataset::AbstractDataset, filename::AbstractString; kwargs...)\n\nWrites the dataset to the designated filename.\n\n\n\n\n\n","category":"method"},{"location":"reference/#API-Feature-Data-1","page":"API Reference","title":"Feature Data","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"feature.jl\", \"featuredefn.jl\", \"featurelayer.jl\", \"fielddefn.jl\", \"geometry.jl\", \"styletable.jl\", \"context.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.asbinary-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asbinary","text":"asbinary(feature::Feature, i::Integer)\n\nFetch field value as binary.\n\nParameters\n\nhFeat: handle to the feature that owned the field.\niField: the field to fetch, from 0 to GetFieldCount()-1.\n\nReturns\n\nthe field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asdatetime-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asdatetime","text":"asdatetime(feature::Feature, i::Integer)\n\nFetch field value as date and time.\n\nParameters\n\nhFeat: handle to the feature that owned the field.\niField: the field to fetch, from 0 to GetFieldCount()-1.\n\nReturns\n\ntrue on success or false on failure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asdouble-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asdouble","text":"asdouble(feature::Feature, i::Integer)\n\nFetch field value as a double.\n\nParameters\n\nfeature: the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asdoublelist-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asdoublelist","text":"asdoublelist(feature::Feature, i::Integer)\n\nFetch field value as a list of doubles.\n\nParameters\n\nhFeat: handle to the feature that owned the field.\niField: the field to fetch, from 0 to GetFieldCount()-1.\npnCount: an integer to put the list count (number of doubles) into.\n\nReturns\n\nthe field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asint-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asint","text":"asint(feature::Feature, i::Integer)\n\nFetch field value as integer.\n\nParameters\n\nfeature: the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asint64-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asint64","text":"asint64(feature::Feature, i::Integer)\n\nFetch field value as integer 64 bit.\n\nParameters\n\nfeature: the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asint64list-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asint64list","text":"asint64list(feature::Feature, i::Integer)\n\nFetch field value as a list of 64 bit integers.\n\nParameters\n\nhFeat: handle to the feature that owned the field.\niField: the field to fetch, from 0 to GetFieldCount()-1.\npnCount: an integer to put the list count (number of integers) into.\n\nReturns\n\nthe field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asintlist-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asintlist","text":"asintlist(feature::Feature, i::Integer)\n\nFetch field value as a list of integers.\n\nParameters\n\nhFeat: handle to the feature that owned the field.\niField: the field to fetch, from 0 to GetFieldCount()-1.\npnCount: an integer to put the list count (number of integers) into.\n\nReturns\n\nthe field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asstring-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asstring","text":"asstring(feature::Feature, i::Integer)\n\nFetch field value as a string.\n\nParameters\n\nfeature: the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asstringlist-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.asstringlist","text":"asstringlist(feature::Feature, i::Integer)\n\nFetch field value as a list of strings.\n\nParameters\n\nhFeat: handle to the feature that owned the field.\niField: the field to fetch, from 0 to GetFieldCount()-1.\n\nReturns\n\nthe field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.destroy","text":"destroy(feature::Feature)\n\nDestroy the feature passed in.\n\nThe feature is deleted, but within the context of the GDAL/OGR heap. This is necessary when higher level applications use GDAL/OGR from a DLL and they want to delete a feature created within the DLL. If the delete is done in the calling application the memory will be freed onto the application heap which is inappropriate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.fillunsetwithdefault!-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.fillunsetwithdefault!","text":"fillunsetwithdefault!(feature::Feature; notnull = true, options = StringList(C_NULL))\n\nFill unset fields with default values that might be defined.\n\nParameters\n\nfeature: handle to the feature.\nnotnull: if we should fill only unset fields with a not-null constraint.\npapszOptions: unused currently. Must be set to NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findfieldindex-Tuple{ArchGDAL.Feature,AbstractString}","page":"API Reference","title":"ArchGDAL.findfieldindex","text":"findfieldindex(feature::Feature, name::AbstractString)\n\nFetch the field index given field name.\n\nParameters\n\nfeature: the feature on which the field is found.\nname: the name of the field to search for.\n\nReturns\n\nthe field index, or -1 if no matching field is found.\n\nRemarks\n\nThis is a cover for the OGRFeatureDefn::GetFieldIndex() method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findgeomindex","page":"API Reference","title":"ArchGDAL.findgeomindex","text":"findgeomindex(feature::Feature, name::AbstractString=\"\")\n\nFetch the geometry field index given geometry field name.\n\nParameters\n\nfeature: the feature on which the geometry field is found.\nname: the name of the geometry field to search for. (defaults to \"\")\n\nReturns\n\nthe geometry field index, or -1 if no matching geometry field is found.\n\nRemarks\n\nThis is a cover for the OGRFeatureDefn::GetGeomFieldIndex() method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.getfid-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getfid","text":"getfid(feature::Feature)\n\nGet feature identifier.\n\nReturns\n\nfeature id or OGRNullFID (-1) if none has been assigned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getfielddefn-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.getfielddefn","text":"getfielddefn(feature::Feature, i::Integer)\n\nFetch definition for this field.\n\nParameters\n\nfeature: the feature on which the field is found.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\nReturns\n\nan handle to the field definition (from the FeatureDefn). This is an internal reference, and should not be deleted or modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeom-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.getgeom","text":"getgeom(feature::Feature, i::Integer)\n\nReturns a clone of the feature geometry at index i.\n\nParameters\n\nfeature: the feature to get geometry from.\ni: geometry field to get.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeom-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getgeom","text":"getgeom(feature::Feature)\n\nReturns a clone of the geometry corresponding to the feature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeomdefn-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.getgeomdefn","text":"getgeomdefn(feature::Feature, i::Integer)\n\nFetch definition for this geometry field.\n\nParameters\n\nfeature: the feature on which the field is found.\ni: the field to fetch, from 0 to GetGeomFieldCount()-1.\n\nReturns\n\nThe field definition (from the OGRFeatureDefn). This is an internal reference, and should not be deleted or modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getmediatype-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getmediatype","text":"getmediatype(feature::Feature)\n\nReturns the native media type for the feature.\n\nThe native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see https://en.wikipedia.org/wiki/Media_type), e.g. \"application/vnd.geo+json\" for JSON.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getnativedata-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getnativedata","text":"getnativedata(feature::Feature)\n\nReturns the native data for the feature.\n\nThe native data is the representation in a \"natural\" form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by GetNativeMediaType().\n\nNote that most drivers do not support storing the native data in the feature object, and if they do, generally the NATIVE_DATA open option must be passed at dataset opening.\n\nThe \"native data\" does not imply it is something more performant or powerful than what can be obtained with the rest of the API, but it may be useful in round-tripping scenarios where some characteristics of the underlying format are not captured otherwise by the OGR abstraction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getstylestring-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getstylestring","text":"getstylestring(feature::Feature)\n\nFetch style string for this feature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getstyletable-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getstyletable","text":"getstyletable(feature::Feature)\n\nFetch style table for this feature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isfieldset-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.isfieldset","text":"isfieldset(feature::Feature, i::Integer)\n\nTest if a field has ever been assigned a value or not.\n\nParameters\n\nfeature: the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nfield-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.nfield","text":"nfield(feature::Feature)\n\nFetch number of fields on this feature.\n\nThis will always be the same as the field count for the OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ngeom-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.ngeom","text":"ngeom(feature::Feature)\n\nFetch number of geometry fields on this feature.\n\nThis will always be the same as the geometry field count for OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setfid!-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.setfid!","text":"setfid!(feature::Feature, i::Integer)\n\nSet the feature identifier.\n\nParameters\n\nfeature: handle to the feature to set the feature id to.\ni: the new feature identifier value to assign.\n\nReturns\n\nOn success OGRERR_NONE, or on failure some other value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setfield!","page":"API Reference","title":"ArchGDAL.setfield!","text":"setfield!(feature::Feature, i::Integer, value)\nsetfield!(feature::Feature, i::Integer, value::DateTime, tzflag::Int = 0)\n\nSet a feature's i-th field to value.\n\nThe following types for value are accepted: Int32, Int64, Float64, AbstractString, or a Vector with those in it, as well as Vector{UInt8}. For DateTime values, an additional keyword argument tzflag is accepted (0=unknown, 1=localtime, 100=GMT, see data model for details).\n\nOFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.\n\nParameters\n\nfeature: handle to the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\nvalue: the value to assign.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.setfrom!","page":"API Reference","title":"ArchGDAL.setfrom!","text":"setfrom!(feature1::Feature, feature2::Feature, forgiving::Bool = false)\nsetfrom!(feature1::Feature, feature2::Feature, indices::Vector{Cint}, forgiving::Bool = false)\n\nSet one feature from another.\n\nParameters\n\nfeature1: handle to the feature to set to.\nfeature2: handle to the feature from which geometry, and field values   will be copied.\nindices: indices of the destination feature's fields stored at the   corresponding index of the source feature's fields. A value of -1 should   be used to ignore the source's field. The array should not be NULL and be   as long as the number of fields in the source feature.\nforgiving: true if the operation should continue despite lacking output   fields matching some of the source fields.\n\nReturns\n\nOGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.setgeom!-Tuple{ArchGDAL.Feature,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.setgeom!","text":"setgeom!(feature::Feature, geom::AbstractGeometry)\n\nSet feature geometry.\n\nThis method updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this method does not assume ownership of the passed geometry, but instead makes a copy of it.\n\nParameters\n\nfeature: the feature on which new geometry is applied to.\ngeom: the new geometry to apply to feature.\n\nReturns\n\nOGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setgeom!-Tuple{ArchGDAL.Feature,Integer,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.setgeom!","text":"setgeom!(feature::Feature, i::Integer, geom::AbstractGeometry)\n\nSet feature geometry of a specified geometry field.\n\nThis function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.\n\nParameters\n\nfeature: the feature on which to apply the geometry.\ni: geometry field to set.\ngeom: the new geometry to apply to feature.\n\nReturns\n\nOGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setmediatype!-Tuple{ArchGDAL.Feature,AbstractString}","page":"API Reference","title":"ArchGDAL.setmediatype!","text":"setmediatype!(feature::Feature, mediatype::AbstractString)\n\nSets the native media type for the feature.\n\nThe native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see https://en.wikipedia.org/wiki/Media_type), e.g. \"application/vnd.geo+json\" for JSON.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setnativedata!-Tuple{ArchGDAL.Feature,AbstractString}","page":"API Reference","title":"ArchGDAL.setnativedata!","text":"setnativedata!(feature::Feature, data::AbstractString)\n\nSets the native data for the feature.\n\nThe native data is the representation in a \"natural\" form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by GetNativeMediaType().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setstylestring!-Tuple{ArchGDAL.Feature,AbstractString}","page":"API Reference","title":"ArchGDAL.setstylestring!","text":"setstylestring!(feature::Feature, style::AbstractString)\n\nSet feature style string.\n\nThis method operate exactly as setstylestringdirectly!() except that it doesn't assume ownership of the passed string, but makes a copy of it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setstyletable!-Tuple{ArchGDAL.Feature,ArchGDAL.StyleTable}","page":"API Reference","title":"ArchGDAL.setstyletable!","text":"setstyletable!(feature::Feature, styletable::StyleTable)\n\nSet the style table for this feature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_clone-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.unsafe_clone","text":"unsafe_clone(feature::Feature)\n\nDuplicate feature.\n\nThe newly created feature is owned by the caller, and will have its own reference to the OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsetfield!-Tuple{ArchGDAL.Feature,Integer}","page":"API Reference","title":"ArchGDAL.unsetfield!","text":"unsetfield!(feature::Feature, i::Integer)\n\nClear a field, marking it as unset.\n\nParameters\n\nfeature: the feature that owned the field.\ni: the field to fetch, from 0 to GetFieldCount()-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.validate-Tuple{ArchGDAL.Feature,Integer,Bool}","page":"API Reference","title":"ArchGDAL.validate","text":"validate(feature::Feature, flags::Integer, emiterror::Bool)\n\nValidate that a feature meets constraints of its schema.\n\nThe scope of test is specified with the nValidateFlags parameter.\n\nRegarding OGR_F_VAL_WIDTH, the test is done assuming the string width must be interpreted as the number of UTF-8 characters. Some drivers might interpret the width as the number of bytes instead. So this test is rather conservative (if it fails, then it will fail for all interpretations).\n\nParameters\n\nfeature: handle to the feature to validate.\nflags: OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL,   OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and   OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with | operator\nemiterror: true if a CPLError() must be emitted when a check fails\n\nReturns\n\ntrue if all enabled validation tests pass.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addfielddefn!-Tuple{ArchGDAL.FeatureDefn,ArchGDAL.FieldDefn}","page":"API Reference","title":"ArchGDAL.addfielddefn!","text":"addfielddefn!(featuredefn::FeatureDefn, fielddefn::FieldDefn)\n\nAdd a new field definition to the passed feature definition.\n\nTo add a new field definition to a layer definition, do not use this function directly, but use OGRLCreateField() instead.\n\nThis function should only be called while there are no OGRFeature objects in existence based on this OGRFeatureDefn. The OGRFieldDefn passed in is copied, and remains the responsibility of the caller.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addgeomdefn!-Tuple{ArchGDAL.FeatureDefn,ArchGDAL.AbstractGeomFieldDefn}","page":"API Reference","title":"ArchGDAL.addgeomdefn!","text":"addgeomdefn!(featuredefn::FeatureDefn, geomfielddefn::AbstractGeomFieldDefn)\n\nAdd a new field definition to the passed feature definition.\n\nTo add a new geometry field definition to a layer definition, do not use this function directly, but use OGRLayer::CreateGeomField() instead.\n\nThis method does an internal copy of the passed geometry field definition, unless bCopy is set to false (in which case it takes ownership of the field definition.\n\nThis method should only be called while there are no OGRFeature objects in existence based on this OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.deletefielddefn!-Tuple{ArchGDAL.FeatureDefn,Integer}","page":"API Reference","title":"ArchGDAL.deletefielddefn!","text":"deletefielddefn!(featuredefn::FeatureDefn, i::Integer)\n\nDelete an existing field definition.\n\nTo delete an existing field definition from a layer definition, do not use this function directly, but use OGR_L_DeleteField() instead.\n\nThis method should only be called while there are no OGRFeature objects in existence based on this OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.deletegeomdefn!-Tuple{ArchGDAL.FeatureDefn,Integer}","page":"API Reference","title":"ArchGDAL.deletegeomdefn!","text":"deletegeomdefn!(featuredefn::FeatureDefn, i::Integer)\n\nDelete an existing geometry field definition.\n\nTo delete an existing field definition from a layer definition, do not use this function directly, but use OGRLayer::DeleteGeomField() instead.\n\nThis method should only be called while there are no OGRFeature objects in existence based on this OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.dereference-Tuple{ArchGDAL.FeatureDefn}","page":"API Reference","title":"ArchGDAL.dereference","text":"dereference(featuredefn::FeatureDefn)\n\nDecrements the reference count by one, and returns the updated count.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.FeatureDefn}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy a feature definition object and release all memory associated with it\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.IFeatureDefnView}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy a feature definition view\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findfieldindex-Tuple{ArchGDAL.AbstractFeatureDefn,AbstractString}","page":"API Reference","title":"ArchGDAL.findfieldindex","text":"findfieldindex(featuredefn::AbstractFeatureDefn, name::AbstractString)\n\nFind field by name.\n\nReturns\n\nthe field index, or -1 if no match found.\n\nRemarks\n\nThis uses the OGRFeatureDefn::GetFieldIndex() method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findgeomindex","page":"API Reference","title":"ArchGDAL.findgeomindex","text":"findgeomindex(featuredefn::AbstractFeatureDefn, name::AbstractString = \"\")\n\nFind geometry field by name.\n\nThe geometry field index of the first geometry field matching the passed field name (case insensitively) is returned.\n\nReturns\n\nthe geometry field index, or -1 if no match found.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.getfeaturedefn-Tuple{ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.getfeaturedefn","text":"getfeaturedefn(feature::Feature)\n\nFetch feature definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getfielddefn-Tuple{ArchGDAL.FeatureDefn,Integer}","page":"API Reference","title":"ArchGDAL.getfielddefn","text":"getfielddefn(featuredefn::FeatureDefn, i::Integer)\n\nFetch field definition of the passed feature definition.\n\nParameters\n\nfeaturedefn: the feature definition to get the field definition from.\ni:  index of the field to fetch, between 0 and nfield(featuredefn)-1.\n\nReturns\n\nan handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeomdefn","page":"API Reference","title":"ArchGDAL.getgeomdefn","text":"getgeomdefn(featuredefn::FeatureDefn, i::Integer = 0)\n\nFetch geometry field definition of the passed feature definition.\n\nParameters\n\ni  geometry field to fetch, between 0 (default) and ngeomfield(fd)-1.\n\nReturns\n\nan internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.getgeomtype-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.getgeomtype","text":"getgeomtype(featuredefn::AbstractFeatureDefn)\n\nFetch the geometry base type of the passed feature definition.\n\nFor layers without any geometry field, this method returns wkbNone.\n\nThis returns the same result as OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)) but for a few drivers, calling OGR_L_GetGeomType() directly can avoid lengthy layer definition initialization.\n\nFor layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use     OGR_GFld_GetType(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(featuredefn::AbstractFeatureDefn)\n\nGet name of the OGRFeatureDefn passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isgeomignored-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.isgeomignored","text":"isgeomignored(featuredefn::AbstractFeatureDefn)\n\nDetermine whether the geometry can be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.issame-Tuple{ArchGDAL.AbstractFeatureDefn,ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.issame","text":"issame(featuredefn1::AbstractFeatureDefn, featuredefn2::AbstractFeatureDefn)\n\nTest if the feature definition is identical to the other one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isstyleignored-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.isstyleignored","text":"isstyleignored(featuredefn::AbstractFeatureDefn)\n\nDetermine whether the style can be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nfield-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.nfield","text":"nfield(featuredefn::AbstractFeatureDefn)\n\nFetch number of fields on the passed feature definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ngeom-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.ngeom","text":"ngeom(featuredefn::AbstractFeatureDefn)\n\nFetch number of geometry fields on the passed feature definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nreference-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.nreference","text":"nreference(featuredefn::AbstractFeatureDefn)\n\nFetch the current reference count.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.reference-Tuple{ArchGDAL.FeatureDefn}","page":"API Reference","title":"ArchGDAL.reference","text":"reference(featuredefn::FeatureDefn)\n\nIncrements the reference count in the FeatureDefn by one.\n\nThe count is used to track the number of Features referencing this definition.\n\nReturns\n\nThe updated reference count.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.release-Tuple{ArchGDAL.FeatureDefn}","page":"API Reference","title":"ArchGDAL.release","text":"release(featuredefn::FeatureDefn)\n\nDrop a reference, and destroy if unreferenced.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.reorderfielddefns!-Tuple{ArchGDAL.FeatureDefn,Array{Int32,1}}","page":"API Reference","title":"ArchGDAL.reorderfielddefns!","text":"reorderfielddefns!(featuredefn::FeatureDefn, indices::Vector{Cint})\n\nReorder the field definitions in the array of the feature definition.\n\nTo reorder the field definitions in a layer definition, do not use this function directly, but use OGR_L_ReorderFields() instead.\n\nThis method should only be called while there are no OGRFeature objects in existence based on this OGRFeatureDefn.\n\nParameters\n\nfd: handle to the feature definition.\nindices: an array of GetFieldCount() elements which is a permutation of   [0, GetFieldCount()-1]. indices is such that, for each field definition   at position i after reordering, its position before reordering was   indices[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setgeomignored!-Tuple{ArchGDAL.FeatureDefn,Bool}","page":"API Reference","title":"ArchGDAL.setgeomignored!","text":"setgeomignored!(featuredefn::FeatureDefn, ignore::Bool)\n\nSet whether the geometry can be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setgeomtype!-Tuple{ArchGDAL.FeatureDefn,GDAL.OGRwkbGeometryType}","page":"API Reference","title":"ArchGDAL.setgeomtype!","text":"setgeomtype!(featuredefn::FeatureDefn, etype::OGRwkbGeometryType)\n\nAssign the base geometry type for the passed layer (same as the fd).\n\nAll geometry objects using this type must be of the defined type or a derived type. The default upon creation is wkbUnknown which allows for any geometry type. The geometry type should generally not be changed after any OGRFeatures have been created against this definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setstyleignored!-Tuple{ArchGDAL.FeatureDefn,Bool}","page":"API Reference","title":"ArchGDAL.setstyleignored!","text":"setstyleignored!(featuredefn::FeatureDefn, ignore::Bool)\n\nSet whether the style can be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createfeature-Tuple{ArchGDAL.AbstractFeatureDefn}","page":"API Reference","title":"ArchGDAL.unsafe_createfeature","text":"unsafe_createfeature(featuredefn::AbstractFeatureDefn)\n\nReturns the new feature object with null fields and no geometry\n\nNote that the OGRFeature will increment the reference count of it's defining OGRFeatureDefn. Destruction of the OGRFeatureDefn before destruction of all OGRFeatures that depend on it is likely to result in a crash.\n\nStarting with GDAL 2.1, returns NULL in case out of memory situation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createfeaturedefn-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.unsafe_createfeaturedefn","text":"unsafe_createfeaturedefn(name::AbstractString)\n\nCreate a new feature definition object to hold field definitions.\n\nThe FeatureDefn maintains a reference count, but this starts at zero, and should normally be incremented by the owner.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addfeature!-Tuple{ArchGDAL.AbstractFeatureLayer,ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.addfeature!","text":"addfeature!(layer::AbstractFeatureLayer, feature::Feature)\n\nWrite a new feature within a layer.\n\nRemarks\n\nThe passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addfielddefn!","page":"API Reference","title":"ArchGDAL.addfielddefn!","text":"addfielddefn!(layer::AbstractFeatureLayer, field::AbstractFieldDefn, approx = false)\n\nCreate a new field on a layer.\n\nParameters\n\nlayer:  the layer to write the field definition.\nfield:  the field definition to write to disk.\napprox: If true, the field may be created in a slightly different form           depending on the limitations of the format driver.\n\nRemarks\n\nYou must use this to create new fields on a real layer. Internally the OGRFeatureDefn for the layer will be updated to reflect the new field. Applications should never modify the OGRFeatureDefn used by a layer directly.\n\nThis function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.\n\nNot all drivers support this function. You can query a layer to check if it supports it with the GDAL.OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.\n\nDrivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.addgeomdefn!","page":"API Reference","title":"ArchGDAL.addgeomdefn!","text":"addgeomdefn!(layer::AbstractFeatureLayer, field::AbstractGeomFieldDefn, approx = false)\n\nCreate a new geometry field on a layer.\n\nParameters\n\nlayer:  the layer to write the field definition.\nfield:  the geometry field definition to write to disk.\napprox: If true, the field may be created in a slightly different form           depending on the limitations of the format driver.\n\nRemarks\n\nYou must use this to create new geometry fields on a real layer. Internally the OGRFeatureDefn for the layer will be updated to reflect the new field. Applications should never modify the OGRFeatureDefn used by a layer directly.\n\nThis function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.\n\nNot all drivers support this function. You can query a layer to check if it supports it with the GDAL.OLCCreateGeomField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.\n\nDrivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.copy-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.copy","text":"copy(layer, dataset, name, options)\n\nCopy an existing layer.\n\nThis method creates a new layer, duplicate the field definitions of the source layer, and then duplicates each feature of the source layer.\n\nParameters\n\nlayer: source layer to be copied.\n\nKeyword Arguments\n\ndataset: the dataset handle. (Creates a new dataset in memory by default.)\nname: the name of the layer to create on the dataset.\noptions: a StringList of name=value (driver-specific) options.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.createlayer-Tuple{}","page":"API Reference","title":"ArchGDAL.createlayer","text":"createlayer(name, dataset, geom, spatialref, options)\n\nThis function attempts to create a new layer on the dataset with the indicated name, spatialref, and geometry type.\n\nKeyword Arguments\n\nname: the name for the new layer. This should ideally not match any   existing layer on the datasource. Defaults to an empty string.\ndataset: the dataset. Defaults to creating a new in memory dataset.\ngeom: the geometry type for the layer. Use wkbUnknown (default) if   there are no constraints on the types geometry to be written.\nspatialref: the coordinate system to use for the new layer.\noptions: a StringList of name=value (driver-specific) options.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.deletefeature!-Tuple{ArchGDAL.AbstractFeatureLayer,Integer}","page":"API Reference","title":"ArchGDAL.deletefeature!","text":"deletefeature!(layer::AbstractFeatureLayer, i::Integer)\n\nDelete feature with fid i from layer.\n\nRemarks\n\nThe feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERRUNSUPPORTEDOPERATION. The OGRLTestCapability() function may be called with OLCDeleteFeature to check if the driver supports feature deletion.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.dereference-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.dereference","text":"dereference(layer::AbstractFeatureLayer)\n\nDecrement layer reference count.\n\nReturns\n\nThe reference count after decrementing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.envelope","page":"API Reference","title":"ArchGDAL.envelope","text":"envelope(layer::AbstractFeatureLayer, force::Bool = false)\nenvelope(layer::AbstractFeatureLayer, i::Integer, force::Bool = false)\n\nFetch the extent of this layer.\n\nReturns the extent (MBR) of the data in the layer. If force is false, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If force is true then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.\n\nParameters\n\nlayer: handle to the layer from which to get extent.\ni:     (optional) the index of the geometry field to compute the extent.\nforce: Flag indicating whether the extent should be computed even if it is           expensive.\n\nAdditional Remarks\n\nDepending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call GetExtent() without setting a spatial filter.\n\nLayers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.\n\nNote that some implementations of this method may alter the read cursor of the layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.fidcolumnname-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.fidcolumnname","text":"fidcolumnname(layer::AbstractFeatureLayer)\n\nThe name of the FID column in the database, or \"\" if not supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findfieldindex-Tuple{ArchGDAL.AbstractFeatureLayer,AbstractString,Bool}","page":"API Reference","title":"ArchGDAL.findfieldindex","text":"findfieldindex(layer::AbstractFeatureLayer, field::AbstractString, exactmatch::Bool)\n\nFind the index of the field in a layer, or -1 if the field doesn't exist.\n\nIf exactmatch is set to false and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.geomcolumnname-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.geomcolumnname","text":"geomcolumnname(layer::AbstractFeatureLayer)\n\nThe name of the geometry column in the database, or \"\" if not supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeomtype-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.getgeomtype","text":"getgeomtype(layer::AbstractFeatureLayer)\n\nReturn the layer geometry type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.getname","text":"getname(layer::AbstractFeatureLayer)\n\nReturn the layer name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getspatialfilter-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.getspatialfilter","text":"getspatialfilter(layer::AbstractFeatureLayer)\n\nReturns the current spatial filter for this layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getspatialref-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.getspatialref","text":"getspatialref(layer::AbstractFeatureLayer)\n\nReturns a clone of the spatial reference system for this layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.layerdefn-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.layerdefn","text":"layerdefn(layer::AbstractFeatureLayer)\n\nReturns a view of the schema information for this layer.\n\nRemarks\n\nThe featuredefn is owned by the layer and should not be modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nfeature","page":"API Reference","title":"ArchGDAL.nfeature","text":"nfeature(layer::AbstractFeatureLayer, force::Bool = false)\n\nFetch the feature count in this layer, or -1 if the count is not known.\n\nParameters\n\nlayer: handle to the layer that owned the features.\nforce: flag indicating whether the count should be computed even if it is   expensive. (false by default.)\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.nfield-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.nfield","text":"nfield(layer::AbstractFeatureLayer)\n\nFetch number of fields on the feature layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ngeom-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.ngeom","text":"ngeom(layer::AbstractFeatureLayer)\n\nFetch number of geometry fields on the feature layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nreference-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.nreference","text":"nreference(layer::AbstractFeatureLayer)\n\nThe current reference count for the layer object itself.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.reference-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.reference","text":"reference(layer::AbstractFeatureLayer)\n\nIncrement layer reference count.\n\nReturns\n\nThe reference count after incrementing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.resetreading!-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.resetreading!","text":"resetreading!(layer::AbstractFeatureLayer)\n\nReset feature reading to start on the first feature.\n\nThis affects nextfeature().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setattributefilter!-Tuple{ArchGDAL.AbstractFeatureLayer,AbstractString}","page":"API Reference","title":"ArchGDAL.setattributefilter!","text":"setattributefilter!(layer::AbstractFeatureLayer, query::AbstractString)\n\nSet a new attribute query.\n\nThis method sets the attribute query string to be used when fetching features via the nextfeature() method. Only features for which the query evaluates as true will be returned.\n\nParameters\n\nlayer: handle to the layer on which attribute query will be executed.\nquery: query in restricted SQL WHERE format.\n\nRemarks\n\nThe query string should be in the format of an SQL WHERE clause. For instance \"population > 1000000 and population < 5000000\" where population is an attribute in the layer. The query format is normally a restricted form of SQL WHERE clause as described in the \"WHERE\" section of the OGR SQL tutorial. In some cases (RDBMS backed drivers) the native capabilities of the database may be used to interpret the WHERE clause in which case the capabilities will be broader than those of OGR SQL.\n\nNote that installing a query string will generally result in resetting the current reading position (ala resetreading!()).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setfeature!-Tuple{ArchGDAL.AbstractFeatureLayer,ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.setfeature!","text":"setfeature!(layer::AbstractFeatureLayer, feature::Feature)\n\nRewrite an existing feature.\n\nThis function will write a feature to the layer, based on the feature id within the OGRFeature.\n\nRemarks\n\nUse OGRLTestCapability(OLCRandomWrite) to establish if this layer supports random access writing via OGRLSetFeature().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setignoredfields!-Tuple{ArchGDAL.AbstractFeatureLayer,Any}","page":"API Reference","title":"ArchGDAL.setignoredfields!","text":"setignoredfields!(layer::AbstractFeatureLayer, fieldnames)\n\nSet which fields can be omitted when retrieving features from the layer.\n\nParameters\n\nfieldnames: an array of field names terminated by NULL item. If NULL is\n\npassed, the ignored list is cleared.\n\nRemarks\n\nIf the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to GetFeature()/nextfeature() and thus save some processing time and/or bandwidth.\n\nBesides field names of the layers, the following special fields can be passed: \"OGR_GEOMETRY\" to ignore geometry and \"OGR_STYLE\" to ignore layer style.\n\nBy default, no fields are ignored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setnextbyindex!-Tuple{ArchGDAL.AbstractFeatureLayer,Integer}","page":"API Reference","title":"ArchGDAL.setnextbyindex!","text":"setnextbyindex!(layer::AbstractFeatureLayer, i::Integer)\n\nMove read cursor to the i-th feature in the current resultset.\n\nThis method allows positioning of a layer such that the nextfeature() call will read the requested feature, where i is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with nextfeature() would have been the fourth feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.\n\nParameters\n\nlayer: handle to the layer\ni: the index indicating how many steps into the result set to seek.\n\nRemarks\n\nOnly in rare circumstances is setnextbyindex!() efficiently implemented. In all other cases the default implementation which calls resetreading!() and then calls nextfeature() i times is used. To determine if fast seeking is available on the layer, use the testcapability() method with a value of OLCFastSetNextByIndex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setspatialfilter!-Tuple{ArchGDAL.AbstractFeatureLayer,ArchGDAL.Geometry}","page":"API Reference","title":"ArchGDAL.setspatialfilter!","text":"setspatialfilter!(layer::AbstractFeatureLayer, geom::Geometry)\n\nSet a new spatial filter for the layer, using the geom.\n\nThis method set the geometry to be used as a spatial filter when fetching features via the nextfeature() method. Only features that geometrically intersect the filter geometry will be returned.\n\nParameters\n\nlayer  handle to the layer on which to set the spatial filter.\ngeom   handle to the geometry to use as a filtering region. NULL may be          passed indicating that the current spatial filter should be cleared,          but no new one instituted.\n\nRemarks\n\nCurrently this test may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by OGRGeometry::getEnvelope()) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.\n\nFor the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by GetLayerDefn()->OGRFeatureDefn::GetGeomFieldDefn(i)->GetSpatialRef()). In the future this may be generalized.\n\nNote that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setspatialfilter!-Tuple{ArchGDAL.AbstractFeatureLayer,Integer,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.setspatialfilter!","text":"setspatialfilter!(layer::AbstractFeatureLayer, i::Integer, geom::AbstractGeometry)\n\nSet a new spatial filter.\n\nThis method set the geometry to be used as a spatial filter when fetching features via the nextfeature() method. Only features that geometrically intersect the filter geometry will be returned.\n\nParameters\n\nlayer: the layer on which to set the spatial filter.\ni: index of the geometry field on which the spatial filter operates.\ngeom: the geometry to use as a filtering region. NULL may be passed   indicating that the current spatial filter should be cleared, but   no new one instituted.\n\nRemarks\n\nCurrently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by OGRGeometry::getEnvelope()) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.\n\nFor the time being the passed filter geometry should be in the same SRS as the layer (as returned by OGRLayer::GetSpatialRef()). In the future this may be generalized.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setspatialfilter!-Tuple{ArchGDAL.AbstractFeatureLayer,Integer,Real,Real,Real,Real}","page":"API Reference","title":"ArchGDAL.setspatialfilter!","text":"setspatialfilter!(layer::AbstractFeatureLayer, i::Integer, xmin, ymin, xmax, ymax)\n\nSet a new rectangular spatial filter.\n\nParameters\n\nlayer: the feature layer on which to set the spatial filter.\ni: index of the geometry field on which the spatial filter operates.\nxmin: the minimum X coordinate for the rectangular region.\nymin: the minimum Y coordinate for the rectangular region.\nxmax: the maximum X coordinate for the rectangular region.\nymax: the maximum Y coordinate for the rectangular region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setspatialfilter!-Tuple{ArchGDAL.AbstractFeatureLayer,Real,Real,Real,Real}","page":"API Reference","title":"ArchGDAL.setspatialfilter!","text":"setspatialfilter!(layer::AbstractFeatureLayer, xmin, ymin, xmax, ymax)\n\nSet a new rectangular spatial filter for the layer.\n\nThis method set rectangle to be used as a spatial filter when fetching features via the nextfeature() method. Only features that geometrically intersect the given rectangle will be returned.\n\nThe x/y values should be in the same coordinate system as the layer as a whole (as returned by OGRLayer::GetSpatialRef()). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to OGRLayer::SetSpatialFilter(). It exists as a convenience.\n\nThe only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.testcapability-Tuple{ArchGDAL.AbstractFeatureLayer,AbstractString}","page":"API Reference","title":"ArchGDAL.testcapability","text":"testcapability(layer::AbstractFeatureLayer, capability::AbstractString)\n\nTest if this layer supported the named capability.\n\nParameters\n\ncapability  the name of the capability to test.\n\nReturns\n\ntrue if the layer has the requested capability, false otherwise. It will return false for any unrecognized capabilities.\n\nAdditional Remarks\n\nThe capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller.\n\nOLCRandomRead / \"RandomRead\": true if the GetFeature() method is   implemented in an optimized way for this layer, as opposed to the default   implementation using resetreading!() and nextfeature() to find the   requested feature id.\nOLCSequentialWrite / \"SequentialWrite\": true if the CreateFeature() method   works for this layer. Note this means that this particular layer is   writable. The same OGRLayer class may returned false for other layer   instances that are effectively read-only.\nOLCRandomWrite / \"RandomWrite\": true if the SetFeature() method is   operational on this layer. Note this means that this particular layer is   writable. The same OGRLayer class may returned false for other layer   instances that are effectively read-only.\nOLCFastSpatialFilter / \"FastSpatialFilter\": true if this layer implements   spatial filtering efficiently. Layers that effectively read all features,   and test them with the OGRFeature intersection methods should return false.   This can be used as a clue by the application whether it should build and   maintain its own spatial index for features in this layer.\nOLCFastFeatureCount / \"FastFeatureCount\": true if this layer can return a   feature count (via GetFeatureCount()) efficiently. i.e. without counting the   features. In some cases this will return true until a spatial filter is   installed after which it will return false.\nOLCFastGetExtent / \"FastGetExtent\": true if this layer can return its data   extent (via GetExtent()) efficiently, i.e. without scanning all the   features. In some cases this will return true until a spatial filter is   installed after which it will return false.\nOLCFastSetNextByIndex / \"FastSetNextByIndex\": true if this layer can   perform the SetNextByIndex() call efficiently, otherwise false.\nOLCCreateField / \"CreateField\": true if this layer can create new fields   on the current layer using CreateField(), otherwise false.\nOLCCreateGeomField / \"CreateGeomField\": (GDAL >= 1.11) true if this layer   can create new geometry fields on the current layer using CreateGeomField(),   otherwise false.\nOLCDeleteField / \"DeleteField\": true if this layer can delete existing   fields on the current layer using DeleteField(), otherwise false.\nOLCReorderFields / \"ReorderFields\": true if this layer can reorder   existing fields on the current layer using ReorderField() or   ReorderFields(), otherwise false.\nOLCAlterFieldDefn / \"AlterFieldDefn\": true if this layer can alter the   definition of an existing field on the current layer using AlterFieldDefn(),   otherwise false.\nOLCDeleteFeature / \"DeleteFeature\": true if the DeleteFeature() method is   supported on this layer, otherwise false.\nOLCStringsAsUTF8 / \"StringsAsUTF8\": true if values of OFTString fields are   assured to be in UTF-8 format. If false the encoding of fields is uncertain,   though it might still be UTF-8.\nOLCTransactions / \"Transactions\": true if the StartTransaction(),   CommitTransaction() and RollbackTransaction() methods work in a meaningful   way, otherwise false.\nOLCIgnoreFields / \"IgnoreFields\": true if fields, geometry and style will   be omitted when fetching features as set by SetIgnoredFields() method.\nOLCCurveGeometries / \"CurveGeometries\": true if this layer supports   writing curve geometries or may return such geometries. (GDAL 2.0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createfeature-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.unsafe_createfeature","text":"unsafe_createfeature(layer::AbstractFeatureLayer)\n\nCreate and returns a new feature based on the layer definition.\n\nThe newly feature is owned by the layer (it will increase the number of features the layer by one), but the feature has not been written to the layer yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_getfeature-Tuple{ArchGDAL.AbstractFeatureLayer,Integer}","page":"API Reference","title":"ArchGDAL.unsafe_getfeature","text":"unsafe_getfeature(layer::AbstractFeatureLayer, i::Integer)\n\nReturn a feature (now owned by the caller) by its identifier or NULL on failure.\n\nParameters\n\nlayer: the feature layer to be read from.\ni: the index of the feature to be returned.\n\nRemarks\n\nThis function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).\n\nIf this function returns a non-NULL feature, it is guaranteed that its feature id (OGRFGetFID()) will be the same as nFID.\n\nUse OGRLTestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via OGRLGetFeature(); however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.\n\nSequential reads (with OGRLGetNextFeature()) are generally considered interrupted by a OGRLGetFeature() call.\n\nThe returned feature is now owned by the caller, and should be freed with destroy().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_nextfeature-Tuple{ArchGDAL.AbstractFeatureLayer}","page":"API Reference","title":"ArchGDAL.unsafe_nextfeature","text":"unsafe_nextfeature(layer::AbstractFeatureLayer)\n\nFetch the next available feature from this layer.\n\nParameters\n\nlayer: the feature layer to be read from.\n\nRemarks\n\nThis method implements sequential access to the features of a layer. The resetreading!() method can be used to start at the beginning again. Only features matching the current spatial filter (set with setspatialfilter!()) will be returned.\n\nThe returned feature becomes the responsibility of the caller to delete with destroy(). It is critical that all features associated with a FeatureLayer (more specifically a FeatureDefn) be destroyed before that layer is destroyed.\n\nFeatures returned by nextfeature() may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call resetreading!() on layers where nextfeature() has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to resetreading!() might be needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.FieldDefn}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy a field definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.GeomFieldDefn}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy a geometry field definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.IGeomFieldDefnView}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy a geometry field definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getdefault-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.getdefault","text":"getdefault(fielddefn::AbstractFieldDefn)\n\nGet default field value\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getjustify-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.getjustify","text":"getjustify(fielddefn::AbstractFieldDefn)\n\nGet the justification for this field.\n\nNote: no driver is know to use the concept of field justification.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.getname","text":"Fetch the name of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getname-Tuple{ArchGDAL.AbstractGeomFieldDefn}","page":"API Reference","title":"ArchGDAL.getname","text":"Fetch name of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getprecision-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.getprecision","text":"getprecision(fielddefn::AbstractFieldDefn)\n\nGet the formatting precision for this field.\n\nThis should normally be zero for fields of types other than OFTReal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getspatialref-Tuple{ArchGDAL.AbstractGeomFieldDefn}","page":"API Reference","title":"ArchGDAL.getspatialref","text":"getspatialref(geomdefn::AbstractGeomFieldDefn)\n\nReturns a clone of the spatial reference system for this field. May be NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getsubtype-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.getsubtype","text":"getsubtype(fielddefn::AbstractFieldDefn)\n\nFetch subtype of this field.\n\nParameters\n\nfielddefn: handle to the field definition to get subtype from.\n\nReturns\n\nfield subtype.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.gettype-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.gettype","text":"Fetch the type of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.gettype-Tuple{ArchGDAL.AbstractGeomFieldDefn}","page":"API Reference","title":"ArchGDAL.gettype","text":"Fetch geometry type of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getwidth-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.getwidth","text":"getwidth(fielddefn::AbstractFieldDefn)\n\nGet the formatting width for this field.\n\nReturns\n\nthe width, zero means no specified width.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isdefaultdriverspecific-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.isdefaultdriverspecific","text":"isdefaultdriverspecific(fielddefn::AbstractFieldDefn)\n\nReturns whether the default value is driver specific.\n\nDriver specific default values are those that are not NULL, a numeric value, a literal value enclosed between single quote characters, CURRENTTIMESTAMP, CURRENTTIME, CURRENT_DATE or datetime literal value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isignored-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.isignored","text":"isignored(fielddefn::AbstractFieldDefn)\n\nReturn whether this field should be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isignored-Tuple{ArchGDAL.AbstractGeomFieldDefn}","page":"API Reference","title":"ArchGDAL.isignored","text":"isignored(geomdefn::AbstractGeomFieldDefn)\n\nReturn whether this field should be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isnullable-Tuple{ArchGDAL.AbstractFieldDefn}","page":"API Reference","title":"ArchGDAL.isnullable","text":"isnullable(fielddefn::AbstractFieldDefn)\n\nReturn whether this field can receive null values.\n\nBy default, fields are nullable.\n\nEven if this method returns false (i.e not-nullable field), it doesn't mean that OGRFeature::IsFieldSet() will necessary return true, as fields can be temporary unset and null/not-null validation is usually done when OGRLayer::CreateFeature()/SetFeature() is called.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isnullable-Tuple{ArchGDAL.AbstractGeomFieldDefn}","page":"API Reference","title":"ArchGDAL.isnullable","text":"isnullable(geomdefn::AbstractGeomFieldDefn)\n\nReturn whether this geometry field can receive null values.\n\nBy default, fields are nullable.\n\nEven if this method returns false (i.e not-nullable field), it doesn't mean that OGRFeature::IsFieldSet() will necessary return true, as fields can be temporary unset and null/not-null validation is usually done when OGRLayer::CreateFeature()/SetFeature() is called.\n\nNote that not-nullable geometry fields might also contain 'empty' geometries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setdefault!-Tuple{ArchGDAL.AbstractFieldDefn,Any}","page":"API Reference","title":"ArchGDAL.setdefault!","text":"setdefault!(fielddefn::AbstractFieldDefn, default)\n\nSet default field value.\n\nThe default field value is taken into account by drivers (generally those with a SQL interface) that support it at field creation time. OGR will generally not automatically set the default field value to null fields by itself when calling OGRFeature::CreateFeature() / OGRFeature::SetFeature(), but will let the low-level layers to do the job. So retrieving the feature from the layer is recommended.\n\nThe accepted values are NULL, a numeric value, a literal value enclosed between single quote characters (and inner single quote characters escaped by repetition of the single quote character), CURRENTTIMESTAMP, CURRENTTIME, CURRENT_DATE or a driver specific expression (that might be ignored by other drivers). For a datetime literal value, format should be 'YYYY/MM/DD HH:MM:SS[.sss]' (considered as UTC time).\n\nDrivers that support writing DEFAULT clauses will advertize the GDALDCAPDEFAULT_FIELDS driver metadata item.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setignored!-Tuple{ArchGDAL.FieldDefn,Bool}","page":"API Reference","title":"ArchGDAL.setignored!","text":"setignored!(fielddefn::FieldDefn, ignore::Bool)\n\nSet whether this field should be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setignored!-Tuple{ArchGDAL.GeomFieldDefn,Bool}","page":"API Reference","title":"ArchGDAL.setignored!","text":"setignored!(geomdefn::GeomFieldDefn, ignore::Bool)\n\nSet whether this field should be omitted when fetching features.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setjustify!-Tuple{ArchGDAL.FieldDefn,GDAL.OGRJustification}","page":"API Reference","title":"ArchGDAL.setjustify!","text":"setjustify!(fielddefn::FieldDefn, ejustify::OGRJustification)\n\nSet the justification for this field.\n\nNote: no driver is know to use the concept of field justification.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setname!-Tuple{ArchGDAL.FieldDefn,AbstractString}","page":"API Reference","title":"ArchGDAL.setname!","text":"Set the name of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setname!-Tuple{ArchGDAL.GeomFieldDefn,AbstractString}","page":"API Reference","title":"ArchGDAL.setname!","text":"Set the name of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setnullable!-Tuple{ArchGDAL.FieldDefn,Bool}","page":"API Reference","title":"ArchGDAL.setnullable!","text":"setnullable!(fielddefn::FieldDefn, nullable::Bool)\n\nSet whether this field can receive null values.\n\nBy default, fields are nullable, so this method is generally called with false to set a not-null constraint.\n\nDrivers that support writing not-null constraint will advertize the GDALDCAPNOTNULL_FIELDS driver metadata item.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setnullable!-Tuple{ArchGDAL.GeomFieldDefn,Bool}","page":"API Reference","title":"ArchGDAL.setnullable!","text":"setnullable!(geomdefn::GeomFieldDefn, nullable::Bool)\n\nSet whether this geometry field can receive null values.\n\nBy default, fields are nullable, so this method is generally called with false to set a not-null constraint.\n\nDrivers that support writing not-null constraint will advertize the GDALDCAPNOTNULL_GEOMFIELDS driver metadata item.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setparams!-Tuple{ArchGDAL.FieldDefn,AbstractString,GDAL.OGRFieldType}","page":"API Reference","title":"ArchGDAL.setparams!","text":"setparams!(fielddefn, name, etype, [nwidth, [nprecision, [justify]]])\n\nSet defining parameters for a field in one call.\n\nParameters\n\nfielddefn:  the field definition to set to.\nname:       the new name to assign.\netype:      the new type (one of the OFT values like OFTInteger).\nnwidth:     the preferred formatting width. 0 (default) indicates undefined.\nnprecision: number of decimals for formatting. 0 (default) for undefined.\njustify:    the formatting justification ([OJUndefined], OJLeft or OJRight)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setprecision!-Tuple{ArchGDAL.FieldDefn,Integer}","page":"API Reference","title":"ArchGDAL.setprecision!","text":"setprecision!(fielddefn::FieldDefn, precision::Integer)\n\nSet the formatting precision for this field in characters.\n\nThis should normally be zero for fields of types other than OFTReal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setspatialref!-Tuple{ArchGDAL.GeomFieldDefn,ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.setspatialref!","text":"setspatialref!(geomdefn::GeomFieldDefn, spatialref::AbstractSpatialRef)\n\nSet the spatial reference of this field.\n\nThis function drops the reference of the previously set SRS object and acquires a new reference on the passed object (if non-NULL).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setsubtype!-Tuple{ArchGDAL.FieldDefn,GDAL.OGRFieldSubType}","page":"API Reference","title":"ArchGDAL.setsubtype!","text":"setsubtype!(fielddefn::FieldDefn, subtype::OGRFieldSubType)\n\nSet the subtype of this field.\n\nThis should never be done to an OGRFieldDefn that is already part of an OGRFeatureDefn.\n\nParameters\n\nfielddefn: handle to the field definition to set type to.\nsubtype: the new field subtype.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.settype!-Tuple{ArchGDAL.FieldDefn,GDAL.OGRFieldType}","page":"API Reference","title":"ArchGDAL.settype!","text":"Set the type of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.settype!-Tuple{ArchGDAL.GeomFieldDefn,GDAL.OGRwkbGeometryType}","page":"API Reference","title":"ArchGDAL.settype!","text":"Set the geometry type of this field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setwidth!-Tuple{ArchGDAL.FieldDefn,Integer}","page":"API Reference","title":"ArchGDAL.setwidth!","text":"setwidth!(fielddefn::FieldDefn, width::Integer)\n\nSet the formatting width for this field in characters.\n\nThis should never be done to an OGRFieldDefn that is already part of an OGRFeatureDefn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createfielddefn-Tuple{AbstractString,GDAL.OGRFieldType}","page":"API Reference","title":"ArchGDAL.unsafe_createfielddefn","text":"unsafe_createfielddefn(name::AbstractString, etype::OGRFieldType)\n\nCreate a new field definition.\n\nBy default, fields have no width, precision, are nullable and not ignored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_creategeomdefn-Tuple{AbstractString,GDAL.OGRwkbGeometryType}","page":"API Reference","title":"ArchGDAL.unsafe_creategeomdefn","text":"unsafe_creategeomdefn(name::AbstractString, etype::OGRwkbGeometryType)\n\nCreate a new field geometry definition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addgeom!-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.addgeom!","text":"addgeom!(geomcontainer::AbstractGeometry, subgeom::AbstractGeometry)\n\nAdd a geometry to a geometry container.\n\nSome subclasses of OGRGeometryCollection restrict the types of geometry that can be added, and may return an error. The passed geometry is cloned to make an internal copy.\n\nFor a polygon, subgeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.\n\nParameters\n\ngeomcontainer: existing geometry.\nsubgeom: geometry to add to the existing geometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addpoint!","page":"API Reference","title":"ArchGDAL.addpoint!","text":"addpoint!(geom::AbstractGeometry, x, y)\naddpoint!(geom::AbstractGeometry, x, y, z)\n\nAdd a point to a geometry (line string or point).\n\nParameters\n\ngeom: the geometry to add a point to.\nx: x coordinate of point to add.\ny: y coordinate of point to add.\nz: z coordinate of point to add.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.boundary-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.boundary","text":"boundary(geom::AbstractGeometry)\n\nReturns the boundary of the geometry.\n\nA new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.buffer","page":"API Reference","title":"ArchGDAL.buffer","text":"buffer(geom::AbstractGeometry, dist::Real, quadsegs::Integer = 30)\n\nCompute buffer of geometry.\n\nBuilds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.\n\nSome buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.\n\nParameters\n\ngeom: the geometry.\ndist: the buffer distance to be applied. Should be expressed into the   same unit as the coordinates of the geometry.\nquadsegs: the number of segments used to approximate a 90 degree   (quadrant) of curvature.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.centroid!-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.centroid!","text":"centroid!(geom::AbstractGeometry, centroid::AbstractGeometry)\n\nCompute the geometry centroid.\n\nThe centroid location is applied to the passed in OGRPoint object. The centroid is not necessarily within the geometry.\n\nThis method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.centroid-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.centroid","text":"centroid(geom::AbstractGeometry)\n\nCompute the geometry centroid.\n\nThe centroid is not necessarily within the geometry.\n\n(This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.clone-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.clone","text":"clone(geom::AbstractGeometry)\n\nReturns a copy of the geometry with the original spatial reference system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.closerings!-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.closerings!","text":"closerings!(geom::AbstractGeometry)\n\nForce rings to be closed.\n\nIf this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.contains-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.contains","text":"contains(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if g1 contains g2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.convexhull-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.convexhull","text":"convexhull(geom::AbstractGeometry)\n\nReturns the convex hull of the geometry.\n\nA new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.creategeom-Tuple{GDAL.OGRwkbGeometryType}","page":"API Reference","title":"ArchGDAL.creategeom","text":"creategeom(geomtype::OGRwkbGeometryType)\n\nCreate an empty geometry of desired type.\n\nThis is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.crosses-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.crosses","text":"crosses(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if the geometries are crossing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.curvegeom-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.curvegeom","text":"curvegeom(geom::AbstractGeometry)\n\nReturn curve version of this geometry.\n\nReturns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating linear into curve geometries.\n\nIf the geometry has no curve portion, the returned geometry will be a clone.\n\nThe reverse function is OGRGGetLinearGeometry().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.delaunaytriangulation-Tuple{ArchGDAL.AbstractGeometry,Real,Bool}","page":"API Reference","title":"ArchGDAL.delaunaytriangulation","text":"delaunaytriangulation(geom::AbstractGeometry, tol::Real, onlyedges::Bool)\n\nReturn a Delaunay triangulation of the vertices of the geometry.\n\nParameters\n\ngeom: the geometry.\ntol: optional snapping tolerance to use for improved robustness\nonlyedges: if true, will return a MULTILINESTRING, otherwise it   will return a GEOMETRYCOLLECTION containing triangular POLYGONs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy geometry object.\n\nEquivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.difference-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.difference","text":"difference(g1::AbstractGeometry, g2::AbstractGeometry)\n\nGenerates a new geometry which is the region of this geometry with the region of the other geometry removed.\n\nReturns\n\nA new geometry representing the difference of the geometries, or NULL if the difference is empty.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.disjoint-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.disjoint","text":"disjoint(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if the geometries are disjoint.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.distance-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.distance","text":"distance(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns the distance between the geometries or -1 if an error occurs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.empty!-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.empty!","text":"empty!(geom::AbstractGeometry)\n\nClear geometry information.\n\nThis restores the geometry to its initial state after construction, and before assignment of actual geometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.envelope-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.envelope","text":"envelope(geom::AbstractGeometry)\n\nComputes and returns the bounding envelope for this geometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.envelope3d-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.envelope3d","text":"envelope3d(geom::AbstractGeometry)\n\nComputes and returns the bounding envelope (3D) for this geometry\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.equals-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.equals","text":"equals(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if the geometries are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.flattento2d!-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.flattento2d!","text":"flattento2d!(geom::AbstractGeometry)\n\nConvert geometry to strictly 2D.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.forceto","page":"API Reference","title":"ArchGDAL.forceto","text":"forceto(geom::AbstractGeometry, targettype::OGRwkbGeometryType, [options])\n\nTries to force the provided geometry to the specified geometry type.\n\nParameters\n\ngeom: the input geometry.\ntargettype: target output geometry type.\n\noptions: (optional) options as a null-terminated vector of strings\n\nIt can promote 'single' geometry type to their corresponding collection type (see OGRGTGetCollection()) or the reverse. non-linear geometry type to their corresponding linear geometry type (see OGRGTGetLinear()), by possibly approximating circular arcs they may contain. Regarding conversion from linear geometry types to curve geometry types, only \"wraping\" will be done. No attempt to retrieve potential circular arcs by de-approximating stroking will be done. For that, OGRGeometry::getCurveGeometry() can be used.\n\nThe passed in geometry is cloned and a new one returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.fromGML-Tuple{Any}","page":"API Reference","title":"ArchGDAL.fromGML","text":"fromGML(data)\n\nCreate geometry from GML.\n\nThis method translates a fragment of GML containing only the geometry portion into a corresponding OGRGeometry. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.\n\nThe following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.fromJSON-Tuple{String}","page":"API Reference","title":"ArchGDAL.fromJSON","text":"fromJSON(data::String)\n\nCreate a geometry object from its GeoJSON representation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.fromWKB-Tuple{Any}","page":"API Reference","title":"ArchGDAL.fromWKB","text":"fromWKB(data)\n\nCreate a geometry object of the appropriate type from it's well known binary (WKB) representation.\n\nParameters\n\ndata: pointer to the input BLOB data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.fromWKT-Tuple{Array{String,1}}","page":"API Reference","title":"ArchGDAL.fromWKT","text":"fromWKT(data::Vector{String})\n\nCreate a geometry object of the appropriate type from its well known text (WKT) representation.\n\nParameters\n\ndata: input zero terminated string containing WKT representation of the   geometry to be created. The pointer is updated to point just beyond that   last character consumed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.geomarea-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.geomarea","text":"geomarea(geom::AbstractGeometry)\n\nReturns the area of the geometry or 0.0 for unsupported geometry types.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.geomdim-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.geomdim","text":"geomdim(geom::AbstractGeometry)\n\nGet the dimension of the geometry. 0 for points, 1 for lines and 2 for surfaces.\n\nThis function corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the geometry, but does not indicate the dimension of the underlying space (as indicated by OGRGGetCoordinateDimension() function).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.geomlength-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.geomlength","text":"geomlength(geom::AbstractGeometry)\n\nReturns the length of the geometry, or 0.0 for unsupported geometry types.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.geomname-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.geomname","text":"geomname(geom::AbstractGeometry)\n\nFetch WKT name for geometry type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getcoorddim-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.getcoorddim","text":"getcoorddim(geom::AbstractGeometry)\n\nGet the dimension of the coordinates in this geometry.\n\nReturns\n\nIn practice this will return 2 or 3. It can also return 0 in the case of an empty point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeom-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.getgeom","text":"getgeom(geom::AbstractGeometry, i::Integer)\n\nFetch geometry from a geometry container.\n\nFor a polygon, getgeom(polygon,i) returns the exterior ring if i == 0, and the interior rings for i > 0.\n\nParameters\n\ngeom: the geometry container from which to get a geometry from.\ni: index of the geometry to fetch, between 0 and getNumGeometries() - 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getgeomtype-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.getgeomtype","text":"getgeomtype(geom::AbstractGeometry)\n\nFetch geometry type code\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getnonlineargeomflag-Tuple{}","page":"API Reference","title":"ArchGDAL.getnonlineargeomflag","text":"getnonlineargeomflag()\n\nGet flag to enable/disable returning non-linear geometries in the C API.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getpoint-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.getpoint","text":"getpoint(geom::AbstractGeometry, i::Integer)\n\nFetch a point in line string or a point geometry, at index i.\n\nParameters\n\ni: the vertex to fetch, from 0 to getNumPoints()-1, zero for a point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getspatialref-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.getspatialref","text":"getspatialref(geom::AbstractGeometry)\n\nReturns a clone of the spatial reference system for the geometry.\n\n(The original SRS may be shared with many objects, and should not be modified.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getx-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.getx","text":"getx(geom::AbstractGeometry, i::Integer)\n\nFetch the x coordinate of a point from a geometry, at index i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.gety-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.gety","text":"gety(geom::AbstractGeometry, i::Integer)\n\nFetch the y coordinate of a point from a geometry, at index i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getz-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.getz","text":"getz(geom::AbstractGeometry, i::Integer)\n\nFetch the z coordinate of a point from a geometry, at index i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.hascurvegeom-Tuple{ArchGDAL.AbstractGeometry,Bool}","page":"API Reference","title":"ArchGDAL.hascurvegeom","text":"hascurvegeom(geom::AbstractGeometry, nonlinear::Bool)\n\nReturns if this geometry is or has curve geometry.\n\nParameters\n\ngeom: the geometry to operate on.\nnonlinear: set it to true to check if the geometry is or contains a   CIRCULARSTRING.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.intersection-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.intersection","text":"intersection(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns a new geometry representing the intersection of the geometries, or NULL if there is no intersection or an error occurs.\n\nGenerates a new geometry which is the region of intersection of the two geometries operated on. The OGRGIntersects() function can be used to test if two geometries intersect.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.intersects-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.intersects","text":"intersects(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns whether the geometries intersect\n\nDetermines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise true is returned if the envelopes (bounding boxes) of the two geometries overlap.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isempty-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.isempty","text":"isempty(geom::AbstractGeometry)\n\nReturns true if the geometry has no points, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isring-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.isring","text":"isring(geom::AbstractGeometry)\n\nReturns true if the geometry is a ring, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.issimple-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.issimple","text":"issimple(geom::AbstractGeometry)\n\nReturns true if the geometry is simple, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.isvalid-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.isvalid","text":"isvalid(geom::AbstractGeometry)\n\nReturns true if the geometry is valid, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.lineargeom","page":"API Reference","title":"ArchGDAL.lineargeom","text":"lineargeom(geom::AbstractGeometry, stepsize::Real = 0)\n\nReturn, possibly approximate, linear version of this geometry.\n\nReturns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.\n\nParameters\n\ngeom: the geometry to operate on.\nstepsize: the largest step in degrees along the arc, zero to use the   default setting.\noptions: options as a null-terminated list of strings or NULL.   See OGRGeometryFactory::curveToLineString() for valid options.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.ngeom-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.ngeom","text":"ngeom(geom::AbstractGeometry)\n\nThe number of elements in a geometry or number of geometries in container.\n\nThis corresponds to\n\nOGR_G_GetPointCount for wkbPoint[25D] or wkbLineString[25D],\nOGR_G_GetGeometryCount for geometries of type wkbPolygon[25D],   wkbMultiPoint[25D], wkbMultiLineString[25D], wkbMultiPolygon[25D] or   wkbGeometryCollection[25D], and\n0 for other geometry types.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.overlaps-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.overlaps","text":"overlaps(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if the geometries overlap.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.pointalongline-Tuple{ArchGDAL.AbstractGeometry,Real}","page":"API Reference","title":"ArchGDAL.pointalongline","text":"pointalongline(geom::AbstractGeometry, distance::Real)\n\nFetch point at given distance along curve.\n\nParameters\n\ngeom: curve geometry.\ndistance: distance along the curve at which to sample position. This   distance should be between zero and geomlength() for this curve.\n\nReturns\n\na point or NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.pointonsurface-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.pointonsurface","text":"pointonsurface(geom::AbstractGeometry)\n\nReturns a point guaranteed to lie on the surface.\n\nThis method relates to the SFCOM ISurface::get_PointOnSurface() method however the current implementation based on GEOS can operate on other geometry types than the types that are supported by SQL/MM-Part 3 : surfaces (polygons) and multisurfaces (multipolygons).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.polygonfromedges-Tuple{ArchGDAL.AbstractGeometry,Real}","page":"API Reference","title":"ArchGDAL.polygonfromedges","text":"polygonfromedges(lines::AbstractGeometry, tol::Real; besteffort = false, autoclose = false)\n\nBuild a ring from a bunch of arcs.\n\nParameters\n\nlines: handle to an OGRGeometryCollection (or OGRMultiLineString)   containing the line string geometries to be built into rings.\ntol: whether two arcs are considered close enough to be joined.\n\nKeyword Arguments\n\nbesteffort: (defaults to false) not yet implemented???.\nautoclose: indicates if the ring should be close when first and last   points of the ring are the same. (defaults to false)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.polygonize-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.polygonize","text":"polygonize(geom::AbstractGeometry)\n\nPolygonizes a set of sparse edges.\n\nA new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't correspond to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.removeallgeoms!","page":"API Reference","title":"ArchGDAL.removeallgeoms!","text":"removeallgeoms!(geom::AbstractGeometry, todelete::Bool = true)\n\nRemove all geometries from an exiting geometry container.\n\nParameters\n\ngeom: the existing geometry to delete from.\ntodelete: if true the geometry will be destroyed, otherwise it will not.   The default is true as the existing geometry is considered to own the   geometries in it.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.removegeom!","page":"API Reference","title":"ArchGDAL.removegeom!","text":"removegeom!(geom::AbstractGeometry, i::Integer, todelete::Bool = true)\n\nRemove a geometry from an exiting geometry container.\n\nParameters\n\ngeom: the existing geometry to delete from.\ni: the index of the geometry to delete. A value of -1 is a special flag   meaning that all geometries should be removed.\ntodelete: if true the geometry will be destroyed, otherwise it will not.   The default is true as the existing geometry is considered to own the   geometries in it.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.segmentize!-Tuple{ArchGDAL.AbstractGeometry,Real}","page":"API Reference","title":"ArchGDAL.segmentize!","text":"segmentize!(geom::AbstractGeometry, maxlength::Real)\n\nModify the geometry such it has no segment longer than the given distance.\n\nInterpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only\n\nParameters\n\ngeom: the geometry to segmentize\nmaxlength: the maximum distance between 2 points after segmentization\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setcoorddim!-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.setcoorddim!","text":"setcoorddim!(geom::AbstractGeometry, dim::Integer)\n\nSet the coordinate dimension.\n\nThis method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setnonlineargeomflag!-Tuple{Bool}","page":"API Reference","title":"ArchGDAL.setnonlineargeomflag!","text":"setnonlineargeomflag!(flag::Bool)\n\nSet flag to enable/disable returning non-linear geometries in the C API.\n\nThis flag has only an effect on the OGRFGetGeometryRef(), OGRFGetGeomFieldRef(), OGRLGetGeomType(), OGRGFldGetType() and OGRFDGetGeomType() C API methods. It is meant as making it simple for applications using the OGR C API not to have to deal with non-linear geometries, even if such geometries might be returned by drivers. In which case, they will be transformed into their closest linear geometry, by doing linear approximation, with OGRGForceTo().\n\nLibraries should generally not use that method, since that could interfere with other libraries or applications.\n\nParameters\n\nflag: true if non-linear geometries might be returned (default value).         false to ask for non-linear geometries to be approximated as linear         geometries.\n\nReturns\n\na point or NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setpoint!","page":"API Reference","title":"ArchGDAL.setpoint!","text":"setpoint!(geom::AbstractGeometry, i::Integer, x, y)\nsetpoint!(geom::AbstractGeometry, i::Integer, x, y, z)\n\nSet the location of a vertex in a point or linestring geometry.\n\nParameters\n\ngeom: handle to the geometry to add a vertex to.\ni: the index of the vertex to assign (zero based) or zero for a point.\nx: input X coordinate to assign.\ny: input Y coordinate to assign.\nz: input Z coordinate to assign (defaults to zero).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.setpointcount!-Tuple{ArchGDAL.AbstractGeometry,Integer}","page":"API Reference","title":"ArchGDAL.setpointcount!","text":"setpointcount!(geom::AbstractGeometry, n::Integer)\n\nSet number of points in a geometry.\n\nParameters\n\ngeom: the geometry.\nn: the new number of points for geometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.simplify-Tuple{ArchGDAL.AbstractGeometry,Real}","page":"API Reference","title":"ArchGDAL.simplify","text":"simplify(geom::AbstractGeometry, tol::Real)\n\nCompute a simplified geometry.\n\nParameters\n\ngeom: the geometry.\ntol: the distance tolerance for the simplification.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.simplifypreservetopology-Tuple{ArchGDAL.AbstractGeometry,Real}","page":"API Reference","title":"ArchGDAL.simplifypreservetopology","text":"simplifypreservetopology(geom::AbstractGeometry, tol::Real)\n\nSimplify the geometry while preserving topology.\n\nParameters\n\ngeom: the geometry.\ntol: the distance tolerance for the simplification.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.symdifference-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.symdifference","text":"symdifference(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns a new geometry representing the symmetric difference of the geometries or NULL if the difference is empty or an error occurs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toGML-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.toGML","text":"toGML(geom::AbstractGeometry)\n\nConvert a geometry into GML format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toISOWKB","page":"API Reference","title":"ArchGDAL.toISOWKB","text":"toISOWKB(geom::AbstractGeometry, order::OGRwkbByteOrder = GDAL.wkbNDR)\n\nConvert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.\n\nParameters\n\ngeom: handle on the geometry to convert to a well know binary data from.\norder: One of wkbXDR or [wkbNDR] indicating MSB or LSB byte order resp.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.toISOWKT-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.toISOWKT","text":"toISOWKT(geom::AbstractGeometry)\n\nConvert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toJSON-Tuple{ArchGDAL.AbstractGeometry,Any}","page":"API Reference","title":"ArchGDAL.toJSON","text":"toJSON(geom::AbstractGeometry, options)\n\nConvert a geometry into GeoJSON format.\n\nParameters\n\ngeom: handle to the geometry.\noptions: a list of options.\n\nReturns\n\nA GeoJSON fragment or NULL in case of error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toJSON-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.toJSON","text":"toJSON(geom::AbstractGeometry)\n\nConvert a geometry into GeoJSON format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toKML","page":"API Reference","title":"ArchGDAL.toKML","text":"toKML(geom::AbstractGeometry, altitudemode = C_NULL)\n\nConvert a geometry into KML format.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.toWKB","page":"API Reference","title":"ArchGDAL.toWKB","text":"toWKB(geom::AbstractGeometry, order::OGRwkbByteOrder = GDAL.wkbNDR)\n\nConvert a geometry well known binary format.\n\nParameters\n\ngeom: handle on the geometry to convert to a well know binary data from.\norder: One of wkbXDR or [wkbNDR] indicating MSB or LSB byte order resp.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.toWKT-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.toWKT","text":"toWKT(geom::AbstractGeometry)\n\nConvert a geometry into well known text format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.touches-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.touches","text":"touches(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if the geometries are touching.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.transform!-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.CoordTransform}","page":"API Reference","title":"ArchGDAL.transform!","text":"transform!(geom::AbstractGeometry, coordtransform::CoordTransform)\n\nApply arbitrary coordinate transformation to geometry.\n\nParameters\n\ngeom: handle on the geometry to apply the transform to.\ncoordtransform: handle on the transformation to apply.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.union-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.union","text":"union(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns a new geometry representing the union of the geometries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.within-Tuple{ArchGDAL.AbstractGeometry,ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.within","text":"within(g1::AbstractGeometry, g2::AbstractGeometry)\n\nReturns true if g1 is contained within g2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.wkbsize-Tuple{ArchGDAL.AbstractGeometry}","page":"API Reference","title":"ArchGDAL.wkbsize","text":"wkbsize(geom::AbstractGeometry)\n\nReturns size (in bytes) of related binary representation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addpart!-Tuple{ArchGDAL.StyleManager,ArchGDAL.StyleTool}","page":"API Reference","title":"ArchGDAL.addpart!","text":"addpart!(stylemanager::StyleManager, styletool::StyleTool)\n\nAdd a part (style tool) to the current style.\n\nParameters\n\nstylemanager: handle to the style manager.\nstyletool: the style tool defining the part to add.\n\nReturns\n\ntrue on success, false on errors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addstyle!-Tuple{ArchGDAL.StyleManager,AbstractString,AbstractString}","page":"API Reference","title":"ArchGDAL.addstyle!","text":"addstyle!(stylemanager::StyleManager, stylename, stylestring)\n\nAdd a style to the current style table.\n\nParameters\n\nstylemanager: handle to the style manager.\nstylename: the name of the style to add.\nstylestring: (optional) the style string to use, or (if not provided) to use   the style stored in the manager.\n\nReturns\n\ntrue on success, false on errors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.addstyle!-Tuple{ArchGDAL.StyleTable,AbstractString,AbstractString}","page":"API Reference","title":"ArchGDAL.addstyle!","text":"addstyle!(styletable::StyleTable, stylename, stylestring)\n\nAdd a new style in the table.\n\nParameters\n\nstyletable: handle to the style table.\nname: the name the style to add.\nstylestring: the style string to add.\n\nReturns\n\ntrue on success, false on error\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asdouble","page":"API Reference","title":"ArchGDAL.asdouble","text":"asdouble(styletool::StyleTool, id::Integer, nullflag = Ref{Cint}(0))\n\nGet Style Tool parameter value as a double.\n\nParameters\n\nstyletool: handle to the style tool.\nid: the parameter id from the enumeration corresponding to the type of this       style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam       or OGRSTLabelParam enumerations)\nnullflag: pointer to an integer that will be set to true or false to       indicate whether the parameter value is NULL.\n\nReturns\n\nthe parameter value as a double and sets nullflag.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.asint","page":"API Reference","title":"ArchGDAL.asint","text":"asint(styletool::StyleTool, id::Integer, nullflag = Ref{Cint}(0))\n\nGet Style Tool parameter value as an integer.\n\nParameters\n\nstyletool: handle to the style tool.\nid: the parameter id from the enumeration corresponding to the type of this       style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam       or OGRSTLabelParam enumerations)\nnullflag: pointer to an integer that will be set to true or false to       indicate whether the parameter value is NULL.\n\nReturns\n\nthe parameter value as an integer and sets nullflag.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.asstring-Tuple{ArchGDAL.StyleTool,Integer,Ref{Int32}}","page":"API Reference","title":"ArchGDAL.asstring","text":"asstring(styletool::StyleTool, id::Integer)\nasstring(styletool::StyleTool, id::Integer, nullflag::Ref{Cint})\n\nGet Style Tool parameter value as a string.\n\nParameters\n\nstyletool: handle to the style tool.\nid: the parameter id from the enumeration corresponding to the type of this       style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam       or OGRSTLabelParam enumerations)\nnullflag: pointer to an integer that will be set to true or false to       indicate whether the parameter value is NULL.\n\nReturns\n\nthe parameter value as a string and sets nullflag.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.StyleManager}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy Style Manager.\n\nParameters\n\nstylemanager: handle to the style manager to destroy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.StyleTable}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy Style Table.\n\nParameters\n\nstyletable: handle to the style table to destroy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.StyleTool}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroy Style Tool.\n\nParameters\n\nstyletool: handle to the style tool to destroy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findstylestring-Tuple{ArchGDAL.StyleTable,AbstractString}","page":"API Reference","title":"ArchGDAL.findstylestring","text":"findstylestring(styletable::StyleTable, name::AbstractString)\n\nGet a style string by name.\n\nParameters\n\nstyletable: handle to the style table.\nname: the name of the style string to find.\n\nReturns\n\nthe style string matching the name or NULL if not found or error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getstylestring-Tuple{ArchGDAL.StyleTool}","page":"API Reference","title":"ArchGDAL.getstylestring","text":"getstylestring(styletool::StyleTool)\n\nGet the style string for this Style Tool.\n\nParameters\n\nstyletool: handle to the style tool.\n\nReturns\n\nthe style string for this style tool or \"\" if the styletool is invalid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.gettype-Tuple{ArchGDAL.StyleTool}","page":"API Reference","title":"ArchGDAL.gettype","text":"gettype(styletool::StyleTool)\n\nDetermine type of Style Tool.\n\nParameters\n\nstyletool: handle to the style tool.\n\nReturns\n\nthe style tool type, one of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4). Returns OGRSTCNone (0) if the OGRStyleToolH is invalid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getunit-Tuple{ArchGDAL.StyleTool}","page":"API Reference","title":"ArchGDAL.getunit","text":"getunit(styletool::StyleTool)\n\nGet Style Tool units.\n\nParameters\n\nstyletool: handle to the style tool.\n\nReturns\n\nthe style tool units.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.initialize!","page":"API Reference","title":"ArchGDAL.initialize!","text":"initialize!(stylemanager::StyleManager, stylestring = C_NULL)\n\nInitialize style manager from the style string.\n\nParameters\n\nstylemanager: handle to the style manager.\nstylestring: the style string to use (can be NULL).\n\nReturns\n\ntrue on success, false on errors.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.initialize!-Tuple{ArchGDAL.StyleManager,ArchGDAL.Feature}","page":"API Reference","title":"ArchGDAL.initialize!","text":"initialize!(stylemanager::StyleManager, feature::Feature)\n\nInitialize style manager from the style string of a feature.\n\nParameters\n\nstylemanager: handle to the style manager.\nfeature: handle to the new feature from which to read the style.\n\nReturns\n\nthe style string read from the feature, or NULL in case of error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.laststyle-Tuple{ArchGDAL.StyleTable}","page":"API Reference","title":"ArchGDAL.laststyle","text":"laststyle(styletable::StyleTable)\n\nGet the style name of the last style string fetched with OGRSTBLGetNextStyle.\n\nParameters\n\nstyletable: handle to the style table.\n\nReturns\n\nthe Name of the last style string or NULL on error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.loadstyletable!-Tuple{ArchGDAL.StyleTable,AbstractString}","page":"API Reference","title":"ArchGDAL.loadstyletable!","text":"loadstyletable!(styletable::StyleTable, filename::AbstractString)\n\nLoad a style table from a file.\n\nParameters\n\nstyletable: handle to the style table.\nfilename: the name of the file to load from.\n\nReturns\n\ntrue on success, false on error\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nextstyle-Tuple{ArchGDAL.StyleTable}","page":"API Reference","title":"ArchGDAL.nextstyle","text":"nextstyle(styletable::StyleTable)\n\nGet the next style string from the table.\n\nParameters\n\nstyletable: handle to the style table.\n\nReturns\n\nthe next style string or NULL on error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.npart","page":"API Reference","title":"ArchGDAL.npart","text":"npart(stylemanager::StyleManager)\nnpart(stylemanager::StyleManager, stylestring::AbstractString)\n\nGet the number of parts in a style.\n\nParameters\n\nstylemanager: handle to the style manager.\nstylestring: (optional) the style string on which to operate. If NULL then                the current style string stored in the style manager is used.\n\nReturns\n\nthe number of parts (style tools) in the style.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.resetreading!-Tuple{ArchGDAL.StyleTable}","page":"API Reference","title":"ArchGDAL.resetreading!","text":"resetreading!(styletable::StyleTable)\n\nReset the next style pointer to 0.\n\nParameters\n\nstyletable: handle to the style table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.savestyletable-Tuple{ArchGDAL.StyleTable,AbstractString}","page":"API Reference","title":"ArchGDAL.savestyletable","text":"savestyletable(styletable::StyleTable, filename::AbstractString)\n\nSave a style table to a file.\n\nParameters\n\nstyletable: handle to the style table.\nfilename: the name of the file to save to.\n\nReturns\n\ntrue on success, false on error\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setparam!","page":"API Reference","title":"ArchGDAL.setparam!","text":"setparam!(styletool::StyleTool, id::Integer, value)\n\nSet Style Tool parameter value.\n\nParameters\n\nstyletool: handle to the style tool.\nid: the parameter id from the enumeration corresponding to the type of this       style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam       or OGRSTLabelParam enumerations)\nvalue: the new parameter value, can be an Integer, Float64, or AbstactString\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.setunit!-Tuple{ArchGDAL.StyleTool,GDAL.ogr_style_tool_units_id,Real}","page":"API Reference","title":"ArchGDAL.setunit!","text":"setunit!(styletool::StyleTool, newunit::OGRSTUnitId, scale::Real)\n\nSet Style Tool units.\n\nParameters\n\nstyletool: handle to the style tool.\nnewunit: the new unit.\nscale: ground to paper scale factor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toRGBA-Tuple{ArchGDAL.StyleTool,AbstractString}","page":"API Reference","title":"ArchGDAL.toRGBA","text":"toRGBA(styletool::StyleTool, color::AbstractString)\n\nReturn the r,g,b,a components of a color encoded in #RRGGBB[AA] format.\n\nParameters\n\nstyletool: handle to the style tool.\npszColor: the color to parse\n\nReturns\n\n(R,G,B,A) tuple of Cints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createstylemanager","page":"API Reference","title":"ArchGDAL.unsafe_createstylemanager","text":"unsafe_createstylemanager(styletable = GDALStyleTable(C_NULL))\n\nOGRStyleMgr factory.\n\nParameters\n\nstyletable: OGRStyleTable or NULL if not working with a style table.\n\nReturns\n\nan handle to the new style manager object.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_createstyletable-Tuple{}","page":"API Reference","title":"ArchGDAL.unsafe_createstyletable","text":"unsafe_createstyletable()\n\nOGRStyleTable factory.\n\nReturns\n\nan handle to the new style table object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createstyletool-Tuple{GDAL.ogr_style_tool_class_id}","page":"API Reference","title":"ArchGDAL.unsafe_createstyletool","text":"unsafe_createstyletool(classid::OGRSTClassId)\n\nOGRStyleTool factory.\n\nParameters\n\nclassid: subclass of style tool to create. One of OGRSTCPen (1),            OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4).\n\nReturns\n\nan handle to the new style tool object or NULL if the creation failed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_getpart","page":"API Reference","title":"ArchGDAL.unsafe_getpart","text":"unsafe_getpart(stylemanager::StyleManager, id::Integer, stylestring = C_NULL)\n\nFetch a part (style tool) from the current style.\n\nParameters\n\nstylemanager: handle to the style manager.\nid: the part number (0-based index).\nstylestring: (optional) the style string on which to operate. If not   provided, then the current style string stored in the style manager is used.\n\nReturns\n\nOGRStyleToolH of the requested part (style tools) or NULL on error.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.addfielddefn!-Tuple{ArchGDAL.AbstractFeatureLayer,AbstractString,GDAL.OGRFieldType}","page":"API Reference","title":"ArchGDAL.addfielddefn!","text":"addfielddefn!(layer::AbstractFeatureLayer, name, etype::OGRFieldType; <keyword arguments>)\n\nCreate a new field on a layer.\n\nThis function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.\n\nNot all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.\n\nDrivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.\n\nParameters\n\nlayer:  the layer to write the field definition.\nname:   name of the field definition to write to disk.\netype:  type of the field definition to write to disk.\n\nKeyword arguments\n\nnwidth:     the preferred formatting width. 0 (default) indicates undefined.\nnprecision: number of decimals for formatting. 0 (default) for undefined.\njustify:    the formatting justification ([OJUndefined], OJLeft or OJRight)\napprox:     If true (default false), the field may be created in a               slightly different form depending on the limitations of the               format driver.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.writegeomdefn!-Tuple{ArchGDAL.AbstractFeatureLayer,AbstractString,GDAL.OGRwkbGeometryType}","page":"API Reference","title":"ArchGDAL.writegeomdefn!","text":"writegeomdefn!(layer::AbstractFeatureLayer, name, etype::OGRwkbGeometryType, approx=false)\n\nWrite a new geometry field on a layer.\n\nThis function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.\n\nNot all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.\n\nDrivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.\n\nParameters\n\nlayer:  the layer to write the field definition.\nname:   name of the field definition to write to disk.\netype:  type of the geometry field defintion to write to disk.\n\nKeyword arguments\n\napprox: If true (default false), the geometry field may be created in a           slightly different form depending on the limitations of the driver.\n\n\n\n\n\n","category":"method"},{"location":"reference/#API-Raster-Data-1","page":"API Reference","title":"Raster Data","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"array.jl\", \"colortable.jl\", \"rasterattributetable.jl\", \"rasterband.jl\", \"rasterio.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.createcolorramp!-Tuple{ArchGDAL.ColorTable,Integer,GDAL.GDALColorEntry,Integer,GDAL.GDALColorEntry}","page":"API Reference","title":"ArchGDAL.createcolorramp!","text":"createcolorramp!(ct::ColorTable, startindex, startcolor::GDAL.GDALColorEntry,\n    endindex, endcolor::GDAL.GDALColorEntry)\n\nCreate color ramp.\n\nAutomatically creates a color ramp from one color entry to another. It can be called several times to create multiples ramps in the same color table.\n\nParameters\n\nstartindex index to start the ramp on the color table [0..255]\nstartcolor a color entry value to start the ramp\nendindex   index to end the ramp on the color table [0..255]\nendcolor   a color entry value to end the ramp\n\nReturns\n\ntotal number of entries, -1 to report error\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroys a color table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getcolorentry-Tuple{ArchGDAL.ColorTable,Integer}","page":"API Reference","title":"ArchGDAL.getcolorentry","text":"getcolorentry(ct::ColorTable, i::Integer)\n\nFetch a color entry from table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getcolorentryasrgb-Tuple{ArchGDAL.ColorTable,Integer}","page":"API Reference","title":"ArchGDAL.getcolorentryasrgb","text":"getcolorentryasrgb(ct::ColorTable, i::Integer)\n\nFetch a table entry in RGB format.\n\nIn theory this method should support translation of color palettes in non-RGB color spaces into RGB on the fly, but currently it only works on RGB color tables.\n\nParameters\n\ni   entry offset from zero to GetColorEntryCount()-1.\n\nReturns\n\ntrue on success, or false if the conversion isn't supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ncolorentry-Tuple{ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.ncolorentry","text":"ncolorentry(ct::ColorTable)\n\nGet number of color entries in table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.paletteinterp-Tuple{ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.paletteinterp","text":"paletteinterp(ct::ColorTable)\n\nFetch palette interpretation.\n\nReturns\n\npalette interpretation enumeration value, usually GPI_RGB.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setcolorentry!-Tuple{ArchGDAL.ColorTable,Integer,GDAL.GDALColorEntry}","page":"API Reference","title":"ArchGDAL.setcolorentry!","text":"setcolorentry!(ct::ColorTable, i::Integer, entry::GDAL.GDALColorEntry)\n\nSet entry in color table.\n\nNote that the passed in color entry is copied, and no internal reference to it is maintained. Also, the passed in entry must match the color interpretation of the table to which it is being assigned.\n\nThe table is grown as needed to hold the supplied offset.\n\nParameters\n\ni     entry offset from 0 to ncolorentry()-1.\nentry value to assign to table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_clone-Tuple{ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.unsafe_clone","text":"unsafe_clone(ct::ColorTable)\n\nMake a copy of a color table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createcolortable-Tuple{GDAL.GDALPaletteInterp}","page":"API Reference","title":"ArchGDAL.unsafe_createcolortable","text":"unsafe_createcolortable(palette::GDALPaletteInterp)\n\nConstruct a new color table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asdouble-Tuple{ArchGDAL.RasterAttrTable,Integer,Integer}","page":"API Reference","title":"ArchGDAL.asdouble","text":"asdouble(rat::RasterAttrTable, row::Integer, col::Integer)\n\nFetch field value as a double.\n\nThe value of the requested column in the requested row is returned as a double. Non double fields will be converted to double with the possibility of data loss.\n\nParameters\n\nrow  row to fetch (zero based).\ncol  column to fetch (zero based).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asint-Tuple{ArchGDAL.RasterAttrTable,Integer,Integer}","page":"API Reference","title":"ArchGDAL.asint","text":"asint(rat::RasterAttrTable, row::Integer, col::Integer)\n\nFetch field value as a integer.\n\nThe value of the requested column in the requested row is returned as an int. Non-integer fields will be converted to int with the possibility of data loss.\n\nParameters\n\nrow  row to fetch (zero based).\ncol  column to fetch (zero based).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.asstring-Tuple{ArchGDAL.RasterAttrTable,Integer,Integer}","page":"API Reference","title":"ArchGDAL.asstring","text":"asstring(rat::RasterAttrTable, row::Integer, col::Integer)\n\nFetch field value as a string.\n\nThe value of the requested column in the requested row is returned as a string. If the field is numeric, it is formatted as a string using default rules, so some precision may be lost.\n\nParameters\n\nrow  row to fetch (zero based).\ncol  column to fetch (zero based).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.attributeio!","page":"API Reference","title":"ArchGDAL.attributeio!","text":"attributeio!(rat::RasterAttrTable, access::GDALRWFlag, col, startrow, nrows, data::Vector)\n\nRead or Write a block of data to/from the Attribute Table.\n\nParameters\n\naccess      Either GF_Read or GF_Write\ncol         Column of the Attribute Table\nstartrow    Row to start reading/writing (zero based)\nnrows       Number of rows to read or write\ndata        Vector of Float64, Int32 or AbstractString to read/write. Should be at least nrows long.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.changesarewrittentofile-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.changesarewrittentofile","text":"changesarewrittentofile(rat::RasterAttrTable)\n\nDetermine whether changes made to this RAT are reflected directly in the dataset\n\nIf this returns false then GDALRasterBand.SetDefaultRAT() should be called. Otherwise this is unnecessary since changes to this object are reflected in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.columnname-Tuple{ArchGDAL.RasterAttrTable,Integer}","page":"API Reference","title":"ArchGDAL.columnname","text":"columnname(rat::RasterAttrTable, i::Integer)\n\nFetch name of indicated column.\n\nParameters\n\ni  the column index (zero based).\n\nReturns\n\nthe column name or an empty string for invalid column numbers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.columntype-Tuple{ArchGDAL.RasterAttrTable,Integer}","page":"API Reference","title":"ArchGDAL.columntype","text":"columntype(rat::RasterAttrTable, i::Integer)\n\nFetch column type.\n\nParameters\n\ncol  the column index (zero based).\n\nReturns\n\ncolumn type or GFT_Integer if the column index is illegal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.columnusage-Tuple{ArchGDAL.RasterAttrTable,Integer}","page":"API Reference","title":"ArchGDAL.columnusage","text":"columnusage(rat::RasterAttrTable, i::Integer)\n\nFetch column usage value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.createcolumn!-Tuple{ArchGDAL.RasterAttrTable,AbstractString,GDAL.GDALRATFieldType,GDAL.GDALRATFieldUsage}","page":"API Reference","title":"ArchGDAL.createcolumn!","text":"createcolumn!(rat::RasterAttrTable, name, fieldtype::GDALRATFieldType, fieldusage::GDALRATFieldUsage)\n\nCreate new column.\n\nIf the table already has rows, all row values for the new column will be initialized to the default value (\"\", or zero). The new column is always created as the last column, can will be column (field) \"GetColumnCount()-1\" after CreateColumn() has completed successfully.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.destroy","text":"Destroys a RAT.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findcolumnindex-Tuple{ArchGDAL.RasterAttrTable,GDAL.GDALRATFieldUsage}","page":"API Reference","title":"ArchGDAL.findcolumnindex","text":"findcolumnindex(rat::RasterAttrTable, usage::GDALRATFieldUsage)\n\nReturns the index of the first column of the requested usage type, or -1 if no match is found.\n\nParameters\n\nusage  usage type to search for.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.findrowindex-Tuple{ArchGDAL.RasterAttrTable,Real}","page":"API Reference","title":"ArchGDAL.findrowindex","text":"findrowindex(rat::RasterAttrTable, pxvalue::Real)\n\nGet row for pixel value.\n\nGiven a raw pixel value, the raster attribute table is scanned to determine which row in the table applies to the pixel value. The row index is returned.\n\nParameters\n\npxvalue the pixel value.\n\nReturns\n\nThe row index or -1 if no row is appropriate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getlinearbinning-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.getlinearbinning","text":"getlinearbinning(rat::RasterAttrTable)\n\nGet linear binning information.\n\nReturns\n\nrow0min the lower bound (pixel value) of the first category.\nbinsize the width of each category (in pixel value units).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.initializeRAT!-Tuple{ArchGDAL.RasterAttrTable,ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.initializeRAT!","text":"initializeRAT!(rat::RasterAttrTable, colortable::ColorTable)\n\nInitialize from color table.\n\nThis method will setup a whole raster attribute table based on the contents of the passed color table. The Value (GFUMinMax), Red (GFURed), Green (GFUGreen), Blue (GFUBlue), and Alpha (GFU_Alpha) fields are created, and a row is set for each entry in the color table.\n\nThe raster attribute table must be empty before calling initializeRAT!().\n\nThe Value fields are set based on the implicit assumption with color tables that entry 0 applies to pixel value 0, 1 to 1, etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ncolumn-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.ncolumn","text":"ncolumn(rat::RasterAttrTable)\n\nFetch table column count.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.nrow-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.nrow","text":"nrow(rat::RasterAttrTable)\n\nFetch row count.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.serializeJSON-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.serializeJSON","text":"serializeJSON(rat::RasterAttrTable)\n\nSerialize Raster Attribute Table in Json format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setlinearbinning!-Tuple{ArchGDAL.RasterAttrTable,Real,Real}","page":"API Reference","title":"ArchGDAL.setlinearbinning!","text":"setlinearbinning!(rat::RasterAttrTable, row0min::Real, binsize::Real)\n\nSet linear binning information.\n\nFor RATs with equal sized categories (in pixel value space) that are evenly spaced, this method may be used to associate the linear binning information with the table.\n\nParameters\n\nrow0min the lower bound (pixel value) of the first category.\nbinsize the width of each category (in pixel value units).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setrowcount!-Tuple{ArchGDAL.RasterAttrTable,Integer}","page":"API Reference","title":"ArchGDAL.setrowcount!","text":"setrowcount!(rat::RasterAttrTable, n::Integer)\n\nSet row count.\n\nResizes the table to include the indicated number of rows. Newly created rows will be initialized to their default values - \"\" for strings, and zero for numeric fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setvalue!","page":"API Reference","title":"ArchGDAL.setvalue!","text":"setvalue!(rat::RasterAttrTable, row, col, val)\n\nSet field value from string.\n\nThe indicated field (column) on the indicated row is set from the passed value. The value will be automatically converted for other field types, with a possible loss of precision.\n\nParameters\n\nrow  row to fetch (zero based).\ncol  column to fetch (zero based).\nval  the value to assign, can be an AbstractString, Integer or Float64.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.toColorTable","page":"API Reference","title":"ArchGDAL.toColorTable","text":"toColorTable(rat::RasterAttrTable, n::Integer = -1)\n\nTranslate to a color table.\n\nParameters\n\nn The number of entries to produce (0 to n-1), or -1 to auto-determine   the number of entries.\n\nReturns\n\nthe generated color table or NULL on failure.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_clone-Tuple{ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.unsafe_clone","text":"unsafe_clone(rat::RasterAttrTable)\n\nCopy Raster Attribute Table.\n\nCreates a new copy of an existing raster attribute table. The new copy becomes the responsibility of the caller to destroy. May fail (return NULL) if the attribute table is too large to clone:     (nrow() * ncolumn() > RAT_MAX_ELEM_FOR_CLONE)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createRAT-Tuple{ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.unsafe_createRAT","text":"unsafe_createRAT(ct::ColorTable)\n\nConstruct table from an existing colortable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createRAT-Tuple{}","page":"API Reference","title":"ArchGDAL.unsafe_createRAT","text":"unsafe_createRAT()\n\nConstruct empty table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.accessflag-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.accessflag","text":"accessflag(band::AbstractRasterBand)\n\nReturn the access flag (e.g. OF_ReadOnly or OF_Update) for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.blocksize-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.blocksize","text":"blocksize(band::AbstractRasterBand)\n\nFetch the \"natural\" block size of this band.\n\nGDAL contains a concept of the natural block size of rasters so that applications can organized data access efficiently for some file formats. The natural block size is the block size that is most efficient for accessing the format. For many formats this is simple a whole scanline in which case *pnXSize is set to GetXSize(), and *pnYSize is set to 1.\n\nHowever, for tiled images this will typically be the tile size.\n\nNote that the X and Y block sizes don't have to divide the image size evenly, meaning that right and bottom edge blocks may be incomplete. See ReadBlock() for an example of code dealing with these issues.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.copywholeraster!-Tuple{ArchGDAL.AbstractRasterBand,ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.copywholeraster!","text":"copywholeraster!( source::AbstractRasterBand, dest::AbstractRasterBand;\n    [options, [progressdata, [progressfunc]]])\n\nCopy all raster band raster data.\n\nThis function copies the complete raster contents of one band to another similarly configured band. The source and destination bands must have the same width and height. The bands do not have to have the same data type.\n\nIt implements efficient copying, in particular \"chunking\" the copy in substantial blocks.\n\nCurrently the only options value supported is : \"COMPRESSED=YES\" to force alignment on target dataset block sizes to achieve best compression. More options may be supported in the future.\n\nParameters\n\nsource        the source band\ndest          the destination band\noptions       transfer hints in \"StringList\" Name=Value format.\nprogressfunc  progress reporting function.\nprogressdata  callback data for progress function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.createmaskband!-Tuple{ArchGDAL.AbstractRasterBand,Integer}","page":"API Reference","title":"ArchGDAL.createmaskband!","text":"createmaskband!(band::AbstractRasterBand, nflags::Integer)\n\nAdds a mask band to the current band.\n\nThe default implementation of the CreateMaskBand() method is implemented based on similar rules to the .ovr handling implemented using the GDALDefaultOverviews object. A TIFF file with the extension .msk will be created with the same basename as the original file, and it will have as many bands as the original image (or just one for GMF_PER_DATASET). The mask images will be deflate compressed tiled images with the same block size as the original image if possible.\n\nIf you got a mask band with a previous call to GetMaskBand(), it might be invalidated by CreateMaskBand(). So you have to call GetMaskBand() again.\n\nSee also: http://trac.osgeo.org/gdal/wiki/rfc15_nodatabitmask\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.fillraster!","page":"API Reference","title":"ArchGDAL.fillraster!","text":"fillraster!(band::AbstractRasterBand, realvalue::Real, imagvalue::Real = 0)\n\nFill this band with a constant value.\n\nGDAL makes no guarantees about what values pixels in newly created files are set to, so this method can be used to clear a band to a specified \"default\" value. The fill value is passed in as a double but this will be converted to the underlying type before writing to the file. An optional second argument allows the imaginary component of a complex constant value to be specified.\n\nParameters\n\nrealvalue: Real component of fill value\nimagvalue: Imaginary component of fill value, defaults to zero\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.getcategorynames-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getcategorynames","text":"getcategorynames(band::AbstractRasterBand)\n\nFetch the list of category names for this raster.\n\nThe return list is a \"StringList\" in the sense of the CPL functions. That is a NULL terminated array of strings. Raster values without associated names will have an empty string in the returned list. The first entry in the list is for raster values of zero, and so on.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getcolorinterp-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getcolorinterp","text":"getcolorinterp(band::AbstractRasterBand)\n\nColor Interpretation value for band\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getdataset-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getdataset","text":"getdataset(band::AbstractRasterBand)\n\nFetch the handle to its dataset handle, or NULL if this cannot be determined.\n\nNote that some RasterBands are not considered to be a part of a dataset, such as overviews or other \"freestanding\" bands.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getdefaultRAT-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getdefaultRAT","text":"getdefaultRAT(band::AbstractRasterBand)\n\nFetch default Raster Attribute Table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getmaskband-Tuple{ArchGDAL.IRasterBand}","page":"API Reference","title":"ArchGDAL.getmaskband","text":"getmaskband(band::IRasterBand)\n\nReturn the mask band associated with the band.\n\nThe GDALRasterBand class includes a default implementation of GetMaskBand() that returns one of four default implementations:\n\nIf a corresponding .msk file exists it will be used for the mask band.\nIf the dataset has a NODATA_VALUES metadata item, an instance of the new\n\nGDALNoDataValuesMaskBand class will be returned. GetMaskFlags() will return GMF_NODATA | GMF_PER_DATASET.\n\nIf the band has a nodata value set, an instance of the new\n\nGDALNodataMaskRasterBand class will be returned. GetMaskFlags() will return GMF_NODATA.\n\nIf there is no nodata value, but the dataset has an alpha band that seems to\n\napply to this band (specific rules yet to be determined) and that is of type GDT_Byte then that alpha band will be returned, and the flags GMF_PER_DATASET and GMF_ALPHA will be returned in the flags.\n\nIf neither of the above apply, an instance of the new\n\nGDALAllValidRasterBand class will be returned that has 255 values for all pixels. The null flags will return GMF_ALL_VALID.\n\nNote that the GetMaskBand() should always return a GDALRasterBand mask, even if it is only an all 255 mask with the flags indicating GMF_ALL_VALID.\n\nSee also: http://trac.osgeo.org/gdal/wiki/rfc15_nodatabitmask\n\nReturns\n\na valid mask band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getnodatavalue-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getnodatavalue","text":"getnodatavalue(band::AbstractRasterBand)\n\nFetch the no data value for this band.\n\nIf there is no out of data value, an out of range value will generally be returned. The no data value for a band is generally a special marker value used to mark pixels that are not valid data. Such pixels should generally not be displayed, nor contribute to analysis operations.\n\nReturns\n\nthe nodata value for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getoffset-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getoffset","text":"getoffset(band::AbstractRasterBand)\n\nFetch the raster value offset.\n\nThis (in combination with GetScale()) is used to transform raw pixel values into the units returned by GetUnits(). For e.g. this might be used to store elevations in GUInt16 bands with a precision of 0.1, starting from -100.\n\nUnits value = (raw value * scale) + offset\n\nFor file formats that don't know this intrinsically, a value of 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getoverview-Tuple{ArchGDAL.IRasterBand,Integer}","page":"API Reference","title":"ArchGDAL.getoverview","text":"getoverview(band::IRasterBand, i::Integer)\n\nFetch overview raster band object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getscale-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getscale","text":"getscale(band::AbstractRasterBand)\n\nFetch the raster value scale.\n\nThis value (in combination with the GetOffset() value) is used to transform raw pixel values into the units returned by GetUnits(). For example this might be used to store elevations in GUInt16 bands with a precision of 0.1, and starting from -100.\n\nUnits value = (raw value * scale) + offset\n\nFor file formats that don't know this intrinsically a value of one is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getunittype-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.getunittype","text":"getunittype(band::AbstractRasterBand)\n\nReturn a name for the units of this raster's values. For instance, it might be \"m\" for an elevation model in meters, or \"ft\" for feet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.height-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.height","text":"height(band::AbstractRasterBand)\n\nFetch the height in pixels of this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.indexof-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.indexof","text":"indexof(band::AbstractRasterBand)\n\nFetch the band number (1+) within its dataset, or 0 if unknown.\n\nThis method may return a value of 0 to indicate overviews, or free-standing GDALRasterBand objects without a relationship to a dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.maskflags-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.maskflags","text":"maskflags(band::AbstractRasterBand)\n\nReturn the status flags of the mask band associated with the band.\n\nThe GetMaskFlags() method returns an bitwise OR-ed set of status flags with the following available definitions that may be extended in the future:\n\nGMF_ALL_VALID (0x01):    There are no invalid pixels, all mask values\n\nwill be 255. When used this will normally be the only flag set.\n\nGMF_PER_DATASET (0x02):  The mask band is shared between all bands on\n\nthe dataset.\n\nGMF_ALPHA (0x04):        The mask band is actually an alpha band and may\n\nhave values other than 0 and 255.\n\nGMF_NODATA (0x08):       Indicates the mask is actually being generated\n\nfrom nodata values. (mutually exclusive of GMF_ALPHA)\n\nThe GDALRasterBand class includes a default implementation of GetMaskBand() that returns one of four default implementations:\n\nIf a corresponding .msk file exists it will be used for the mask band.\nIf the dataset has a NODATA_VALUES metadata item, an instance of the new\n\nGDALNoDataValuesMaskBand class will be returned. GetMaskFlags() will return GMF_NODATA | GMF_PER_DATASET.\n\nIf the band has a nodata value set, an instance of the new\n\nGDALNodataMaskRasterBand class will be returned. GetMaskFlags() will return GMF_NODATA.\n\nIf there is no nodata value, but the dataset has an alpha band that seems to\n\napply to this band (specific rules yet to be determined) and that is of type GDT_Byte then that alpha band will be returned, and the flags GMF_PER_DATASET and GMF_ALPHA will be returned in the flags.\n\nIf neither of the above apply, an instance of the new GDALAllValidRasterBand\n\nclass will be returned that has 255 values for all pixels. The null flags will return GMF_ALL_VALID.\n\nSee also: http://trac.osgeo.org/gdal/wiki/rfc15_nodatabitmask\n\nReturns\n\na valid mask band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.maximum-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.maximum","text":"maximum(band::AbstractRasterBand)\n\nFetch the maximum value for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.minimum-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.minimum","text":"minimum(band::AbstractRasterBand)\n\nFetch the minimum value for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.noverview-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.noverview","text":"noverview(band::AbstractRasterBand)\n\nReturn the number of overview layers available, zero if none.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.pixeltype-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.pixeltype","text":"pixeltype(band::AbstractRasterBand)\n\nFetch the pixel data type for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.regenerateoverviews!","page":"API Reference","title":"ArchGDAL.regenerateoverviews!","text":"regenerateoverviews!(band::AbstractRasterBand, overviewbands::Vector{<:AbstractRasterBand},\n    resampling = \"NEAREST\")\n\nGenerate downsampled overviews.\n\nThis function will generate one or more overview images from a base image using the requested downsampling algorithm. Its primary use is for generating overviews via BuildOverviews(), but it can also be used to generate downsampled images in one file from another outside the overview architecture.\n\nParameters\n\nband              the source (base level) band.\noverviewbands   the list of downsampled bands to be generated.\n\nKeyword Arguments\n\nresampling      (optional) Resampling algorithm (eg. \"AVERAGE\"). default to                   \"NEAREST\".\nprogressfunc    (optional) progress report function.\nprogressdata    (optional) progress function callback data.\n\nAdditional Remarks\n\nThe output bands need to exist in advance.\n\nThis function will honour properly NODATA_VALUES tuples (special dataset metadata) so that only a given RGB triplet (in case of a RGB image) will be considered as the nodata value and not each value of the triplet independantly per band.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.sampleoverview-Tuple{ArchGDAL.IRasterBand,Integer}","page":"API Reference","title":"ArchGDAL.sampleoverview","text":"sampleoverview(band::IRasterBand, nsamples::Integer)\n\nFetch best overview satisfying nsamples number of samples.\n\nReturns the most reduced overview of the given band that still satisfies the desired number of samples nsamples. This function can be used with zero as the number of desired samples to fetch the most reduced overview. The same band as was passed in will be returned if it has not overviews, or if none of the overviews have enough samples.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setcategorynames!-Tuple{ArchGDAL.AbstractRasterBand,Any}","page":"API Reference","title":"ArchGDAL.setcategorynames!","text":"setcategorynames!(band::AbstractRasterBand, names)\n\nSet the category names for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setcategorynames!-Tuple{ArchGDAL.AbstractRasterBand,Array{String,1}}","page":"API Reference","title":"ArchGDAL.setcategorynames!","text":"setcategorynames!(band::AbstractRasterBand, names::Vector{String})\n\nSet the category names for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setcolorinterp!-Tuple{ArchGDAL.AbstractRasterBand,GDAL.GDALColorInterp}","page":"API Reference","title":"ArchGDAL.setcolorinterp!","text":"setcolorinterp!(band::AbstractRasterBand, color::GDALColorInterp)\n\nSet color interpretation of a band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setcolortable!-Tuple{ArchGDAL.AbstractRasterBand,ArchGDAL.ColorTable}","page":"API Reference","title":"ArchGDAL.setcolortable!","text":"setcolortable!(band::AbstractRasterBand, colortable::ColorTable)\n\nSet the raster color table.\n\nThe driver will make a copy of all desired data in the colortable. It remains owned by the caller after the call.\n\nParameters\n\ncolortable color table to apply (where supported).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setdefaultRAT!-Tuple{ArchGDAL.AbstractRasterBand,ArchGDAL.RasterAttrTable}","page":"API Reference","title":"ArchGDAL.setdefaultRAT!","text":"setdefaultRAT!(band::AbstractRasterBand, rat::RasterAttrTable)\n\nSet default Raster Attribute Table.\n\nAssociates a default RAT with the band. If not implemented for the format a CPLE_NotSupported error will be issued. If successful a copy of the RAT is made, the original remains owned by the caller.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setnodatavalue!-Tuple{ArchGDAL.AbstractRasterBand,Real}","page":"API Reference","title":"ArchGDAL.setnodatavalue!","text":"setnodatavalue!(band::AbstractRasterBand, value::Real)\n\nSet the no data value for this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setoffset!-Tuple{ArchGDAL.AbstractRasterBand,Real}","page":"API Reference","title":"ArchGDAL.setoffset!","text":"setoffset!(band::AbstractRasterBand, value::Real)\n\nSet scaling offset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setscale!-Tuple{ArchGDAL.AbstractRasterBand,Real}","page":"API Reference","title":"ArchGDAL.setscale!","text":"setscale!(band::AbstractRasterBand, ratio::Real)\n\nSet scaling ratio.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.setunittype!-Tuple{ArchGDAL.AbstractRasterBand,AbstractString}","page":"API Reference","title":"ArchGDAL.setunittype!","text":"setunittype!(band::AbstractRasterBand, unitstring::AbstractString)\n\nSet unit type of band to unittype.\n\nValues should be one of \"\" (the default indicating it is unknown), \"m\" indicating meters, or \"ft\" indicating feet, though other nonstandard values are allowed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_getcolortable-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.unsafe_getcolortable","text":"unsafe_getcolortable(band::AbstractRasterBand)\n\nReturns a clone of the color table associated with the band.\n\n(If there is no associated color table, the original result is NULL. The original color table remains owned by the GDALRasterBand, and can't be depended on for long, nor should it ever be modified by the caller.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.width-Tuple{ArchGDAL.AbstractRasterBand}","page":"API Reference","title":"ArchGDAL.width","text":"width(band::AbstractRasterBand)\n\nFetch the width in pixels of this band.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.rasterio!","page":"API Reference","title":"ArchGDAL.rasterio!","text":"rasterio!(dataset::AbstractDataset, buffer::Array{<:Real, 3}, bands::Vector{Cint}; <keyword arguments>)\nrasterio!(dataset::AbstractDataset, buffer::Array{<:Real, 3}, bands::Vector{Cint}, rows, cols; <keyword arguments>)\nrasterio!(rasterband::AbstractRasterBand, buffer::Matrix{<:Real}; <keyword arguments>)\nrasterio!(rasterband::AbstractRasterBand, buffer::Matrix{<:Real}, rows, cols; <keyword arguments>)\n\nRead/write a region of image data from multiple bands.\n\nThis method allows reading a region of one or more RasterBands from this dataset into a buffer, or writing data from a buffer into a region of the RasterBands. It automatically takes care of data type translation if the element type (<:Real) of the buffer is different than that of the GDALRasterBand. The method also takes care of image decimation / replication if the buffer size (xsz × ysz) is different than the size of the region being accessed (xsize × ysize).\n\nThe pxspace, linespace and bandspace parameters allow reading into or writing from various organization of buffers.\n\nFor highest performance full resolution data access, read and write on \"block boundaries\" as returned by blocksize(), or use the readblock!() and writeblock!() methods.\n\nParameters\n\nrows        A continuous range of rows expressed as a UnitRange{<:Integer},               such as 2:9.\ncols        A continuous range of columns expressed as a UnitRange{<:Integer},               such as 2:9.\naccess      Either GDAL.GF_Read to read a region of data, or               GDAL.GF_Write to write a region of data.\nxoffset     The pixel offset to the top left corner of the region to be               accessed. It will be 0 (default) to start from the left.\nyoffset     The line offset to the top left corner of the region to be               accessed. It will be 0 (default) to start from the top.\nxsize       The width of the region of the band to be accessed in pixels.\nysize       The height of the region of the band to be accessed in lines.\nbuffer      The buffer into which the data should be read, or from which it               should be written. It must contain ≥ xsz * ysz * <# of bands>               words of type eltype(buffer). It is organized in left to               right, top to bottom pixel order. Spacing is controlled by the               pxspace, and linespace parameters\nxsz         The width of the buffer into which the desired region is               to be read, or from which it is to be written.\nysz         The height of the buffer into which the desired region is               to be read, or from which it is to be written.\nbands       The list of bands (1-based) to be read/written.\npxspace     The byte offset from the start of a pixel value in the buffer               to the start of the next pixel value within a scanline. By               default (i.e., 0) the size of eltype(buffer) will be used.\nlinespace   The byte offset from the start of one scanline in pBuffer to               the start of the next. By default (i.e., 0) the value of               sizeof(eltype(buffer)) * xsz will be used.\nbandspace   The byte offset from the start of one bands data to the start               of the next. By default (0), it will be linespace * ysz               implying band sequential organization of the buffer.\n\nReturns\n\nCE_Failure if the access fails, otherwise CE_None.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.readblock!-Tuple{ArchGDAL.AbstractRasterBand,Integer,Integer,Any}","page":"API Reference","title":"ArchGDAL.readblock!","text":"readblock!(rb::AbstractRasterBand, xoffset::Integer, yoffset::Integer, buffer)\n\nRead a block of image data efficiently.\n\nThis method accesses a \"natural\" block from the raster band without resampling, or data type conversion. For a more generalized, but potentially less efficient access use RasterIO().\n\nParameters\n\nxoffset the horizontal block offset, with zero indicating the left most           block, 1 the next block and so forth.\nyoffset the vertical block offset, with zero indicating the top most block,           1 the next block and so forth.\nbuffer  the buffer into which the data will be read. The buffer must be           large enough to hold GetBlockXSize()*GetBlockYSize() words of type           GetRasterDataType().\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.writeblock!-Tuple{ArchGDAL.AbstractRasterBand,Integer,Integer,Any}","page":"API Reference","title":"ArchGDAL.writeblock!","text":"writeblock!(rb::AbstractRasterBand, xoffset::Integer, yoffset::Integer, buffer)\n\nWrite a block of image data efficiently.\n\nThis method accesses a \"natural\" block from the raster band without resampling, or data type conversion. For a more generalized, but potentially less efficient access use RasterIO().\n\nParameters\n\nxoffset the horizontal block offset, with zero indicating the left most           block, 1 the next block and so forth.\nyoffset the vertical block offset, with zero indicating the left most block,           1 the next block and so forth.\nbuffer  the buffer from which the data will be written. The buffer must be           large enough to hold GetBlockXSize()*GetBlockYSize() words of type           GetRasterDataType().\n\n\n\n\n\n","category":"method"},{"location":"reference/#API-Spatial-projections-1","page":"API Reference","title":"Spatial projections","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"spatialref.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.clone-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.clone","text":"clone(spref::AbstractSpatialRef)\n\nMakes a clone of the Spatial Reference System. May return NULL.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.CoordTransform}","page":"API Reference","title":"ArchGDAL.destroy","text":"OGRCoordinateTransformation destructor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getattrvalue-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString,Integer}","page":"API Reference","title":"ArchGDAL.getattrvalue","text":"getattrvalue(spref::AbstractSpatialRef, name::AbstractString, i::Integer)\n\nFetch indicated attribute of named node.\n\nThis method uses GetAttrNode() to find the named node, and then extracts the value of the indicated child. Thus a call to getattrvalue(spref,\"UNIT\",1) would return the second child of the UNIT node, which is normally the length of the linear unit in meters.\n\nParameters name the tree node to look for (case insensitive). i    the child of the node to fetch (zero based).\n\nReturns the requested value, or NULL if it fails for any reason.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importEPSG!-Tuple{ArchGDAL.AbstractSpatialRef,Integer}","page":"API Reference","title":"ArchGDAL.importEPSG!","text":"importEPSG!(spref::AbstractSpatialRef, code::Integer)\n\nInitialize SRS based on EPSG GCS or PCS code.\n\nThis method will initialize the spatial reference based on the passed in EPSG GCS or PCS code. It is relatively expensive, and generally involves quite a bit of text file scanning. Reasonable efforts should be made to avoid calling it many times for the same coordinate system.\n\nAdditional Remarks\n\nThis method is similar to importFromEPSGA() except that EPSG preferred axis ordering will not be applied for geographic coordinate systems. EPSG normally defines geographic coordinate systems to use lat/long contrary to typical GIS use). Since OGR 1.10.0, EPSG preferred axis ordering will also not be applied for projected coordinate systems that use northing/easting order.\n\nThe coordinate system definitions are normally read from the EPSG derived support files such as pcs.csv, gcs.csv, pcs.override.csv, gcs.override.csv and falling back to search for a PROJ.4 epsg init file or a definition in epsg.wkt.\n\nThese support files are normally searched for in /usr/local/share/gdal or in the directory identified by the GDAL_DATA configuration option. See CPLFindFile() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importEPSG-Tuple{Integer}","page":"API Reference","title":"ArchGDAL.importEPSG","text":"importEPSG(code::Integer)\n\nConstruct a Spatial Reference System from its EPSG GCS or PCS code.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importEPSGA!-Tuple{ArchGDAL.AbstractSpatialRef,Integer}","page":"API Reference","title":"ArchGDAL.importEPSGA!","text":"importEPSGA!(spref::AbstractSpatialRef, code::Integer)\n\nInitialize SRS based on EPSG CRS code.\n\nThis method is similar to importFromEPSG() except that EPSG preferred axis ordering will be applied for geographic and projected coordinate systems. EPSG normally defines geographic coordinate systems to use lat/long, and also there are also a few projected coordinate systems that use northing/easting order contrary to typical GIS use). See importFromEPSG() for more details on operation of this method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importEPSGA-Tuple{Integer}","page":"API Reference","title":"ArchGDAL.importEPSGA","text":"importEPSGA(code::Integer)\n\nConstruct a Spatial Reference System from its EPSG CRS code.\n\nThis method is similar to importFromEPSG() except that EPSG preferred axis ordering will be applied for geographic and projected coordinate systems. EPSG normally defines geographic coordinate systems to use lat/long, and also there are also a few projected coordinate systems that use northing/easting order contrary to typical GIS use). See importFromEPSG() for more details on operation of this method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importESRI!-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString}","page":"API Reference","title":"ArchGDAL.importESRI!","text":"importESRI!(spref::AbstractSpatialRef, esristr::AbstractString)\n\nImport coordinate system from ESRI .prj format(s).\n\nThis function will read the text loaded from an ESRI .prj file, and translate it into an OGRSpatialReference definition. This should support many (but by no means all) old style (Arc/Info 7.x) .prj files, as well as the newer pseudo-OGC WKT .prj files. Note that new style .prj files are in OGC WKT format, but require some manipulation to correct datum names, and units on some projection parameters. This is addressed within importFromESRI() by an automatic call to morphFromESRI().\n\nCurrently only GEOGRAPHIC, UTM, STATEPLANE, GREATBRITIAN_GRID, ALBERS, EQUIDISTANT_CONIC, TRANSVERSE (mercator), POLAR, MERCATOR and POLYCONIC projections are supported from old style files.\n\nAt this time there is no equivalent exportToESRI() method. Writing old style .prj files is not supported by OGRSpatialReference. However the morphToESRI() and exportToWkt() methods can be used to generate output suitable to write to new style (Arc 8) .prj files.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importESRI-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.importESRI","text":"importESRI(esristr::AbstractString)\n\nCreate SRS from its ESRI .prj format(s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importPROJ4!-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString}","page":"API Reference","title":"ArchGDAL.importPROJ4!","text":"importPROJ4!(spref::AbstractSpatialRef, projstr::AbstractString)\n\nImport PROJ.4 coordinate string.\n\nThe OGRSpatialReference is initialized from the passed PROJ.4 style coordinate system string. In addition to many +proj formulations which have OGC equivalents, it is also possible to import \"+init=epsg:n\" style definitions. These are passed to importFromEPSG(). Other init strings (such as the state plane zones) are not currently supported.\n\nExample: pszProj4 = \"+proj=utm +zone=11 +datum=WGS84\"\n\nSome parameters, such as grids, recognized by PROJ.4 may not be well understood and translated into the OGRSpatialReference model. It is possible to add the +wktext parameter which is a special keyword that OGR recognized as meaning \"embed the entire PROJ.4 string in the WKT and use it literally when converting back to PROJ.4 format\".\n\nFor example: \"+proj=nzmg +lat_0=-41 +lon_0=173 +x_0=2510000 +y_0=6023150 +ellps=intl +units=m +nadgrids=nzgd2kgrid0005.gsb +wktext\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importPROJ4-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.importPROJ4","text":"importPROJ4(projstr::AbstractString)\n\nCreate SRS from its PROJ.4 string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importURL!-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString}","page":"API Reference","title":"ArchGDAL.importURL!","text":"importURL!(spref::AbstractSpatialRef, url::AbstractString)\n\nSet spatial reference from a URL.\n\nThis method will download the spatial reference at a given URL and feed it into SetFromUserInput for you.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importURL-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.importURL","text":"importURL(url::AbstractString)\n\nConstruct SRS from a URL.\n\nThis method will download the spatial reference at a given URL and feed it into SetFromUserInput for you.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importWKT!-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString}","page":"API Reference","title":"ArchGDAL.importWKT!","text":"importWKT!(spref::AbstractSpatialRef, wktstr::AbstractString)\n\nImport from WKT string.\n\nThis method will wipe the existing SRS definition, and reassign it based on the contents of the passed WKT string. Only as much of the input string as needed to construct this SRS is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importWKT-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.importWKT","text":"importWKT(wktstr::AbstractString)\n\nCreate SRS from its WKT string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importXML!-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString}","page":"API Reference","title":"ArchGDAL.importXML!","text":"importXML!(spref::AbstractSpatialRef, xmlstr::AbstractString)\n\nImport SRS from XML format (GML only currently).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.importXML-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.importXML","text":"importXML(xmlstr::AbstractString)\n\nConstruct SRS from XML format (GML only currently).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.morphfromESRI!-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.morphfromESRI!","text":"morphfromESRI!(spref::AbstractSpatialRef)\n\nConvert in place from ESRI WKT format.\n\nThe value notes of this coordinate system are modified in various manners to adhere more closely to the WKT standard. This mostly involves translating a variety of ESRI names for projections, arguments and datums to \"standard\" names, as defined by Adam Gawne-Cain's reference translation of EPSG to WKT for the CT specification.\n\nMissing parameters in TOWGS84, DATUM or GEOGCS nodes can be added to the WKT, comparing existing WKT parameters to GDAL's databases. Note that this optional procedure is very conservative and should not introduce false information into the WKT definition (although caution should be advised when activating it). Needs the Configuration Option GDAL_FIX_ESRI_WKT be set to one of the following (TOWGS84 recommended for proper datum shift calculations)\n\nGDAL_FIX_ESRI_WKT values:\n\nTOWGS84 Adds missing TOWGS84 parameters (necessary for datum       transformations), based on named datum and spheroid values.\nDATUM   Adds EPSG AUTHORITY nodes and sets SPHEROID name to OGR spec.\nGEOGCS  Adds EPSG AUTHORITY nodes and sets GEOGCS, DATUM and SPHEROID       names to OGR spec. Effectively replaces GEOGCS node with the result of       importFromEPSG(n), using EPSG code n corresponding to the existing       GEOGCS. Does not impact PROJCS values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.morphtoESRI!-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.morphtoESRI!","text":"morphtoESRI!(spref::AbstractSpatialRef)\n\nConvert in place to ESRI WKT format.\n\nThe value nodes of this coordinate system are modified in various manners more closely map onto the ESRI concept of WKT format. This includes renaming a variety of projections and arguments, and stripping out nodes note recognised by ESRI (like AUTHORITY and AXIS).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.newspatialref","page":"API Reference","title":"ArchGDAL.newspatialref","text":"newspatialref(wkt::AbstractString = \"\")\n\nConstruct a Spatial Reference System from its WKT.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.setattrvalue!-Tuple{ArchGDAL.AbstractSpatialRef,AbstractString,AbstractString}","page":"API Reference","title":"ArchGDAL.setattrvalue!","text":"setattrvalue!(spref::AbstractSpatialRef, path::AbstractString, value::AbstractString)\n\nSet attribute value in spatial reference.\n\nMissing intermediate nodes in the path will be created if not already in existence. If the attribute has no children one will be created and assigned the value otherwise the zeroth child will be assigned the value.\n\nParameters\n\npath: full path to attribute to be set. For instance \"PROJCS|GEOGCS|UNIT\".\nvalue: (optional) to be assigned to node, such as \"meter\". This may be left           out if you just want to force creation of the intermediate path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toMICoordSys-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.toMICoordSys","text":"toMICoordSys(spref::AbstractSpatialRef)\n\nExport coordinate system in Mapinfo style CoordSys format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toPROJ4-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.toPROJ4","text":"toPROJ4(spref::AbstractSpatialRef)\n\nExport coordinate system in PROJ.4 format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toWKT-Tuple{ArchGDAL.AbstractSpatialRef,Bool}","page":"API Reference","title":"ArchGDAL.toWKT","text":"toWKT(spref::AbstractSpatialRef, simplify::Bool)\n\nConvert this SRS into a nicely formatted WKT string for display to a person.\n\nParameters\n\nspref:      the SRS to be converted\nsimplify:   true if the AXIS, AUTHORITY and EXTENSION nodes should be               stripped off.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toWKT-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.toWKT","text":"toWKT(spref::AbstractSpatialRef)\n\nConvert this SRS into WKT format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.toXML-Tuple{ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.toXML","text":"toXML(spref::AbstractSpatialRef)\n\nExport coordinate system in XML format.\n\nConverts the loaded coordinate reference system into XML format to the extent possible. LOCALCS coordinate systems are not translatable. An empty string will be returned along with OGRERRNONE.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.transform!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},ArchGDAL.CoordTransform}","page":"API Reference","title":"ArchGDAL.transform!","text":"transform!(xvertices, yvertices, zvertices, obj::CoordTransform)\n\nTransform points from source to destination space.\n\nParameters\n\nxvertices   array of nCount X vertices, modified in place.\nyvertices   array of nCount Y vertices, modified in place.\nzvertices   array of nCount Z vertices, modified in place.\n\nReturns\n\ntrue on success, or false if some or all points fail to transform.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.unsafe_createcoordtrans-Tuple{ArchGDAL.AbstractSpatialRef,ArchGDAL.AbstractSpatialRef}","page":"API Reference","title":"ArchGDAL.unsafe_createcoordtrans","text":"unsafe_createcoordtrans(source::AbstractSpatialRef, target::AbstractSpatialRef)\n\nCreate transformation object.\n\nParameters\n\nsource: source spatial reference system.\ntarget: target spatial reference system.\n\nReturns\n\nNULL on failure or a ready to use transformation object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#API-Utilities-1","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"utilities.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.gdalinfo","page":"API Reference","title":"ArchGDAL.gdalinfo","text":"gdalinfo(dataset::Dataset, options = String[])\n\nList various information about a GDAL supported raster dataset.\n\nParameters\n\ndataset: The source dataset.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdalinfo utility.\n\nReturns\n\nString corresponding to the information about the raster dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdalbuildvrt","page":"API Reference","title":"ArchGDAL.unsafe_gdalbuildvrt","text":"unsafe_gdalbuildvrt(datasets::Vector{Dataset}, options = String[]; dest = \"/vsimem/tmp\")\n\nBuild a VRT from a list of datasets.\n\nParameters\n\ndatasets: The list of input datasets.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdalbuildvrt utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdaldem","page":"API Reference","title":"ArchGDAL.unsafe_gdaldem","text":"unsafe_gdaldem(dataset::Dataset, processing::String, options = String[]; dest = \"/vsimem/tmp\", colorfile)\n\nTools to analyze and visualize DEMs.\n\nParameters\n\ndataset: The source dataset.\npszProcessing: the processing to apply (one of \"hillshade\", \"slope\",   \"aspect\", \"color-relief\", \"TRI\", \"TPI\", \"Roughness\").\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdaldem utility.\n\nKeyword Arguments\n\ncolorfile: color file (mandatory for \"color-relief\" processing,   should be empty otherwise).\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdalgrid","page":"API Reference","title":"ArchGDAL.unsafe_gdalgrid","text":"unsafe_gdalgrid(dataset::Dataset, options = String[]; dest = \"/vsimem/tmp\")\n\nCreate a raster from the scattered data.\n\nParameters\n\ndataset: The source dataset.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdal_grid utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdalnearblack","page":"API Reference","title":"ArchGDAL.unsafe_gdalnearblack","text":"unsafe_gdalnearblack(dataset::Dataset, options = String[]; dest = \"/vsimem/tmp\")\n\nConvert nearly black/white borders to exact value.\n\nParameters\n\ndataset: The source dataset.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the nearblack utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdalrasterize","page":"API Reference","title":"ArchGDAL.unsafe_gdalrasterize","text":"unsafe_gdalrasterize(dataset::Dataset, options = String[]; dest = \"/vsimem/tmp\")\n\nBurn vector geometries into a raster.\n\nParameters\n\ndataset: The source dataset.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdal_rasterize utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdaltranslate","page":"API Reference","title":"ArchGDAL.unsafe_gdaltranslate","text":"unsafe_gdaltranslate(dataset::Dataset, options = String[]; dest = \"/vsimem/tmp\")\n\nConvert raster data between different formats.\n\nParameters\n\ndataset: The dataset to be translated.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdal_translate utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdalvectortranslate","page":"API Reference","title":"ArchGDAL.unsafe_gdalvectortranslate","text":"unsafe_gdalvectortranslate(datasets::Vector{Dataset}, options = String[]; dest = \"/vsimem/tmp\")\n\nConvert vector data between file formats.\n\nParameters\n\ndatasets: The list of input datasets (only 1 supported currently).\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the ogr2ogr utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.unsafe_gdalwarp","page":"API Reference","title":"ArchGDAL.unsafe_gdalwarp","text":"unsafe_gdalwarp(datasets::Vector{Dataset}, options = String[]; dest = \"/vsimem/tmp\")\n\nImage reprojection and warping function.\n\nParameters\n\ndatasets: The list of input datasets.\noptions: List of options (potentially including filename and open   options). The accepted options are the ones of the gdalwarp utility.\n\nReturns\n\nThe output dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#API-Format-Drivers-1","page":"API Reference","title":"Format Drivers","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"driver.jl\"]","category":"page"},{"location":"reference/#ArchGDAL.copyfiles","page":"API Reference","title":"ArchGDAL.copyfiles","text":"copyfiles(drv::Driver, new::AbstractString, old::AbstractString)\ncopyfiles(drvname::AbstractString, new::AbstractString, old::AbstractString)\n\nCopy all the files associated with a dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ArchGDAL.deregister-Tuple{ArchGDAL.Driver}","page":"API Reference","title":"ArchGDAL.deregister","text":"deregister(drv::Driver)\n\nDeregister the passed driver.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.destroy-Tuple{ArchGDAL.Driver}","page":"API Reference","title":"ArchGDAL.destroy","text":"destroy(drv::Driver)\n\nDestroy a GDALDriver.\n\nThis is roughly equivalent to deleting the driver, but is guaranteed to take place in the GDAL heap. It is important this that function not be called on a driver that is registered with the GDALDriverManager.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getdriver-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.getdriver","text":"getdriver(name::AbstractString)\n\nFetch a driver based on the short name (such as GTiff).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.getdriver-Tuple{Integer}","page":"API Reference","title":"ArchGDAL.getdriver","text":"getdriver(i::Integer)\n\nFetch driver by index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.identifydriver-Tuple{AbstractString}","page":"API Reference","title":"ArchGDAL.identifydriver","text":"identifydriver(filename::AbstractString)\n\nIdentify the driver that can open a raster file.\n\nThis function will try to identify the driver that can open the passed filename by invoking the Identify method of each registered GDALDriver in turn. The first driver that successful identifies the file name will be returned. If all drivers fail then NULL is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.listdrivers-Tuple{}","page":"API Reference","title":"ArchGDAL.listdrivers","text":"listdrivers()\n\nReturns a listing of all registered drivers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.longname-Tuple{ArchGDAL.Driver}","page":"API Reference","title":"ArchGDAL.longname","text":"longname(drv::Driver)\n\nReturn the long name of a driver (e.g. GeoTIFF), or empty string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.ndriver-Tuple{}","page":"API Reference","title":"ArchGDAL.ndriver","text":"ndriver()\n\nFetch the number of registered drivers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.options-Tuple{ArchGDAL.Driver}","page":"API Reference","title":"ArchGDAL.options","text":"options(drv::Driver)\n\nReturn the list of creation options of the driver [an XML string].\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.register-Tuple{ArchGDAL.Driver}","page":"API Reference","title":"ArchGDAL.register","text":"register(drv::Driver)\n\nRegister a driver for use.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.shortname-Tuple{ArchGDAL.Driver}","page":"API Reference","title":"ArchGDAL.shortname","text":"shortname(drv::Driver)\n\nReturn the short name of a driver (e.g. GTiff).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArchGDAL.validate-Union{Tuple{T}, Tuple{ArchGDAL.Driver,Array{T,1}}} where T<:AbstractString","page":"API Reference","title":"ArchGDAL.validate","text":"validate(drv::Driver, options::Vector{<:AbstractString})\n\nValidate the list of creation options that are handled by a drv.\n\nThis is a helper method primarily used by create() and copy() to validate that the passed in list of creation options is compatible with the GDAL_DMD_CREATIONOPTIONLIST metadata item defined by some drivers.\n\nParameters\n\ndrv     the handle of the driver with whom the lists of creation option           must be validated\noptions the list of creation options. An array of strings, whose last           element is a NULL pointer\n\nReturns\n\ntrue if the list of creation options is compatible with the create() and createcopy() method of the driver, false otherwise.\n\nAdditional Remarks\n\nSee also: options(drv::Driver)\n\nIf the GDAL_DMD_CREATIONOPTIONLIST metadata item is not defined, this function will return true. Otherwise it will check that the keys and values in the list of creation options are compatible with the capabilities declared by the GDAL_DMD_CREATIONOPTIONLIST metadata item. In case of incompatibility a (non fatal) warning will be emited and false will be returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#API-GeoInterface-1","page":"API Reference","title":"GeoInterface","text":"","category":"section"},{"location":"reference/#","page":"API Reference","title":"API Reference","text":"Modules = [ArchGDAL]\nPages   = [\"geointerface.jl\"]","category":"page"},{"location":"geometries/#Geometric-Operations-1","page":"Geometric Operations","title":"Geometric Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"using ArchGDAL\nconst AG = ArchGDAL","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"In this section, we consider some of the common kinds of geometries that arises in applications. These include Point, LineString, Polygon, GeometryCollection, MultiPolygon, MultiPoint, and MultiLineString. For brevity in the examples, we will use the prefix const AG = ArchGDAL.","category":"page"},{"location":"geometries/#Geometry-Creation-1","page":"Geometric Operations","title":"Geometry Creation","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"To create geometries of different types, ","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"point = AG.createpoint(1.0, 2.0)\nlinestring = AG.createlinestring([(i,i+1) for i in 1.0:3.0])\nlinearring = AG.createlinearring([(0.,0.), (0.,1.), (1.,1.)])\nsimplepolygon = AG.createpolygon([(0.,0.), (0.,1.), (1.,1.)])\ncomplexpolygon = AG.createpolygon([[(0.,0.), (0.,j), (j,j)] for j in 1.0:-0.1:0.9])\nmultipoint = AG.createlinearring([(0.,0.), (0.,1.), (1.,1.)])\nmultilinestring = AG.createmultilinestring([[(i,i+1) for i in j:j+3] for j in 1.0:5.0:6.0])\nmultipolygon = AG.createmultipolygon([[[(0.,0.), (0.,j), (j,j)]] for j in 1.0:-0.1:0.9])","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"Alternatively, they can be assembled from their components.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"point = AG.createpoint()\nAG.addpoint!(point, 1.0, 2.0)\n\nlinestring = AG.createlinestring()\nfor i in 1.0:3.0\n    AG.addpoint!(linestring, i, i+1)\nend\n\nlinearring = AG.createlinearring()\nfor i in 1.0:3.0\n    AG.addpoint!(linearring, i, i+1)\nend\n\npolygon = AG.createpolygon()\nfor j in 1.0:-0.1:0.9\n    ring = AG.createlinearring([(0.,0.), (0.,j), (j,j)])\n    AG.addgeom!(polygon, ring)\nend\n\nmultipoint = AG.createmultipoint()\nfor i in 1.0:3.0\n    pt = AG.createpoint(i, i+1)\n    AG.addgeom!(multipoint, pt)\nend\n\nmultilinestring = AG.createmultilinestring()\nfor j in 1.0:5.0:6.0\n    line = AG.createlinestring([(i,i+1) for i in j:j+3])\n    AG.addgeom!(multilinestring, line)\nend\n\nmultipolygon = AG.createmultipolygon()\nfor j in 1.0:-0.1:0.9\n    poly = AG.createpolygon([(0.,0.), (0.,j), (j,j)])\n    AG.addgeom!(multipolygon, poly)\nend","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"They can also be constructed from other data formats such as:","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"Well-Known Binary (WKB): ArchGDAL.fromWKB([0x01,0x01,...,0x27,0x41])\nWell-Known Text (WKT): ArchGDAL.fromWKT(\"POINT (1 2)\")\nJavaScript Object Notation (JSON): ArchGDAL.fromJSON(\"\"\"{\"type\":\"Point\",\"coordinates\":[1,2]}\"\"\")","category":"page"},{"location":"geometries/#Geometry-Modification-1","page":"Geometric Operations","title":"Geometry Modification","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods are commonly used for retrieving elements of a geometry.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.getcoorddim(geom): dimension of the coordinates. Returns 0 for an empty point\nArchGDAL.getspatialref(geom)\nArchGDAL.getx(geom, i)\nArchGDAL.gety(geom, i)\nArchGDAL.getz(geom, i)\nArchGDAL.getpoint(geom, i)\nArchGDAL.getgeom(geom, i)","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods are commonly used for modifying or adding to a geometry.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.setcoorddim!(geom, dim)\nArchGDAL.setpointcount!(geom, n)\nArchGDAL.setpoint!(geom, i, x, y)\nArchGDAL.setpoint!(geom, i, x, y, z)\nArchGDAL.addpoint!(geom, x, y)\nArchGDAL.addpoint!(geom, x, y, z)\nArchGDAL.addgeom!(geom1, geom2)\nArchGDAL.removegeom!(geom, i)\nArchGDAL.removeallgeoms!(geom)","category":"page"},{"location":"geometries/#Unary-Operations-1","page":"Geometric Operations","title":"Unary Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following is an non-exhaustive list of unary operations available for geometries.","category":"page"},{"location":"geometries/#Attributes-1","page":"Geometric Operations","title":"Attributes","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.geomdim(geom): 0 for points, 1 for lines and 2 for surfaces\nArchGDAL.getcoorddim(geom): dimension of the coordinates. Returns 0 for an empty point\nArchGDAL.envelope(geom): the bounding envelope for this geometry\nArchGDAL.envelope3d(geom): the bounding envelope for this geometry\nArchGDAL.wkbsize(geom): size (in bytes) of related binary representation\nArchGDAL.getgeomtype(geom): geometry type code (in OGRwkbGeometryType)\nArchGDAL.geomname(geom): WKT name for geometry type\nArchGDAL.getspatialref(geom): spatial reference system. May be NULL\nArchGDAL.geomlength(geom): the length of the geometry, or 0.0 for unsupported types\nArchGDAL.geomarea(geom): the area of the geometry, or 0.0 for unsupported types","category":"page"},{"location":"geometries/#Predicates-1","page":"Geometric Operations","title":"Predicates","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following predicates return a Bool.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.isempty(geom)\nArchGDAL.isvalid(geom)\nArchGDAL.issimple(geom)\nArchGDAL.isring(geom)\nArchGDAL.hascurvegeom(geom, nonlinear::Bool)","category":"page"},{"location":"geometries/#Immutable-Operations-1","page":"Geometric Operations","title":"Immutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods do not modify geom.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.clone(geom): a copy of the geometry with the original spatial reference system.\nArchGDAL.forceto(geom, targettype): force the provided geometry to the specified geometry type.\nArchGDAL.simplify(geom, tol): Compute a simplified geometry.\nArchGDAL.simplifypreservetopology(geom, tol): Simplify the geometry while preserving topology.\nArchGDAL.delaunaytriangulation(geom, tol, onlyedges): a delaunay triangulation of the vertices of the geometry.\nArchGDAL.boundary(geom): the boundary of the geometry\nArchGDAL.convexhull(geom): the convex hull of the geometry.\nArchGDAL.buffer(geom, dist, quadsegs): a polygon containing the region within the buffer distance of the original geometry.\nArchGDAL.union(geom): the union of the geometry using cascading\nArchGDAL.pointonsurface(geom): Returns a point guaranteed to lie on the surface.\nArchGDAL.centroid(geom): Compute the geometry centroid. It is not necessarily within the geometry.\nArchGDAL.pointalongline(geom, distance): Fetch point at given distance along curve.\nArchGDAL.polygonize(geom): Polygonizes a set of sparse edges.","category":"page"},{"location":"geometries/#Mutable-Operations-1","page":"Geometric Operations","title":"Mutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods modifies the first argument geom.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.setcoorddim!(geom, dim): sets the explicit coordinate dimension.\nArchGDAL.flattento2d!(geom): Convert geometry to strictly 2D.\nArchGDAL.closerings!(geom): Force rings to be closed by adding the start point to the end.\nArchGDAL.transform!(geom, coordtransform): Apply coordinate transformation to geometry.\nArchGDAL.segmentize!(geom, maxlength): Modify the geometry such it has no segment longer than the given distance.\nArchGDAL.empty!(geom): Clear geometry information.","category":"page"},{"location":"geometries/#Export-Formats-1","page":"Geometric Operations","title":"Export Formats","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.toWKB(geom)\nArchGDAL.toISOWKB(geom)\nArchGDAL.toWKT(geom)\nArchGDAL.toISOWKT(geom)\nArchGDAL.toGML(geom)\nArchGDAL.toKML(geom)\nArchGDAL.toJSON(geom)","category":"page"},{"location":"geometries/#Binary-Operations-1","page":"Geometric Operations","title":"Binary Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following is an non-exhaustive list of binary operations available for geometries.","category":"page"},{"location":"geometries/#Predicates-2","page":"Geometric Operations","title":"Predicates","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following predicates return a Bool.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.intersects(g1, g2)\nArchGDAL.equals(g1, g2)\nArchGDAL.disjoint(g1, g2)\nArchGDAL.touches(g1, g2)\nArchGDAL.crosses(g1, g2)\nArchGDAL.within(g1, g2)\nArchGDAL.contains(g1, g2)\nArchGDAL.overlaps(g1, g2)","category":"page"},{"location":"geometries/#Immutable-Operations-2","page":"Geometric Operations","title":"Immutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following methods do not mutate the input geomteries g1 and g2.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.intersection(g1, g2)\nArchGDAL.union(g1, g2)\nArchGDAL.difference(g1, g2)\nArchGDAL.symdifference(g1, g2)","category":"page"},{"location":"geometries/#Mutable-Operations-2","page":"Geometric Operations","title":"Mutable Operations","text":"","category":"section"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"The following method modifies the first argument g1.","category":"page"},{"location":"geometries/#","page":"Geometric Operations","title":"Geometric Operations","text":"ArchGDAL.addgeom!(g1, g2)","category":"page"},{"location":"memory/#Interactive-versus-Scoped-Objects-1","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL provides two approaches for working with GDAL objects.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"The first approach is through Scoped Objects, which uses do-blocks as context managers. The problem with using do-blocks to manage context is that they are difficult to work with in an interactive way:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.read(filename) do dataset\n    # dataset exists within this scope\nend\n# we do not have access to dataset from here on","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"In the example above, we do not get to see information about dataset unless we write code to display information within the scope of the do-block. This makes it difficult to work with it in an exploratory \"depth-first\" manner.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"The second approach is through Interactive Objects, which are designed for use at the REPL.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"dataset = ArchGDAL.read(filename)\n# work with dataset","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"A potential drawback of the second approach is that the objects are managed by Julia's garbage collector. This requires ArchGDAL to keep track of objects that interactive objects have a relationship with so that the interactive objects are not prematurely destroyed. For safety, ArchGDAL might make clones/copies of the underlying data, and only allow a subset of GDAL's objects to be created in this way.","category":"page"},{"location":"memory/#Memory-Management-(Advanced)-1","page":"Interactive versus Scoped Objects","title":"Memory Management (Advanced)","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"Unlike the design of fiona, ArchGDAL does not immediately make copies from data sources. This introduces concerns about memory management (whether objects should be managed by Julia's garbage collector, or by other means of destroying GDAL object when they are out of scope).","category":"page"},{"location":"memory/#Scoped-Objects-1","page":"Interactive versus Scoped Objects","title":"Scoped Objects","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"For scoped objects, they are often created within the context of a do-block. As an example, the following code block","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.getband(dataset, i) do rasterband\n    # do something with rasterband\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"corresponds to the following sequence of function calls:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"rasterband = ArchGDAL.unsafe_getband(dataset, i)\ntry\n    # do something with rasterband\nfinally\n    ArchGDAL.destroy(rasterband)\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"under the hood (see src/context.jl). Therefore, the objects themselves do not have a finalizer registered:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"mutable struct RasterBand <: AbstractRasterBand\n    ptr::GDALRasterBand\nend\n\nunsafe_getband(dataset::AbstractDataset, i::Integer) =\n    RasterBand(GDAL.getrasterband(dataset.ptr, i))\n\nfunction destroy(rb::AbstractRasterBand)\n    rb.ptr = GDALRasterBand(C_NULL)\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"note: Note\nWe use the unsafe_ prefix to indicate those methods that return scoped objects. These methods should not be used by users directly.","category":"page"},{"location":"memory/#Interactive-Objects-1","page":"Interactive versus Scoped Objects","title":"Interactive Objects","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"By contrast, the following code","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"rasterband = ArchGDAL.getband(dataset, i)\n# do something with rasterband","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"returns an interactive rasterband that has destroy() registered with its finalizer.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"mutable struct IRasterBand <: AbstractRasterBand\n    ptr::GDALRasterBand\n    ownedby::AbstractDataset\n\n    function IRasterBand(\n            ptr::GDALRasterBand = GDALRasterBand(C_NULL);\n            ownedby::AbstractDataset = Dataset()\n        )\n        rasterband = new(ptr, ownedby)\n        finalizer(destroy, rasterband)\n        return rasterband\n    end\nend\n\ngetband(dataset::AbstractDataset, i::Integer) =\n    IRasterBand(GDAL.getrasterband(dataset.ptr, i), ownedby = dataset)\n\nfunction destroy(rasterband::IRasterBand)\n    rasterband.ptr = GDALRasterBand(C_NULL)\n    rasterband.ownedby = Dataset()\n    return rasterband\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"The I in IRasterBand indicates that it is an [i]nteractive type. Other interactive types include IDataset, IFeatureLayer, ISpatialRef and IGeometry.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL requires all interactive types to have a finalizer that calls destroy() on them. All objects that have a relationship with an interactive object are required to hold a reference to the interactive object. For example, objects of type IRasterBand might have a relationship with an IDataset, therefore they have an ownedby attribute which might refer to such a dataset.","category":"page"},{"location":"memory/#Views-1","page":"Interactive versus Scoped Objects","title":"Views","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"Sometimes, it is helpful to work with objects that are \"internal references\" that have restrictions on the types of methods that they support. As an example layerdefn(featurelayer) returns a feature definition that is internal to the feature layer, and does not support methods such as write!(featuredefn, fielddefn) and deletegeomdefn!(featuredefn, i). To indicate that they might have restrictions, some types have View as a postfix. Such types include IFeatureDefnView, IFieldDefnView, and IGeomFieldDefnView.","category":"page"},{"location":"memory/#Summary-1","page":"Interactive versus Scoped Objects","title":"Summary","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"To summarize,","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.unsafe_<method>(args...) will return a scoped object. The proper way of using them is within the setting of a do-block:","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.<method>(args...) do result\n    # result is a scoped object\nend","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"ArchGDAL.<method>(args...) will return an interactive object.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"result = ArchGDAL.<method>(args...)\n# result is an interactive object","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"note: Note\nUsers are allowed to mix both \"interactive\" and \"scoped\" objects. As long as they do not manually call ArchGDAL.destroy() on any object, ArchGDAL is designed to avoid the pitfalls of GDAL memory management (e.g. in Python Gotchas).","category":"page"},{"location":"memory/#References-1","page":"Interactive versus Scoped Objects","title":"References","text":"","category":"section"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"Here's a collection of references for developers who are interested.","category":"page"},{"location":"memory/#","page":"Interactive versus Scoped Objects","title":"Interactive versus Scoped Objects","text":"https://docs.julialang.org/en/v1.3/manual/calling-c-and-fortran-code/\nhttps://github.com/JuliaLang/julia/issues/7721\nhttps://github.com/JuliaLang/julia/issues/11207\nhttps://gdal.org/api/python_gotchas.html\nhttps://lists.osgeo.org/pipermail/gdal-dev/2010-September/026027.html\nhttps://sgillies.net/2013/12/17/teaching-python-gis-users-to-be-more-rational.html\nhttps://pcjericks.github.io/py-gdalogr-cookbook/gotchas.html#features-and-geometries-have-a-relationship-you-don-t-want-to-break","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"#=\nThis piece of documentation is currently commented out until the GDAL build provided by GDAL.jl provides spatialite support.\nCurrently it already includes sqlite support, so everything up to X(Geometry) works, but then it doesn't recognize that function.\nThe reason this is commented out is because Documenter.jl would still run the examples here and give warnings that they didn't work.\n\n# Working with Spatialite\n\nHere is an example of how you can work with a SQLite Database in ArchGDAL.jl, and follows the tutorial in [http://www.gaia-gis.it/gaia-sins/spatialite-tutorial-2.3.1.html](http://www.gaia-gis.it/gaia-sins/spatialite-tutorial-2.3.1.html).\n\nWe will work with the following database:\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite import ArchGDAL const AG = ArchGDAL","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"filepath = download(\"https://github.com/yeesian/ArchGDALDatasets/raw/e0b15dca5ad493c5ebe8111688c5d14b031b7305/spatialite/test-2.3.sqlite\", \"test.sqlite\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\nHere's a quick summary of `test.sqlite`:\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite AG.read(filepath) do dataset     print(dataset) end","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\nWe will display the results of running `query` on the dataset using the following function:\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite function inspect(query, filename=filepath)     AG.read(filename) do dataset         AG.executesql(dataset, query) do results             print(results)         end     end end","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n## Constructing SQL Queries\n\n### A Simple LIMIT Query\nHere's a first query:","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"SELECT * FROM towns LIMIT 5\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\nA few points to understand:\n* the `SELECT` statement requests SQLite to perform a query\n* fetching all columns `[*]`\n* `FROM` the database table of name `towns`\n* retrieving only the first five rows [`LIMIT 5`]\n\n### A Simple ORDER BY Query\nNow try this second SQL query:\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"select name AS Town, peoples as Population from towns ORDER BY name LIMIT 5\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\nSome remarks:\n* in SQL, constructs using lower- or upper-case have identical effects; So the commands constructed using `SELECT` and `select`, or `FROM` and `from` are equivalent.\n* you can freely choose which columns to fetch, determine their ordering, and rename then if you wish by using the `AS` clause.\n* you can order the fetched rows by using the `ORDER BY` clause.\n\n### The WHERE and ORDER BY clauses\nA more complex SQL query:","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\"select name, peoples from towns            WHERE peoples > 350000 order by peoples DESC\"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\nSome remarks:\n* you can filter a specific set of rows by imposing a `WHERE` clause; only those rows that satisfies the logical expression you specify will be fetched.\n* In this example only `towns` with a population greater than `350000` peoples has been fetched.\n* you can order rows in *descending* order if appropriate, by using the `DESC` clause.\n\n### Using SQL functions","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" select COUNT() as '# Towns',     MIN(peoples) as Smaller,     MAX(peoples) as Bigger,     SUM(peoples) as 'Total peoples',     SUM(peoples) / COUNT() as 'mean peoples for town' from towns \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n* you can split complex queries along many lines\n* you can use *functions* in an SQL query. `COUNT()`, `MIN()`, `MAX()` and `SUM()` are functions. Not at all surprisingly:\n    * `COUNT()` returns the total number of rows.\n    * `MIN()` returns the minimum value for the given column.\n    * `MAX()` returns the maximum value for the given column.\n    * `SUM()` returns the total of all values for the given column.\n* you can do *calculations* in your query. e.g. we have calculated the `mean` of peoples per village dividing the `SUM()` by the `COUNT()` values.\n\n### Constructing Expressions\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"select (10 - 11) * 2 as Number, ABS((10 - 11) * 2) as AbsoluteValue\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n* the `(10 - 11) * 2` term is an example of an `expression`.\n* the `ABS()` function returns the *absolute value* of a number.\n* note that in this example we have not used any DB column or DB table at all.\n\n### The HEX() function","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" select name, peoples, HEX(Geometry) from Towns where peoples > 350000 order by peoples DESC \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n* the `HEX()` function returns the hexadecimal representation of a `BLOB` column value.\n* in the preceding execution of this query, the geom column seemed empty; now, by using the `HEX()` function, we discover that it contains lots of strange binary data.\n* *geom* contains `GEOMETRY` values, stored as `BLOB`s and encoded in the internal representation used by SpatiaLite.\n\n!!! note\n    \n    SQLite in its own hasn't the slightest idea of what `GEOMETRY` is, and cannot do any other operation on it. To really use `GEOMETRY` values, it's time use the SpatiaLite extension.\n\n## Spatialite Features\n\n### Well-Known Text","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT name, peoples, AsText(Geometry) from Towns where peoples > 350000 order by peoples DESC \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* the `AsText()` function comes from SpatiaLite, and returns the *Well Known Text - WKT* representation for a `GEOMETRY` column value. WKT is a standard notation conformant to OpenGIS specification.\n* in the preceding execution of this query, the `HEX()` function returned lots of strange binary data. Now the `AsText()` function shows useful and quite easily understandable `GEOMETRY` values.\n* a `POINT` is the simplest `GEOMETRY` class, and has only a couple of `[X,Y]` coordinates.\n\n### Working with Coordinates","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT name, X(Geometry), Y(Geometry) FROM Towns WHERE peoples > 350000  ORDER BY peoples DESC \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* the SpatiaLite `X()` function returns the *X coordinate* for a `POINT`.\n* the `Y()` function returns the *Y coordinate* for a `POINT`.\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"SELECT HEX(GeomFromText('POINT(10 20)'))\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n### Format Conversions\nyou can use the following `GEOMETRY` format conversion functions:","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"SELECT HEX(AsBinary(GeomFromText('POINT(10 20)')))\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"SELECT AsText(GeomFromWKB(X'010100000000000000000024400000000000003440'))\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* the SpatiaLite `GeomFromText()` function returns the internal `BLOB` representation for a `GEOMETRY`.\n* the `AsBinary()` function returns the *Well Known Binary - WKB* representation for a `GEOMETRY` column value. WKB is a standard notation conformant to OpenGIS specification.\n* the `GeomFromWKB()` function converts a WKB value into the corresponding internal `BLOB` value.\n\n## GEOMETRY Classes\n\n### LINESTRING","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"SELECT PKUID, AsText(Geometry) FROM HighWays WHERE PKUID = 10\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* `LINESTRING` is another `GEOMETRY` class, and has lots of `POINT`s.\n* in this case you have fetched a very simple `LINESTRING`, representing a polyline with just 4 vertices.\n* it isn't unusual to encounter `LINESTRING`s with thousands of vertices in real GIS data.\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT PK_UID, NumPoints(Geometry), GLength(Geometry),        Dimension(Geometry), GeometryType(Geometry) FROM HighWays ORDER BY NumPoints(Geometry) DESC LIMIT 5 \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* the SpatiaLite `NumPoints()` function returns the *number of vertices* for a `LINESTRING GEOMETRY`.\n* the `GLength()` function returns the *geometric length* [expressed in *map units*] for a `LINESTRING GEOMETRY`.\n* the `Dimension()` function returns the *dimensions'* number for any `GEOMETRY` class [e.g. 1 for lines].\n* the `GeometryType()` function returns the *class type* for any kind of `GEOMETRY` value.\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT PK_UID, NumPoints(Geometry),        AsText(StartPoint(Geometry)), AsText(EndPoint(Geometry)),        X(PointN(Geometry, 2)), Y(PointN(Geometry, 2)) FROM HighWays ORDER BY NumPoints(Geometry) DESC LIMIT 5 \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n* the SpatiaLite `StartPoint()` function returns the first `POINT` for a `LINESTRING GEOMETRY`.\n* the `EndPoint()` function returns the last `POINT` for a `LINESTRING GEOMETRY`.\n* the `PointN()` function returns the selected vertex as a `POINT`; each one vertex is identified by a relative index. The first vertex is identified by an index value `1`, the second by an index value `2` and so on.\n* You can freely nest the various SpatiaLite functions, by passing the return value of the inner function as an argument for the outer one.\n\n### POLYGON","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"SELECT name, AsText(Geometry) FROM Regions WHERE PK_UID = 52\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* `POLYGON` is another `GEOMETRY` class.\n* in this case you have fetched a very simple `POLYGON`, having only the *exterior ring* [i.e. it doesn't contains any internal hole]. Remember that POLYGONs may optionally contain an arbitrary number of *internal holes*, each one delimited by an *interior ring*.\n* the *exterior ring* in itself is simply a `LINESTRING` [and *interior rings* too are `LINESTRINGS`].\n* note that a POLYGON is a *closed geometry*, and thus the first and the last POINT for each *ring* are exactly identical.\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT PK_UID, Area(Geometry), AsText(Centroid(Geometry)),        Dimension(Geometry), GeometryType(Geometry) FROM Regions ORDER BY Area(Geometry) DESC LIMIT 5 \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* we have already meet the SpatiaLite `Dimension()` and `GeometryType()` functions; they works for `POLYGON`s exactly in same fashion as for any other kind of `GEOMETRY`.\n* the SpatiaLite `Area()` function returns the geometric area [expressed in *square map units*] for a `POLYGON GEOMETRY`.\n* the `Centroid()` function returns the `POINT` identifying the *centroid* for a `POLYGON GEOMETRY`.\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT PK_UID, NumInteriorRings(Geometry),        NumPoints(ExteriorRing(Geometry)), NumPoints(InteriorRingN(Geometry, 1)) FROM regions ORDER BY NumInteriorRings(Geometry) DESC LIMIT 5 \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"\n* the SpatiaLite `ExteriorRing()` functions returns the exterior ring for a given `GEOMETRY`. Any valid `POLYGON` must have an *exterior ring*. Remember: each one of the rings belonging to a `POLYGON` is a closed `LINESTRING`.\n* the SpatiaLite `NumInteriorRings()` function returns the number of interior rings belonging to a `POLYGON`. A valid `POLYGON` may have any number of interior rings, including *zero* i.e. no interior ring at all.\n* The SpatiaLite `InteriorRingN()` function returns the selected interior rings as a `LINESTRING`; each one interior ring is identified by a relative index. The first interior ring is identified by an index value `1`, the second by an index value `2` and so on.\n* Any ring is a `LINESTRING`, so we can use the `NumPoints()` function in order to detect the number of related vertices. If we call the `NumPoints()` function on a `NULL GEOMETRY` [or on a `GEOMETRY` of non-`LINESTRING` class] we'll get a `NULL` result. This explains why the the last three rows has a `NULL` `NumPoints()` result; there is no corresponding interior ring!\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT AsText(InteriorRingN(Geometry, 1)),        AsText(PointN(InteriorRingN(Geometry, 1), 4)),        X(PointN(InteriorRingN(Geometry, 1), 5)),        Y(PointN(InteriorRingN(Geometry, 1), 5)) FROM Regions WHERE PK_UID = 55 \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* we have already met in the preceding ones the usage of nested functions. For `POLYGON`s it becomes to be a little more tedious, but still easily understandable.\n* e.g. to obtain the last column we have used `InteriorRingN()` in order to get the first interior ring, and then `PointN()` to get the *fifth* vertex. At last we can call `Y()` to get the coordinate value.\n","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"@example spatialite inspect(\"\"\" SELECT Name, AsText(Envelope(Geometry)) FROM Regions LIMIT 5 \"\"\")","category":"page"},{"location":"spatialite/#","page":"-","title":"-","text":"* the SpatiaLite `Envelope()` function always returns a `POLYGON` that is the *Minimum Bounding Rectangle - MBR* for the given `GEOMETRY`. Because an MBR is a rectangle, it always has `5 POINT`s [remember: in closed geometries the last POINT must be identical to the first one].\n* individual `POINT`s are as follows:\n    * POINT #1: `minX,minY`\n    * POINT #2: `maxX,minY`\n    * POINT #3: `maxX,maxY`\n    * POINT #4: `minX,maxY`\n    * POINT #5: `minX,minY`\n* MBRs are of peculiar interest, because by using them you can evaluate spatial relationships between two geometries in a simplified and roughly approximative way. But MBR comparisons are very fast to compute, so they are very useful and widely used to speed up data processing.\n* MBRs are also widely referenced as *bounding boxes*, or \"BBOX\" as well.\n\n### Complex Geometry Classes\n`POINT`, `LINESTRING` and `POLYGON` are the elementary classes for `GEOMETRY`. But `GEOMETRY` supports the following complex classes as well:\n* a `MULTIPOINT` is a collection of two or more `POINT`s belonging to the same entity.\n* a `MULTILINESTRING` is a collection of two or more `LINESTRING`s.\n* a `MULTIPOLYGON` is a collection of two or more `POLYGON`s.\n* a `GEOMETRYCOLLECTION` is an arbitrary collection containing any other kind of geometries.\n\nWe'll not explain in detail this kind of collections, because it will be simply too boring and dispersive. Generally speaking, they extend in the expected way to their corresponding elementary classes, e.g.\n* the SpatiaLite `NumGeometries()` function returns the number of elements for a collection.\n* the `GeometryN()` function returns the *N-th* element for a collection.\n* the `GLength()` function applied to a `MULTILINESTRING` returns the sum of individual lengths for each `LINESTRING` composing the collection.\n* the `Area()` function applied to a `MULTIPOLYGON` returns the sum of individual areas for each `POLYGON` in the collection.\n* the `Centroid()` function returns the *average centroid* when applied to a `MULTIPOLYGON`.\n=#","category":"page"},{"location":"#ArchGDAL.jl-documentation-1","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"GDAL is a translator library for raster and vector geospatial data formats that is released under an X/MIT license by the Open Source Geospatial Foundation. As a library, it presents an abstract data model to drivers for various raster and vector formats.","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"ArchGDAL.jl aims to be a complete solution for working with GDAL in Julia, similar in scope to the SWIG bindings for Python. It builds on top of GDAL.jl, and provides a high level API for GDAL, espousing the following principles.","category":"page"},{"location":"#Principles-(The-Arch-Way)-1","page":"ArchGDAL.jl documentation","title":"Principles (The Arch Way)","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"(adapted from https://wiki.archlinux.org/index.php/Arch_Linux#Principles)","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"simplicity: without unnecessary additions or modifications. It preserves the GDAL Data Model and requires minimal dependencies.\nmodernity: ArchGDAL strives to maintain the latest stable release versions of GDAL as long as systemic package breakage can be reasonably avoided.\npragmatism: The principles here are only useful guidelines. Ultimately, design decisions are made on a case-by-case basis through developer consensus. Evidence-based technical analysis and debate are what matter, not politics or popular opinion.\nuser-centrality: Whereas other libraries attempt to be more user-friendly, ArchGDAL shall be user-centric. It is intended to fill the needs of those contributing to it, rather than trying to appeal to as many users as possible.\nversatility: ArchGDAL will strive to remain small in its assumptions about the range of user-needs, and to make it easy for users to build their own extensions/conveniences.","category":"page"},{"location":"#Installation-1","page":"ArchGDAL.jl documentation","title":"Installation","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"To install this package, run the following command in the Pkg REPL-mode,","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"pkg> add ArchGDAL","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"To test if it is installed correctly,","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"pkg> test ArchGDAL","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"To load the package,","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"julia> using ArchGDAL","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"In the documentation AG is often used as a shorthand for ArchGDAL. To use this shorthand you can use:","category":"page"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"using ArchGDAL\nconst AG = ArchGDAL","category":"page"},{"location":"#Contents-1","page":"ArchGDAL.jl documentation","title":"Contents","text":"","category":"section"},{"location":"#","page":"ArchGDAL.jl documentation","title":"ArchGDAL.jl documentation","text":"","category":"page"},{"location":"projections/#Spatial-Projections-1","page":"Spatial Projections","title":"Spatial Projections","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"using ArchGDAL\nconst AG = ArchGDAL","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"(This is based entirely on the GDAL/OSR Tutorial and Python GDAL/OGR Cookbook.)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"The ArchGDAL.SpatialRef, and ArchGDAL.CoordTransform types are lightweight wrappers around GDAL objects that represent coordinate systems (projections and datums) and provide services to transform between them. These services are loosely modeled on the OpenGIS Coordinate Transformations specification, and use the same Well Known Text format for describing coordinate systems.","category":"page"},{"location":"projections/#Coordinate-Systems-1","page":"Spatial Projections","title":"Coordinate Systems","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"There are two primary kinds of coordinate systems. The first is geographic (positions are measured in long/lat) and the second is projected (such as UTM - positions are measured in meters or feet).","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"Geographic Coordinate Systems: A Geographic coordinate system contains information on the datum (which implies an spheroid described by a semi-major axis, and inverse flattening), prime meridian (normally Greenwich), and an angular units type which is normally degrees.\nProjected Coordinate Systems: A projected coordinate system (such as UTM, Lambert Conformal Conic, etc) requires and underlying geographic coordinate system as well as a definition for the projection transform used to translate between linear positions (in meters or feet) and angular long/lat positions.","category":"page"},{"location":"projections/#Creating-Spatial-References-1","page":"Spatial Projections","title":"Creating Spatial References","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"spatialref = ArchGDAL.importEPSG(2927)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"ArchGDAL.toPROJ4(spatialref)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"The details of how to interpret the results can be found in http://proj4.org/usage/projections.html.","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"In the above example, we constructed a SpatialRef object from the EPSG Code 2927. There are a variety of other formats from which SpatialRefs can be constructed, such as","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"ArchGDAL.importEPSG(::Int): based on the EPSG code\nArchGDAL.importEPSGA(::Int): based on the EPSGA code\nArchGDAL.importESRI(::String): based on ESRI projection codes\n[ArchGDAL.importPROJ4(::String) based on the PROJ.4 string (reference)\nArchGDAL.importURL(::String): download from a given URL and feed it into SetFromUserInput for you.\nArchGDAL.importWKT(::String): WKT string\nArchGDAL.importXML(::String): XML format (GML only currently)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"We currently support a few export formats too:","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"ArchGDAL.toMICoordSys(spref): Mapinfo style CoordSys format.\nArchGDAL.toPROJ4(spref): coordinate system in PROJ.4 format.\nArchGDAL.toWKT(spref): nicely formatted WKT string for display to a person.\nArchGDAL.toXML(spref): converts into XML format to the extent possible.","category":"page"},{"location":"projections/#Reprojecting-a-Geometry-1","page":"Spatial Projections","title":"Reprojecting a Geometry","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"source = ArchGDAL.importEPSG(2927)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"target = ArchGDAL.importEPSG(4326)","category":"page"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"ArchGDAL.createcoordtrans(source, target) do transform\n    point = ArchGDAL.fromWKT(\"POINT (1120351.57 741921.42)\")\n    println(\"Before: $(ArchGDAL.toWKT(point))\")\n    ArchGDAL.transform!(point, transform)\n    println(\"After: $(ArchGDAL.toWKT(point))\")\nend","category":"page"},{"location":"projections/#References-1","page":"Spatial Projections","title":"References","text":"","category":"section"},{"location":"projections/#","page":"Spatial Projections","title":"Spatial Projections","text":"Some background on OpenGIS coordinate systems and services can be found in the Simple Features for COM, and Spatial Reference Systems Abstract Model documents available from the Open Geospatial Consortium. The GeoTIFF Projections Transform List may also be of assistance in understanding formulations of projections in WKT. The EPSG Geodesy web page is also a useful resource. You may also consult the OGC WKT Coordinate System Issues page.","category":"page"}]
}
