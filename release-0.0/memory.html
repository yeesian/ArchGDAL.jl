<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Memory Management · ArchGDAL.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ArchGDAL.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">ArchGDAL.jl documentation</a></li><li><a class="toctext" href="datasets.html">GDAL Datasets</a></li><li><a class="toctext" href="features.html">Feature Data</a></li><li><a class="toctext" href="rasters.html">Raster Data</a></li><li><a class="toctext" href="geometries.html">Geometric Operations</a></li><li><a class="toctext" href="projections.html">Spatial Projections</a></li><li class="current"><a class="toctext" href="memory.html">Memory Management</a><ul class="internal"><li><a class="toctext" href="#Manual-versus-Context-Management-1">Manual versus Context Management</a></li><li><a class="toctext" href="#Interactive-versus-Scoped-Geometries-1">Interactive versus Scoped Geometries</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="spatialite.html">Working with Spatialite</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="memory.html">Memory Management</a></li></ul><a class="edit-page" href="https://github.com/yeesian/ArchGDAL.jl/blob/master/docs/src/memory.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Memory Management</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Memory-Management-1" href="#Memory-Management-1">Memory Management</a></h1><p>Unlike the <a href="http://toblerity.org/fiona/manual.html#introduction">design of fiona</a>, <code>ArchGDAL</code> does not automatically copy data from her data sources. This introduces concerns about memory management (whether objects should be managed by Julia&#39;s garbage collector, or by manually destroying the corresponding GDAL object).</p><p>Currently this package provides data types corresponding to GDAL&#39;s Data Model, e.g.</p><pre><code class="language-julia">mutable struct ColorTable;                    ptr::GDALColorTable         end
mutable struct CoordTransform;                ptr::GDALCoordTransform     end
mutable struct Dataset;                       ptr::GDALDataset            end
mutable struct Driver;                        ptr::GDALDriver             end
mutable struct Feature;                       ptr::GDALFeature            end
mutable struct FeatureDefn;                   ptr::GDALFeatureDefn        end
mutable struct FeatureLayer;                  ptr::GDALFeatureLayer       end
mutable struct Field;                         ptr::GDALField              end
mutable struct FieldDefn;                     ptr::GDALFieldDefn          end
mutable struct Geometry &lt;: AbstractGeometry;  ptr::GDALGeometry           end
mutable struct GeomFieldDefn;                 ptr::GDALGeomFieldDefn      end
mutable struct RasterAttrTable;               ptr::GDALRasterAttrTable    end
mutable struct RasterBand;                    ptr::GDALRasterBand         end
mutable struct SpatialRef;                    ptr::GDALSpatialRef         end
mutable struct StyleManager;                  ptr::GDALStyleManager       end
mutable struct StyleTable;                    ptr::GDALStyleTable         end
mutable struct StyleTool;                     ptr::GDALStyleTool          end</code></pre><p>and makes it the responsibility of the user to free the allocation of memory from GDAL, by calling <code>ArchGDAL.destroy(obj)</code> (which sets <code>obj.ptr</code> to <code>C_NULL</code> after destroying the GDAL object corresponding to <code>obj</code>).</p><h2><a class="nav-anchor" id="Manual-versus-Context-Management-1" href="#Manual-versus-Context-Management-1">Manual versus Context Management</a></h2><p>There are two approaches for doing so.</p><ol><li><p>The first uses the <a href="https://docs.julialang.org/en/v0.6.2/manual/style-guide/#Don&#39;t-expose-unsafe-operations-at-the-interface-level-1"><code>unsafe_</code> prefix</a> to indicate methods that returns objects that needs to be manually destroyed.</p></li><li><p>The second uses <a href="https://docs.julialang.org/en/release-0.6/manual/functions/#do-block-syntax-for-function-arguments"><code>do</code>-blocks</a> as context managers.</p></li></ol><p>The first approach will result in code that looks like</p><pre><code class="language-julia">dataset = ArchGDAL.unsafe_read(filename)
# work with dataset
ArchGDAL.destroy(dataset) # the equivalent of GDAL.close(dataset.ptr)</code></pre><p>This can be helpful when working interactively with <code>dataset</code> at the REPL. The second approach will result in the following code</p><pre><code class="language-julia">ArchGDAL.read(filename) do dataset
    # work with dataset
end</code></pre><p>which uses <code>do</code>-blocks to scope the lifetime of the <code>dataset</code> object.</p><h2><a class="nav-anchor" id="Interactive-versus-Scoped-Geometries-1" href="#Interactive-versus-Scoped-Geometries-1">Interactive versus Scoped Geometries</a></h2><p>There is a third option for managing memory, which is to register a finalizer with julia, which gets called by the garbage collector at some point after it is out-of-scope. This is in contrast to an approach where users manage memory by working with it within the scope of a <code>do</code>-block, or by manually destroying objects themselves. </p><p>Therefore, we introduce an <code>AbstractGeometry</code> type:</p><pre><code class="language-julia">abstract type AbstractGeometry &lt;: GeoInterface.AbstractGeometry end</code></pre><p>which is then subtyped into <code>Geometry</code> and <code>IGeometry</code></p><pre><code class="language-julia">mutable struct Geometry &lt;: AbstractGeometry
    ptr::GDALGeometry
end

mutable struct IGeometry &lt;: AbstractGeometry
    ptr::GDALGeometry

    function IGeometry(ptr::GDALGeometry)
        geom = new(GDAL.clone(ptr))
        finalizer(geom, destroy)
        geom
    end
end</code></pre><p>Objects of type <code>IGeometry</code> use the third type of memory management, where we register <code>ArchGDAL.destroy()</code> as a <a href="https://docs.julialang.org/en/release-0.6/stdlib/base/?highlight=finalizer#Base.finalizer"><code>finalizer</code></a>. This is useful for users who are interested in working with geometries in a julia session, when they wish to read it from a geospatial database into a dataframe, and want it to persist within the julia session even after the connection to the database has been closed.</p><p>As a result, the general API for geometries is</p><ul><li><p><code>unsafe_&lt;method&gt;(G, args...)</code> will return a geometry of type <code>G</code> (one of <code>Geometry</code> or <code>IGeometry</code>).</p></li><li><p><code>unsafe_&lt;method&gt;(args...)</code> will return a geometry of type <code>Geometry</code> (which</p></li></ul><p>has to be destroyed by the user).</p><ul><li><p><code>&lt;method&gt;(::Function, args...)</code> allows for the <code>do</code>-block syntax which creates a <code>geometry::Geometry</code> which is operated on by the function, before being destroyed.</p></li><li><p><code>&lt;method&gt;(args...)</code> returns a geometry of type <code>IGeometry</code>.</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>So long as the user does not manually call <code>ArchGDAL.destroy()</code> on any object themselves, users are allowed to mix both the methods of memory management (i) using <code>do</code>-blocks for scoped geometries, and (ii) using finalizers for interactive geometries. However, there are plenty of pitfalls (e.g. in <a href="https://trac.osgeo.org/gdal/wiki/PythonGotchas">PythonGotchas</a>) if users try to mix in their own custom style of calling <code>ArchGDAL.destroy()</code>.</p></div></div><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>Here&#39;s a collection of references for developers who are interested.</p><ul><li><p>http://docs.julialang.org/en/release-0.4/manual/calling-c-and-fortran-code/</p></li><li><p>https://github.com/JuliaLang/julia/issues/7721</p></li><li><p>https://github.com/JuliaLang/julia/issues/11207</p></li><li><p>https://trac.osgeo.org/gdal/wiki/PythonGotchas</p></li><li><p>https://lists.osgeo.org/pipermail/gdal-dev/2010-September/026027.html</p></li><li><p>https://sgillies.net/2013/12/17/teaching-python-gis-users-to-be-more-rational.html</p></li><li><p>https://pcjericks.github.io/py-gdalogr-cookbook/gotchas.html#features-and-geometries-have-a-relationship-you-don-t-want-to-break</p></li></ul><footer><hr/><a class="previous" href="projections.html"><span class="direction">Previous</span><span class="title">Spatial Projections</span></a><a class="next" href="spatialite.html"><span class="direction">Next</span><span class="title">Working with Spatialite</span></a></footer></article></body></html>
